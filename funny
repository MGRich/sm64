diff --git a/actors/burn_smoke/model.inc.c b/actors/burn_smoke/model.inc.c
index a0f6557..18da5d2 100644
--- a/actors/burn_smoke/model.inc.c
+++ b/actors/burn_smoke/model.inc.c
@@ -2,10 +2,10 @@
 
 // 0x040217C0
 static const Vtx burn_smoke_seg4_vertex_040217C0[] = {
-    {{{   -50,    -50,      0}, 0, {     0,    992}, {0x14, 0x0a, 0x0a, 0xff}}},
-    {{{    50,    -50,      0}, 0, {   992,    992}, {0x14, 0x0a, 0x0a, 0xff}}},
-    {{{    50,     50,      0}, 0, {   992,      0}, {0x14, 0x0a, 0x0a, 0xff}}},
-    {{{   -50,     50,      0}, 0, {     0,      0}, {0x14, 0x0a, 0x0a, 0xff}}},
+    { { { -50, -50, 0 }, 0, { 0, 992 }, { 0x14, 0x0a, 0x0a, 0xff } } },
+    { { { 50, -50, 0 }, 0, { 992, 992 }, { 0x14, 0x0a, 0x0a, 0xff } } },
+    { { { 50, 50, 0 }, 0, { 992, 0 }, { 0x14, 0x0a, 0x0a, 0xff } } },
+    { { { -50, 50, 0 }, 0, { 0, 0 }, { 0x14, 0x0a, 0x0a, 0xff } } },
 };
 
 // //! Wrong texture format. Called as rgba16, which makes the burn smoke appear
@@ -28,7 +28,7 @@ const Gfx burn_smoke_seg4_dl_04022000[] = {
 // 0x04022028 - 0x04022048
 const Gfx burn_smoke_seg4_dl_04022028[] = {
     gsSPVertex(burn_smoke_seg4_vertex_040217C0, 4, 0),
-    gsSP2Triangles( 0,  1,  2, 0x0,  0,  2,  3, 0x0),
+    gsSP2Triangles(0, 1, 2, 0x0, 0, 2, 3, 0x0),
     gsSPEndDisplayList(),
 };
 
@@ -44,7 +44,8 @@ const Gfx burn_smoke_seg4_dl_04022048[] = {
 // 0x04022070 - 0x040220C8
 const Gfx burn_smoke_seg4_dl_04022070[] = {
     gsSPDisplayList(burn_smoke_seg4_dl_04022000),
-    gsDPLoadTextureBlock(burn_smoke_seg4_texture_04021800, G_IM_FMT_RGBA, G_IM_SIZ_16b, 32, 32, 0, G_TX_CLAMP, G_TX_CLAMP, 5, 5, G_TX_NOLOD, G_TX_NOLOD),
+    gsDPLoadTextureBlock(burn_smoke_seg4_texture_04021800, G_IM_FMT_IA, G_IM_SIZ_16b, 32, 32, 0,
+                         G_TX_CLAMP, G_TX_CLAMP, 5, 5, G_TX_NOLOD, G_TX_NOLOD),
     gsSPDisplayList(burn_smoke_seg4_dl_04022028),
     gsSPDisplayList(burn_smoke_seg4_dl_04022048),
     gsSPEndDisplayList(),
diff --git a/asm/crash.s b/asm/crash.s
new file mode 100644
index 0000000..870b7e2
--- /dev/null
+++ b/asm/crash.s
@@ -0,0 +1,160 @@
+# SM64 Crash Handler
+# See Readme below.
+
+.include "macros.inc"
+
+.set COP0_CAUSE, 13
+.set COP0_EPC, 14
+.set COP0_BADVADDR, 8
+
+/* ---------------------------------------------------------------
+ * IMPORTANT README:
+ * ---------------------------------------------------------------
+ * To use this crash screen, in lib/__osExceptionPreamble.s, change
+ * the function to use the following assembly:
+ *
+ *     lui   $k0, %hi(__crash_handler_entry)
+ *     addiu $k0, $k0, %lo(__crash_handler_entry)
+ *     jr    $k0
+ *     nop
+ *
+ * Doing just a jal __crash_handler_entry will cause mupen recompiler
+ * errors, so be sure to use the original exception style assembly
+ * above!
+ *
+ * Be sure to add #include "../../enhancements/crash.inc.c" to
+ * the top of game.c. Add .include "../enhancements/crash.inc.s" to
+ * the bottom of asm/decompress.s. Add "../enhancements/crash.h" to
+ * the top of sm64.h, above the CRASH_SCREEN_INCLUDED condition.
+ *
+ * See the DEBUG_ASSERT macro on how to call the crash screen for
+ * detected exceptions.
+ */
+
+glabel crashFont
+    .incbin "enhancements/crash_font.bin"
+    .align 4
+
+glabel exceptionRegContext
+    .fill 0x108
+
+glabel pAssertFile
+    .dword 0
+glabel nAssertLine
+    .dword 0
+glabel pAssertExpression
+    .dword 0
+glabel nAssertStopProgram
+    .dword 0
+
+glabel _n64_assert
+    lui  $at, %hi(pAssertFile)
+    sw   $a0, %lo(pAssertFile)($at)
+    lui  $at, %hi(nAssertLine)
+    sw   $a1, %lo(nAssertLine)($at)
+    lui  $at, %hi(pAssertExpression)
+    sw   $a2, %lo(pAssertExpression)($at)
+    lui  $at, %hi(nAssertStopProgram)
+    sw   $a3, %lo(nAssertStopProgram)($at)
+    beqz $a3, .end_2
+    nop
+    syscall # trigger crash screen
+.end_2:
+    jr $ra
+    nop
+
+glabel cop0_get_cause
+    jr   $ra
+    mfc0 $v0, $13 # COP0_CAUSE
+
+glabel cop0_get_epc
+    jr   $ra
+    mfc0 $v0, $14 # COP0_EPC
+
+glabel cop0_get_badvaddr
+    jr   $ra
+    mfc0 $v0, $8 # COP0_BADVADDR
+
+# If the error code field of cop0's cause register is non-zero,
+# draw crash details to the screen and hang
+#
+# If there wasn't an error, continue to the original handler
+
+glabel __crash_handler_entry
+    la    $k0, exceptionRegContext
+    sd    $zero, 0x018 ($k0)
+    sd    $at, 0x020 ($k0)
+    sd    $v0, 0x028 ($k0)
+    sd    $v1, 0x030 ($k0)
+    sd    $a0, 0x038 ($k0)
+    sd    $a1, 0x040 ($k0)
+    sd    $a2, 0x048 ($k0)
+    sd    $a3, 0x050 ($k0)
+    sd    $t0, 0x058 ($k0)
+    sd    $t1, 0x060 ($k0)
+    sd    $t2, 0x068 ($k0)
+    sd    $t3, 0x070 ($k0)
+    sd    $t4, 0x078 ($k0)
+    sd    $t5, 0x080 ($k0)
+    sd    $t6, 0x088 ($k0)
+    sd    $t7, 0x090 ($k0)
+    sd    $s0, 0x098 ($k0)
+    sd    $s1, 0x0A0 ($k0)
+    sd    $s2, 0x0A8 ($k0)
+    sd    $s3, 0x0B0 ($k0)
+    sd    $s4, 0x0B8 ($k0)
+    sd    $s5, 0x0C0 ($k0)
+    sd    $s6, 0x0C8 ($k0)
+    sd    $s7, 0x0D0 ($k0)
+    sd    $t8, 0x0D8 ($k0)
+    sd    $t9, 0x0E0 ($k0)
+    sd    $gp, 0x0E8 ($k0)
+    sd    $sp, 0x0F0 ($k0)
+    sd    $s8, 0x0F8 ($k0)
+    sd    $ra, 0x100 ($k0)
+    mfc0  $t0, $13 # COP0_CAUSE
+    srl   $t0, $t0, 2
+    andi  $t0, $t0, 0x1F
+    beqz  $t0, .end
+    nop
+    # cop unusable exception fired twice on startup so we'll ignore it for now
+    li    $at, 0x0B
+    beq   $t0, $at, .end
+    nop
+    jal   show_crash_screen_and_hang
+    nop
+    .end:
+    ld    $zero, 0x018 ($k0)
+    ld    $at, 0x020 ($k0)
+    ld    $v0, 0x028 ($k0)
+    ld    $v1, 0x030 ($k0)
+    ld    $a0, 0x038 ($k0)
+    ld    $a1, 0x040 ($k0)
+    ld    $a2, 0x048 ($k0)
+    ld    $a3, 0x050 ($k0)
+    ld    $t0, 0x058 ($k0)
+    ld    $t1, 0x060 ($k0)
+    ld    $t2, 0x068 ($k0)
+    ld    $t3, 0x070 ($k0)
+    ld    $t4, 0x078 ($k0)
+    ld    $t5, 0x080 ($k0)
+    ld    $t6, 0x088 ($k0)
+    ld    $t7, 0x090 ($k0)
+    ld    $s0, 0x098 ($k0)
+    ld    $s1, 0x0A0 ($k0)
+    ld    $s2, 0x0A8 ($k0)
+    ld    $s3, 0x0B0 ($k0)
+    ld    $s4, 0x0B8 ($k0)
+    ld    $s5, 0x0C0 ($k0)
+    ld    $s6, 0x0C8 ($k0)
+    ld    $s7, 0x0D0 ($k0)
+    ld    $t8, 0x0D8 ($k0)
+    ld    $t9, 0x0E0 ($k0)
+    ld    $gp, 0x0E8 ($k0)
+    ld    $sp, 0x0F0 ($k0)
+    ld    $s8, 0x0F8 ($k0)
+    ld    $ra, 0x100 ($k0)
+    lui   $k0, %hi(__osException)
+    addiu $k0, $k0, %lo(__osException)
+    jr    $k0 # run the original handler
+    nop
diff --git a/funny b/funny
new file mode 100644
index 0000000..baad0c6
--- /dev/null
+++ b/funny
@@ -0,0 +1,3517 @@
+diff --git a/actors/burn_smoke/model.inc.c b/actors/burn_smoke/model.inc.c
+index a0f6557..18da5d2 100644
+--- a/actors/burn_smoke/model.inc.c
++++ b/actors/burn_smoke/model.inc.c
+@@ -2,10 +2,10 @@
+ 
+ // 0x040217C0
+ static const Vtx burn_smoke_seg4_vertex_040217C0[] = {
+-    {{{   -50,    -50,      0}, 0, {     0,    992}, {0x14, 0x0a, 0x0a, 0xff}}},
+-    {{{    50,    -50,      0}, 0, {   992,    992}, {0x14, 0x0a, 0x0a, 0xff}}},
+-    {{{    50,     50,      0}, 0, {   992,      0}, {0x14, 0x0a, 0x0a, 0xff}}},
+-    {{{   -50,     50,      0}, 0, {     0,      0}, {0x14, 0x0a, 0x0a, 0xff}}},
++    { { { -50, -50, 0 }, 0, { 0, 992 }, { 0x14, 0x0a, 0x0a, 0xff } } },
++    { { { 50, -50, 0 }, 0, { 992, 992 }, { 0x14, 0x0a, 0x0a, 0xff } } },
++    { { { 50, 50, 0 }, 0, { 992, 0 }, { 0x14, 0x0a, 0x0a, 0xff } } },
++    { { { -50, 50, 0 }, 0, { 0, 0 }, { 0x14, 0x0a, 0x0a, 0xff } } },
+ };
+ 
+ // //! Wrong texture format. Called as rgba16, which makes the burn smoke appear
+@@ -28,7 +28,7 @@ const Gfx burn_smoke_seg4_dl_04022000[] = {
+ // 0x04022028 - 0x04022048
+ const Gfx burn_smoke_seg4_dl_04022028[] = {
+     gsSPVertex(burn_smoke_seg4_vertex_040217C0, 4, 0),
+-    gsSP2Triangles( 0,  1,  2, 0x0,  0,  2,  3, 0x0),
++    gsSP2Triangles(0, 1, 2, 0x0, 0, 2, 3, 0x0),
+     gsSPEndDisplayList(),
+ };
+ 
+@@ -44,7 +44,8 @@ const Gfx burn_smoke_seg4_dl_04022048[] = {
+ // 0x04022070 - 0x040220C8
+ const Gfx burn_smoke_seg4_dl_04022070[] = {
+     gsSPDisplayList(burn_smoke_seg4_dl_04022000),
+-    gsDPLoadTextureBlock(burn_smoke_seg4_texture_04021800, G_IM_FMT_RGBA, G_IM_SIZ_16b, 32, 32, 0, G_TX_CLAMP, G_TX_CLAMP, 5, 5, G_TX_NOLOD, G_TX_NOLOD),
++    gsDPLoadTextureBlock(burn_smoke_seg4_texture_04021800, G_IM_FMT_IA, G_IM_SIZ_16b, 32, 32, 0,
++                         G_TX_CLAMP, G_TX_CLAMP, 5, 5, G_TX_NOLOD, G_TX_NOLOD),
+     gsSPDisplayList(burn_smoke_seg4_dl_04022028),
+     gsSPDisplayList(burn_smoke_seg4_dl_04022048),
+     gsSPEndDisplayList(),
+diff --git a/asm/crash.s b/asm/crash.s
+new file mode 100644
+index 0000000..870b7e2
+--- /dev/null
++++ b/asm/crash.s
+@@ -0,0 +1,160 @@
++# SM64 Crash Handler
++# See Readme below.
++
++.include "macros.inc"
++
++.set COP0_CAUSE, 13
++.set COP0_EPC, 14
++.set COP0_BADVADDR, 8
++
++/* ---------------------------------------------------------------
++ * IMPORTANT README:
++ * ---------------------------------------------------------------
++ * To use this crash screen, in lib/__osExceptionPreamble.s, change
++ * the function to use the following assembly:
++ *
++ *     lui   $k0, %hi(__crash_handler_entry)
++ *     addiu $k0, $k0, %lo(__crash_handler_entry)
++ *     jr    $k0
++ *     nop
++ *
++ * Doing just a jal __crash_handler_entry will cause mupen recompiler
++ * errors, so be sure to use the original exception style assembly
++ * above!
++ *
++ * Be sure to add #include "../../enhancements/crash.inc.c" to
++ * the top of game.c. Add .include "../enhancements/crash.inc.s" to
++ * the bottom of asm/decompress.s. Add "../enhancements/crash.h" to
++ * the top of sm64.h, above the CRASH_SCREEN_INCLUDED condition.
++ *
++ * See the DEBUG_ASSERT macro on how to call the crash screen for
++ * detected exceptions.
++ */
++
++glabel crashFont
++    .incbin "enhancements/crash_font.bin"
++    .align 4
++
++glabel exceptionRegContext
++    .fill 0x108
++
++glabel pAssertFile
++    .dword 0
++glabel nAssertLine
++    .dword 0
++glabel pAssertExpression
++    .dword 0
++glabel nAssertStopProgram
++    .dword 0
++
++glabel _n64_assert
++    lui  $at, %hi(pAssertFile)
++    sw   $a0, %lo(pAssertFile)($at)
++    lui  $at, %hi(nAssertLine)
++    sw   $a1, %lo(nAssertLine)($at)
++    lui  $at, %hi(pAssertExpression)
++    sw   $a2, %lo(pAssertExpression)($at)
++    lui  $at, %hi(nAssertStopProgram)
++    sw   $a3, %lo(nAssertStopProgram)($at)
++    beqz $a3, .end_2
++    nop
++    syscall # trigger crash screen
++.end_2:
++    jr $ra
++    nop
++
++glabel cop0_get_cause
++    jr   $ra
++    mfc0 $v0, $13 # COP0_CAUSE
++
++glabel cop0_get_epc
++    jr   $ra
++    mfc0 $v0, $14 # COP0_EPC
++
++glabel cop0_get_badvaddr
++    jr   $ra
++    mfc0 $v0, $8 # COP0_BADVADDR
++
++# If the error code field of cop0's cause register is non-zero,
++# draw crash details to the screen and hang
++#
++# If there wasn't an error, continue to the original handler
++
++glabel __crash_handler_entry
++    la    $k0, exceptionRegContext
++    sd    $zero, 0x018 ($k0)
++    sd    $at, 0x020 ($k0)
++    sd    $v0, 0x028 ($k0)
++    sd    $v1, 0x030 ($k0)
++    sd    $a0, 0x038 ($k0)
++    sd    $a1, 0x040 ($k0)
++    sd    $a2, 0x048 ($k0)
++    sd    $a3, 0x050 ($k0)
++    sd    $t0, 0x058 ($k0)
++    sd    $t1, 0x060 ($k0)
++    sd    $t2, 0x068 ($k0)
++    sd    $t3, 0x070 ($k0)
++    sd    $t4, 0x078 ($k0)
++    sd    $t5, 0x080 ($k0)
++    sd    $t6, 0x088 ($k0)
++    sd    $t7, 0x090 ($k0)
++    sd    $s0, 0x098 ($k0)
++    sd    $s1, 0x0A0 ($k0)
++    sd    $s2, 0x0A8 ($k0)
++    sd    $s3, 0x0B0 ($k0)
++    sd    $s4, 0x0B8 ($k0)
++    sd    $s5, 0x0C0 ($k0)
++    sd    $s6, 0x0C8 ($k0)
++    sd    $s7, 0x0D0 ($k0)
++    sd    $t8, 0x0D8 ($k0)
++    sd    $t9, 0x0E0 ($k0)
++    sd    $gp, 0x0E8 ($k0)
++    sd    $sp, 0x0F0 ($k0)
++    sd    $s8, 0x0F8 ($k0)
++    sd    $ra, 0x100 ($k0)
++    mfc0  $t0, $13 # COP0_CAUSE
++    srl   $t0, $t0, 2
++    andi  $t0, $t0, 0x1F
++    beqz  $t0, .end
++    nop
++    # cop unusable exception fired twice on startup so we'll ignore it for now
++    li    $at, 0x0B
++    beq   $t0, $at, .end
++    nop
++    jal   show_crash_screen_and_hang
++    nop
++    .end:
++    ld    $zero, 0x018 ($k0)
++    ld    $at, 0x020 ($k0)
++    ld    $v0, 0x028 ($k0)
++    ld    $v1, 0x030 ($k0)
++    ld    $a0, 0x038 ($k0)
++    ld    $a1, 0x040 ($k0)
++    ld    $a2, 0x048 ($k0)
++    ld    $a3, 0x050 ($k0)
++    ld    $t0, 0x058 ($k0)
++    ld    $t1, 0x060 ($k0)
++    ld    $t2, 0x068 ($k0)
++    ld    $t3, 0x070 ($k0)
++    ld    $t4, 0x078 ($k0)
++    ld    $t5, 0x080 ($k0)
++    ld    $t6, 0x088 ($k0)
++    ld    $t7, 0x090 ($k0)
++    ld    $s0, 0x098 ($k0)
++    ld    $s1, 0x0A0 ($k0)
++    ld    $s2, 0x0A8 ($k0)
++    ld    $s3, 0x0B0 ($k0)
++    ld    $s4, 0x0B8 ($k0)
++    ld    $s5, 0x0C0 ($k0)
++    ld    $s6, 0x0C8 ($k0)
++    ld    $s7, 0x0D0 ($k0)
++    ld    $t8, 0x0D8 ($k0)
++    ld    $t9, 0x0E0 ($k0)
++    ld    $gp, 0x0E8 ($k0)
++    ld    $sp, 0x0F0 ($k0)
++    ld    $s8, 0x0F8 ($k0)
++    ld    $ra, 0x100 ($k0)
++    lui   $k0, %hi(__osException)
++    addiu $k0, $k0, %lo(__osException)
++    jr    $k0 # run the original handler
++    nop
+diff --git a/include/types.h b/include/types.h
+index 483c894..b391e4f 100644
+--- a/include/types.h
++++ b/include/types.h
+@@ -7,6 +7,9 @@
+ #include <ultra64.h>
+ #include "macros.h"
+ 
++//typedef int bool;
++#define true 1
++#define false 0 
+ 
+ // Certain functions are marked as having return values, but do not
+ // actually return a value. This causes undefined behavior, which we'd rather
+diff --git a/lib/asm/__osExceptionPreamble.s b/lib/asm/__osExceptionPreamble.s
+index c98608b..3f9804f 100644
+--- a/lib/asm/__osExceptionPreamble.s
++++ b/lib/asm/__osExceptionPreamble.s
+@@ -15,12 +15,11 @@
+ .endif
+ 
+ glabel __osExceptionPreamble
+-    lui   $k0, %hi(__osException) # $k0, 0x8032
+-    addiu $k0, %lo(__osException) # addiu $k0, $k0, 0x66d0
++    lui   $k0, %hi(__crash_handler_entry) # $k0, 0x8032
++    addiu $k0, %lo(__crash_handler_entry) # addiu $k0, $k0, 0x66d0
+     jr    $k0
+      nop
+ 
+-
+ glabel __osException
+ .ifndef VERSION_EU
+     lui   $k0, %hi(gInterruptedThread) # $k0, 0x8036
+diff --git a/lib/asm/__osExceptionPreamble.s.orig b/lib/asm/__osExceptionPreamble.s.orig
+new file mode 100644
+index 0000000..c98608b
+--- /dev/null
++++ b/lib/asm/__osExceptionPreamble.s.orig
+@@ -0,0 +1,1123 @@
++.set noat      # allow manual use of $at
++.set noreorder # don't insert nops after branches
++.set gp=64
++
++.include "macros.inc"
++
++.ifdef VERSION_SH
++.set VERSION_EU, 1 # HACK, someone fix this file, its poorly diff'd!
++.endif
++
++.section .text, "ax"
++
++.ifdef AVOID_UB
++.set D_80334890, D_80334890_fix
++.endif
++
++glabel __osExceptionPreamble
++    lui   $k0, %hi(__osException) # $k0, 0x8032
++    addiu $k0, %lo(__osException) # addiu $k0, $k0, 0x66d0
++    jr    $k0
++     nop
++
++
++glabel __osException
++.ifndef VERSION_EU
++    lui   $k0, %hi(gInterruptedThread) # $k0, 0x8036
++    addiu $k0, %lo(gInterruptedThread) # addiu $k0, $k0, 0x5f40
++    sd    $at, 0x20($k0)
++    mfc0  $k1, $12
++    sw    $k1, 0x118($k0)
++    li    $at, -4
++    and   $k1, $k1, $at
++    mtc0  $k1, $12
++    sd    $t0, 0x58($k0)
++    sd    $t1, 0x60($k0)
++    sd    $t2, 0x68($k0)
++    sw    $zero, 0x18($k0)
++    mfc0  $t0, $13
++
++    andi  $t1, $t0, 0x7c
++    li    $t2, 0
++    bne   $t1, $t2, .L80326750
++     nop
++    and   $t1, $k1, $t0
++    andi  $t2, $t1, 0x4000
++    beqz  $t2, .L80326734
++     nop
++    li    $t1, 1
++    lui   $at, %hi(D_80334934) # $at, 0x8033
++    b     .L80326794
++     sw    $t1, %lo(D_80334934)($at)
++.L80326734:
++    andi  $t2, $t1, 0x2000
++    beqz  $t2, .L80326750
++     nop
++    li    $t1, 1
++    lui   $at, %hi(D_80334938) # $at, 0x8033
++    b     .L80326794
++     sw    $t1, %lo(D_80334938)($at)
++.L80326750:
++    lui   $at, %hi(D_80334934) # $at, 0x8033
++    sw    $zero, %lo(D_80334934)($at)
++    lui   $at, %hi(D_80334938) # $at, 0x8033
++
++    move  $t0, $k0
++    sw    $zero, %lo(D_80334938)($at)
++    lui   $k0, %hi(D_80334890 + 0x10) # $k0, 0x8033
++    lw    $k0, %lo(D_80334890 + 0x10)($k0)
++    ld    $t1, 0x20($t0)
++    sd    $t1, 0x20($k0)
++    ld    $t1, 0x118($t0)
++    sd    $t1, 0x118($k0)
++    ld    $t1, 0x58($t0)
++    sd    $t1, 0x58($k0)
++    ld    $t1, 0x60($t0)
++    sd    $t1, 0x60($k0)
++    ld    $t1, 0x68($t0)
++    sd    $t1, 0x68($k0)
++.L80326794:
++    mflo  $t0
++    sd    $t0, 0x108($k0)
++    mfhi  $t0
++    sd    $v0, 0x28($k0)
++    sd    $v1, 0x30($k0)
++    sd    $a0, 0x38($k0)
++    sd    $a1, 0x40($k0)
++    sd    $a2, 0x48($k0)
++    sd    $a3, 0x50($k0)
++    sd    $t3, 0x70($k0)
++    sd    $t4, 0x78($k0)
++    sd    $t5, 0x80($k0)
++    sd    $t6, 0x88($k0)
++    sd    $t7, 0x90($k0)
++    sd    $s0, 0x98($k0)
++    sd    $s1, 0xa0($k0)
++    sd    $s2, 0xa8($k0)
++    sd    $s3, 0xb0($k0)
++    sd    $s4, 0xb8($k0)
++    sd    $s5, 0xc0($k0)
++    sd    $s6, 0xc8($k0)
++    sd    $s7, 0xd0($k0)
++    sd    $t8, 0xd8($k0)
++    sd    $t9, 0xe0($k0)
++    sd    $gp, 0xe8($k0)
++    sd    $sp, 0xf0($k0)
++    sd    $fp, 0xf8($k0)
++    sd    $ra, 0x100($k0)
++.ifndef VERSION_EU
++    sd    $t0, 0x110($k0)
++.else
++    beqz $t1, .L802F3A18
++    sd    $t0, 0x110($k0)
++    lui   $t0, %hi(D_8030208C) # $t0, 0x8030
++    addiu $t0, $t0, %lo(D_8030208C) # addiu $t0, $t0, 0x208c
++    lw    $t0, ($t0)
++    li    $at, -1
++    xor   $t0, $t0, $at
++    lui   $at, (0xFFFF00FF >> 16) # lui $at, 0xffff
++    andi  $t0, $t0, 0xff00
++    ori   $at, (0xFFFF00FF & 0xFFFF) # ori $at, $at, 0xff
++    or    $t1, $t1, $t0
++    and   $k1, $k1, $at
++    or    $k1, $k1, $t1
++    sw    $k1, 0x118($k0)
++.L802F3A18:
++    lui   $t1, %hi(MI_INTR_MASK_REG) # $t1, 0xa430
++    lw    $t1, %lo(MI_INTR_MASK_REG)($t1)
++    beqz  $t1, .L802F3A50
++     nop   
++    lui   $t0, %hi(D_8030208C) # $t0, 0x8030
++    addiu $t0, $t0, %lo(D_8030208C) # addiu $t0, $t0, 0x208c
++    lw    $t0, ($t0)
++    lw    $t4, 0x128($k0)
++    li    $at, -1
++    srl   $t0, $t0, 0x10
++    xor   $t0, $t0, $at
++    andi  $t0, $t0, 0x3f
++    and   $t0, $t0, $t4
++    or    $t1, $t1, $t0
++.L802F3A50:
++    sw    $t1, 0x128($k0)
++.endif
++
++
++    mfc0  $t0, $14
++    sw    $t0, 0x11c($k0)
++    lw    $t0, 0x18($k0)
++    beqz  $t0, .L80326868
++     nop
++    cfc1  $t0, $31
++    nop
++    sw    $t0, 0x12c($k0)
++    sdc1  $f0, 0x130($k0)
++    sdc1  $f2, 0x138($k0)
++    sdc1  $f4, 0x140($k0)
++    sdc1  $f6, 0x148($k0)
++    sdc1  $f8, 0x150($k0)
++    sdc1  $f10, 0x158($k0)
++    sdc1  $f12, 0x160($k0)
++    sdc1  $f14, 0x168($k0)
++    sdc1  $f16, 0x170($k0)
++    sdc1  $f18, 0x178($k0)
++    sdc1  $f20, 0x180($k0)
++    sdc1  $f22, 0x188($k0)
++    sdc1  $f24, 0x190($k0)
++    sdc1  $f26, 0x198($k0)
++    sdc1  $f28, 0x1a0($k0)
++    sdc1  $f30, 0x1a8($k0)
++.L80326868:
++    mfc0  $t0, $13
++    sw    $t0, 0x120($k0)
++    lui   $t1, %hi(MI_INTR_MASK_REG) # $t1, 0xa430
++    lw    $t1, %lo(MI_INTR_MASK_REG)($t1)
++    sw    $t1, 0x128($k0)
++    li    $t1, 2
++    sh    $t1, 0x10($k0)
++    lui   $t1, %hi(D_80334934) # $t1, 0x8033
++    lw    $t1, %lo(D_80334934)($t1)
++    beqz  $t1, .L803268B4
++     nop
++    lui   $t2, %hi(D_C0000008) # $t2, 0xc000
++    sw    $zero, %lo(D_C0000008)($t2)
++    lui   $a0, %hi(D_C0000000)
++    addiu $t2, %lo(D_C0000008) # addiu $t2, $t2, 8
++    jal   kdebugserver
++     lw    $a0, %lo(D_C0000000)($a0)
++    b     .L80326E08
++     nop
++.L803268B4:
++    lui   $t1, %hi(D_80334938) # $t1, 0x8033
++    lw    $t1, %lo(D_80334938)($t1)
++    beqz  $t1, .L80326900
++     nop
++    lui   $t2, %hi(D_C000000C) # $t2, 0xc000
++    sw    $zero, %lo(D_C000000C)($t2)
++    lui   $t1, %hi(D_80334A40) # $t1, 0x8033
++    lw    $t1, %lo(D_80334A40)($t1)
++    addiu $t2, %lo(D_C000000C) # addiu $t2, $t2, 0xc
++    beqz  $t1, .L803268E8
++     nop
++    jal   send_mesg
++     li    $a0, 120
++.L803268E8:
++    lui   $t1, %hi(D_80334A44) # $t1, 0x8033
++    lw    $t1, %lo(D_80334A44)($t1)
++    lui   $at, %hi(D_80334A44) # $at, 0x8033
++    addi  $t1, $t1, 1
++    b     .L80326E08
++     sw    $t1, %lo(D_80334A44)($at)
++.L80326900:
++    andi  $t1, $t0, 0x7c
++    li    $t2, 36
++    beq   $t1, $t2, .L80326B84
++     nop
++    li    $t2, 44
++    beq   $t1, $t2, .L80326CCC
++     nop
++    li    $t2, 0
++    bne   $t1, $t2, .L80326BE8
++     nop
++    and   $s0, $k1, $t0
++.L8032692C:
++    andi  $t1, $s0, 0xff00
++    srl   $t2, $t1, 0xc
++    bnez  $t2, .L80326944
++     nop
++    srl   $t2, $t1, 8
++    addi  $t2, $t2, 0x10
++.L80326944:
++    lui   $at, %hi(D_80338610)
++    addu  $at, $at, $t2
++    lbu   $t2, %lo(D_80338610)($at)
++    lui   $at, %hi(jtbl_80338630)
++    addu  $at, $at, $t2
++    lw    $t2, %lo(jtbl_80338630)($at)
++    jr    $t2
++     nop
++glabel L80326964
++    mfc0  $t1, $11
++    mtc0  $t1, $11
++    jal   send_mesg
++     li    $a0, 24
++    lui   $at, (0xFFFF7FFF >> 16) # lui $at, 0xffff
++    ori   $at, (0xFFFF7FFF & 0xFFFF) # ori $at, $at, 0x7fff
++    b     .L8032692C
++     and   $s0, $s0, $at
++glabel L80326984
++    li    $t2, 4
++    lui   $at, %hi(D_80334920)
++    addu  $at, $at, $t2
++    lw    $t2, %lo(D_80334920)($at)
++    beqz  $t2, .L803269A4
++     nop
++    jalr  $t2
++    nop
++.L803269A4:
++    jal   send_mesg
++     li    $a0, 16
++    li    $at, -2049
++    b     .L8032692C
++     and   $s0, $s0, $at
++glabel L803269B8
++    lui   $s1, %hi(MI_INTR_REG) # $s1, 0xa430
++    lw    $s1, %lo(MI_INTR_REG)($s1)
++    andi  $s1, $s1, 0x3f
++    andi  $t1, $s1, 1
++    beqz  $t1, .L80326A18
++     nop
++    lui   $t4, %hi(SP_STATUS_REG) # $t4, 0xa404
++    lw    $t4, %lo(SP_STATUS_REG)($t4)
++    li    $t1, 8
++    lui   $at, %hi(SP_STATUS_REG) # $at, 0xa404
++    andi  $t4, $t4, 0x300
++    andi  $s1, $s1, 0x3e
++    beqz  $t4, .L80326A08
++     sw    $t1, %lo(SP_STATUS_REG)($at)
++    jal   send_mesg
++     li    $a0, 32
++    beqz  $s1, .L80326ADC
++     nop
++    b     .L80326A18
++     nop
++.L80326A08:
++    jal   send_mesg
++     li    $a0, 88
++    beqz  $s1, .L80326ADC
++     nop
++.L80326A18:
++    andi  $t1, $s1, 8
++    beqz  $t1, .L80326A3C
++     lui   $at, %hi(VI_CURRENT_REG) # $at, 0xa440
++    andi  $s1, $s1, 0x37
++    sw    $zero, %lo(VI_CURRENT_REG)($at)
++    jal   send_mesg
++     li    $a0, 56
++    beqz  $s1, .L80326ADC
++     nop
++.L80326A3C:
++    andi  $t1, $s1, 4
++    beqz  $t1, .L80326A68
++     nop
++    li    $t1, 1
++    lui   $at, %hi(AI_STATUS_REG) # $at, 0xa450
++    andi  $s1, $s1, 0x3b
++    sw    $t1, %lo(AI_STATUS_REG)($at)
++    jal   send_mesg
++     li    $a0, 48
++    beqz  $s1, .L80326ADC
++     nop
++.L80326A68:
++    andi  $t1, $s1, 2
++    beqz  $t1, .L80326A8C
++     lui   $at, %hi(SI_STATUS_REG) # $at, 0xa480
++    andi  $s1, $s1, 0x3d
++    sw    $zero, %lo(SI_STATUS_REG)($at)
++    jal   send_mesg
++     li    $a0, 40
++    beqz  $s1, .L80326ADC
++     nop
++.L80326A8C:
++    andi  $t1, $s1, 0x10
++    beqz  $t1, .L80326AB8
++     nop
++    li    $t1, 2
++    lui   $at, %hi(PI_STATUS_REG) # $at, 0xa460
++    andi  $s1, $s1, 0x2f
++    sw    $t1, %lo(PI_STATUS_REG)($at)
++    jal   send_mesg
++     li    $a0, 64
++    beqz  $s1, .L80326ADC
++     nop
++.L80326AB8:
++    andi  $t1, $s1, 0x20
++    beqz  $t1, .L80326ADC
++     nop
++    li    $t1, 2048
++    lui   $at, %hi(MI_MODE_REG)
++    andi  $s1, $s1, 0x1f
++    sw    $t1, %lo(MI_MODE_REG)($at)
++    jal   send_mesg
++     li    $a0, 72
++.L80326ADC:
++    li    $at, -1025
++    b     .L8032692C
++     and   $s0, $s0, $at
++glabel L80326AE8
++    lw    $k1, 0x118($k0)
++    li    $at, -4097
++    lui   $t1, %hi(D_80334808) # $t1, 0x8033
++    and   $k1, $k1, $at
++    sw    $k1, 0x118($k0)
++    addiu $t1, %lo(D_80334808) # addiu $t1, $t1, 0x4808
++    lw    $t2, ($t1)
++    beqz  $t2, .L80326B14
++     li    $at, -4097
++    b     .L80326B9C
++     and   $s0, $s0, $at
++.L80326B14:
++    li    $t2, 1
++    sw    $t2, ($t1)
++    jal   send_mesg
++     li    $a0, 112
++    lui   $t2, %hi(D_80334890 + 0x8) # $t2, 0x8033
++    lw    $t2, %lo(D_80334890 + 0x8)($t2)
++    li    $at, -4097
++    and   $s0, $s0, $at
++    lw    $k1, 0x118($t2)
++    and   $k1, $k1, $at
++    b     .L80326B9C
++     sw    $k1, 0x118($t2)
++glabel L80326B44
++    li    $at, -513
++    and   $t0, $t0, $at
++    mtc0  $t0, $13
++    jal   send_mesg
++     li    $a0, 8
++    li    $at, -513
++    b     .L8032692C
++     and   $s0, $s0, $at
++glabel L80326B64
++    li    $at, -257
++    and   $t0, $t0, $at
++    mtc0  $t0, $13
++    jal   send_mesg
++     li    $a0, 0
++    li    $at, -257
++    b     .L8032692C
++     and   $s0, $s0, $at
++.L80326B84:
++    li    $t1, 1
++    sh    $t1, 0x12($k0)
++    jal   send_mesg
++     li    $a0, 80
++    b     .L80326B9C
++     nop
++.L80326B9C:
++glabel L80326B9C
++    lui   $t2, %hi(D_80334890 + 0x8) # $t2, 0x8033
++    lw    $t2, %lo(D_80334890 + 0x8)($t2)
++    lw    $t1, 4($k0)
++    lw    $t3, 4($t2)
++    slt   $at, $t1, $t3
++    beqz  $at, .L80326BD0
++     nop
++    lui   $a0, %hi(D_80334890 + 0x8) # $a0, 0x8033
++    move  $a1, $k0
++    jal   __osEnqueueThread
++     addiu $a0, %lo(D_80334890 + 0x8) # addiu $a0, $a0, 0x4898
++    j     __osDispatchThread
++     nop
++
++.L80326BD0:
++    lui   $t1, %hi(D_80334890 + 0x8) # $t1, 0x8033
++    addiu $t1, %lo(D_80334890 + 0x8) # addiu $t1, $t1, 0x4898
++    lw    $t2, ($t1)
++    sw    $t2, ($k0)
++    j     __osDispatchThread
++     sw    $k0, ($t1)
++
++.L80326BE8:
++glabel L80326BE8
++    lui   $at, %hi(D_80334890 + 0x14) # $at, 0x8033
++    sw    $k0, %lo(D_80334890 + 0x14)($at)
++    li    $t1, 1
++    sh    $t1, 0x10($k0)
++    li    $t1, 2
++    sh    $t1, 0x12($k0)
++    mfc0  $t2, $8
++    sw    $t2, 0x124($k0)
++    jal   send_mesg
++     li    $a0, 96
++    j     __osDispatchThread
++     nop
++.else
++  lui   $k0, %hi(gInterruptedThread) # $k0, 0x8033
++  addiu $k0, %lo(gInterruptedThread) # addiu $k0, $k0, 0x6ce0
++  sd    $at, 0x20($k0)
++  mfc0  $k1, $12
++  sw    $k1, 0x118($k0)
++  li    $at, -4
++  and   $k1, $k1, $at
++  mtc0  $k1, $12
++  sd    $t0, 0x58($k0)
++  sd    $t1, 0x60($k0)
++  sd    $t2, 0x68($k0)
++  sw    $zero, 0x18($k0)
++  mfc0  $t0, $13
++  move  $t0, $k0
++  lui   $k0, %hi(D_80334890 + 0x10) # $k0, 0x8030
++  lw    $k0, %lo(D_80334890 + 0x10)($k0)
++  ld    $t1, 0x20($t0)
++  sd    $t1, 0x20($k0)
++  ld    $t1, 0x118($t0)
++  sd    $t1, 0x118($k0)
++  ld    $t1, 0x58($t0)
++  sd    $t1, 0x58($k0)
++  ld    $t1, 0x60($t0)
++  sd    $t1, 0x60($k0)
++  ld    $t1, 0x68($t0)
++  sd    $t1, 0x68($k0)
++  lw    $k1, 0x118($k0)
++  mflo  $t0
++  sd    $t0, 0x108($k0)
++  mfhi  $t0
++  andi  $t1, $k1, 0xff00
++  sd    $v0, 0x28($k0)
++  sd    $v1, 0x30($k0)
++  sd    $a0, 0x38($k0)
++  sd    $a1, 0x40($k0)
++  sd    $a2, 0x48($k0)
++  sd    $a3, 0x50($k0)
++  sd    $t3, 0x70($k0)
++  sd    $t4, 0x78($k0)
++  sd    $t5, 0x80($k0)
++  sd    $t6, 0x88($k0)
++  sd    $t7, 0x90($k0)
++  sd    $s0, 0x98($k0)
++  sd    $s1, 0xa0($k0)
++  sd    $s2, 0xa8($k0)
++  sd    $s3, 0xb0($k0)
++  sd    $s4, 0xb8($k0)
++  sd    $s5, 0xc0($k0)
++  sd    $s6, 0xc8($k0)
++  sd    $s7, 0xd0($k0)
++  sd    $t8, 0xd8($k0)
++  sd    $t9, 0xe0($k0)
++  sd    $gp, 0xe8($k0)
++  sd    $sp, 0xf0($k0)
++  sd    $fp, 0xf8($k0)
++  sd    $ra, 0x100($k0)
++  beqz  $t1, .L802F3A18
++   sd    $t0, 0x110($k0)
++  lui   $t0, %hi(D_8030208C) # $t0, 0x8030
++  addiu $t0, %lo(D_8030208C) # addiu $t0, $t0, 0x208c
++  lw    $t0, ($t0)
++  li    $at, -1
++  xor   $t0, $t0, $at
++  lui   $at, (0xFFFF00FF >> 16) # lui $at, 0xffff
++  andi  $t0, $t0, 0xff00
++  ori   $at, (0xFFFF00FF & 0xFFFF) # ori $at, $at, 0xff
++  or    $t1, $t1, $t0
++  and   $k1, $k1, $at
++  or    $k1, $k1, $t1
++  sw    $k1, 0x118($k0)
++.L802F3A18:
++  lui   $t1, %hi(MI_INTR_MASK_REG) # $t1, 0xa430
++  lw    $t1, %lo(MI_INTR_MASK_REG)($t1)
++  beqz  $t1, .L802F3A50
++   nop   
++  lui   $t0, %hi(D_8030208C) # $t0, 0x8030
++  addiu $t0, %lo(D_8030208C) # addiu $t0, $t0, 0x208c
++  lw    $t0, ($t0)
++  lw    $t4, 0x128($k0)
++  li    $at, -1
++  srl   $t0, $t0, 0x10
++  xor   $t0, $t0, $at
++  andi  $t0, $t0, 0x3f
++  and   $t0, $t0, $t4
++  or    $t1, $t1, $t0
++.L802F3A50:
++  sw    $t1, 0x128($k0)
++  mfc0  $t0, $14
++  sw    $t0, 0x11c($k0)
++  lw    $t0, 0x18($k0)
++  beqz  $t0, .L802F3AB4
++   nop   
++  cfc1  $t0, $31
++  nop   
++  sw    $t0, 0x12c($k0)
++  sdc1  $f0, 0x130($k0)
++  sdc1  $f2, 0x138($k0)
++  sdc1  $f4, 0x140($k0)
++  sdc1  $f6, 0x148($k0)
++  sdc1  $f8, 0x150($k0)
++  sdc1  $f10, 0x158($k0)
++  sdc1  $f12, 0x160($k0)
++  sdc1  $f14, 0x168($k0)
++  sdc1  $f16, 0x170($k0)
++  sdc1  $f18, 0x178($k0)
++  sdc1  $f20, 0x180($k0)
++  sdc1  $f22, 0x188($k0)
++  sdc1  $f24, 0x190($k0)
++  sdc1  $f26, 0x198($k0)
++  sdc1  $f28, 0x1a0($k0)
++  sdc1  $f30, 0x1a8($k0)
++.L802F3AB4:
++  mfc0  $t0, $13
++  sw    $t0, 0x120($k0)
++  li    $t1, 2
++  sh    $t1, 0x10($k0)
++  andi  $t1, $t0, 0x7c
++  li    $t2, 36
++  beq   $t1, $t2, .L802F3D90
++   nop   
++  li    $t2, 44
++  beq   $t1, $t2, .L80326CCC
++   nop   
++  li    $t2, 0
++  bne   $t1, $t2, .L80326BE8
++   nop   
++  and   $s0, $k1, $t0
++.L802F3AF0:
++  andi  $t1, $s0, 0xff00
++  srl   $t2, $t1, 0xc
++  bnez  $t2, .L802F3B08
++   nop   
++  srl   $t2, $t1, 8
++  addi  $t2, $t2, 0x10
++.L802F3B08:
++  lui   $at, %hi(D_80338610)
++  addu  $at, $at, $t2
++  lbu   $t2, %lo(D_80338610)($at)
++  lui   $at, %hi(jtbl_80338630)
++  addu  $at, $at, $t2
++  lw    $t2, %lo(jtbl_80338630)($at)
++  jr    $t2
++   nop   
++  li    $at, -8193
++  b     .L802F3AF0
++   and   $s0, $s0, $at
++  li    $at, -16385
++  b     .L802F3AF0
++   and   $s0, $s0, $at
++glabel L80326964 #probably not right...
++  mfc0  $t1, $11
++  mtc0  $t1, $11
++  jal   send_mesg
++   li    $a0, 24
++  lui   $at, (0xFFFF7FFF >> 16) # lui $at, 0xffff
++  ori   $at, (0xFFFF7FFF & 0xFFFF) # ori $at, $at, 0x7fff
++  b     .L802F3AF0
++   and   $s0, $s0, $at
++glabel L80326984 #possibly wrong 
++  li    $at, -2049
++  and   $s0, $s0, $at
++  li    $t2, 4
++  lui   $at, %hi(D_80334920)
++  addu  $at, $at, $t2
++  lw    $t2, %lo(D_80334920)($at)
++  lui   $sp, %hi(D_80365E40) # $sp, 0x8033 #.bss stack for D_802F4380
++  addiu $sp, %lo(D_80365E40) # addiu $sp, $sp, 0x5c20
++  li    $a0, 16
++  beqz  $t2, .L802F3BA4
++   addiu $sp, $sp, 0xff0
++  jalr  $t2
++  nop   
++  beqz  $v0, .L802F3BA4
++   nop   
++  b     .L802F3DA8
++   nop   
++.L802F3BA4:
++  jal   send_mesg
++   nop   
++  b     .L802F3AF0
++   nop   
++glabel L803269B8
++  lui   $t0, %hi(D_8030208C) # $t0, 0x8030
++  addiu $t0, %lo(D_8030208C) # addiu $t0, $t0, 0x208c
++  lw    $t0, ($t0)
++  lui   $s1, %hi(MI_INTR_REG) # $s1, 0xa430
++  lw    $s1, %lo(MI_INTR_REG)($s1)
++  srl   $t0, $t0, 0x10
++  and   $s1, $s1, $t0
++  andi  $t1, $s1, 1
++  beqz  $t1, .L802F3C24
++   nop   
++  lui   $t4, %hi(SP_STATUS_REG) # $t4, 0xa404
++  lw    $t4, %lo(SP_STATUS_REG)($t4)
++  li    $t1, 8
++  lui   $at, %hi(SP_STATUS_REG) # $at, 0xa404
++  andi  $t4, $t4, 0x300
++  andi  $s1, $s1, 0x3e
++  beqz  $t4, .L802F3C14
++   sw    $t1, %lo(SP_STATUS_REG)($at)
++  jal   send_mesg
++   li    $a0, 32
++  beqz  $s1, .L802F3CE8
++   nop   
++  b     .L802F3C24
++   nop   
++.L802F3C14:
++  jal   send_mesg
++   li    $a0, 88
++  beqz  $s1, .L802F3CE8
++   nop   
++.L802F3C24:
++  andi  $t1, $s1, 8
++  beqz  $t1, .L802F3C48
++   lui   $at, %hi(VI_CURRENT_REG) # $at, 0xa440
++  andi  $s1, $s1, 0x37
++  sw    $zero, %lo(VI_CURRENT_REG)($at)
++  jal   send_mesg
++   li    $a0, 56
++  beqz  $s1, .L802F3CE8
++   nop   
++.L802F3C48:
++  andi  $t1, $s1, 4
++  beqz  $t1, .L802F3C74
++   nop   
++  li    $t1, 1
++  lui   $at, %hi(AI_STATUS_REG) # $at, 0xa450
++  andi  $s1, $s1, 0x3b
++  sw    $t1, %lo(AI_STATUS_REG)($at)
++  jal   send_mesg
++   li    $a0, 48
++  beqz  $s1, .L802F3CE8
++   nop   
++.L802F3C74:
++  andi  $t1, $s1, 2
++  beqz  $t1, .L802F3C98
++   lui   $at, %hi(SI_STATUS_REG) # $at, 0xa480
++  andi  $s1, $s1, 0x3d
++  sw    $zero, %lo(SI_STATUS_REG)($at)
++  jal   send_mesg
++   li    $a0, 40
++  beqz  $s1, .L802F3CE8
++   nop   
++.L802F3C98:
++  andi  $t1, $s1, 0x10
++  beqz  $t1, .L802F3CC4
++   nop   
++  li    $t1, 2
++  lui   $at, %hi(PI_STATUS_REG) # $at, 0xa460
++  andi  $s1, $s1, 0x2f
++  sw    $t1, %lo(PI_STATUS_REG)($at)
++  jal   send_mesg
++   li    $a0, 64
++  beqz  $s1, .L802F3CE8
++   nop   
++.L802F3CC4:
++  andi  $t1, $s1, 0x20
++  beqz  $t1, .L802F3CE8
++   nop   
++  li    $t1, 2048
++  lui   $at, 0xa430
++  andi  $s1, $s1, 0x1f
++  sw    $t1, ($at)
++  jal   send_mesg
++   li    $a0, 72
++.L802F3CE8:
++  li    $at, -1025
++  b     .L802F3AF0
++   and   $s0, $s0, $at
++glabel L80326AE8
++  lw    $k1, 0x118($k0)
++  li    $at, -4097
++  lui   $t1, %hi(D_80334808) # $t1, 0x8030
++  and   $k1, $k1, $at
++  sw    $k1, 0x118($k0)
++  addiu $t1, %lo(D_80334808) # addiu $t1, $t1, 0x2088
++  lw    $t2, ($t1)
++  beqz  $t2, .L802F3D20
++   li    $at, -4097
++  b     .L802F3DA8
++   and   $s0, $s0, $at
++.L802F3D20:
++  li    $t2, 1
++  sw    $t2, ($t1)
++  jal   send_mesg
++   li    $a0, 112
++  lui   $t2, %hi(D_80334890 + 0x8) # $t2, 0x8030
++  lw    $t2, %lo(D_80334890 + 0x8)($t2)
++  li    $at, -4097
++  and   $s0, $s0, $at
++  lw    $k1, 0x118($t2)
++  and   $k1, $k1, $at
++  b     .L802F3DA8
++   sw    $k1, 0x118($t2)
++glabel L80326B44
++  li    $at, -513
++  and   $t0, $t0, $at
++  mtc0  $t0, $13
++  jal   send_mesg
++   li    $a0, 8
++  li    $at, -513
++  b     .L802F3AF0
++   and   $s0, $s0, $at
++glabel L80326B64
++  li    $at, -257
++  and   $t0, $t0, $at
++  mtc0  $t0, $13
++  jal   send_mesg
++   li    $a0, 0
++  li    $at, -257
++  b     .L802F3AF0
++   and   $s0, $s0, $at
++.L802F3D90:
++  li    $t1, 1
++  sh    $t1, 0x12($k0)
++  jal   send_mesg
++   li    $a0, 80
++  b     .L802F3DA8
++   nop   
++.L802F3DA8:
++glabel L80326B9C
++  lui   $t2, %hi(D_80334890 + 0x8) # $t2, 0x8030
++  lw    $t2, %lo(D_80334890 + 0x8)($t2)
++  lw    $t1, 4($k0)
++  lw    $t3, 4($t2)
++  slt   $at, $t1, $t3
++  beqz  $at, .L80326BD0
++   nop   
++  lui   $a0, %hi(D_80334890 + 0x8) # $a0, 0x8030
++  move  $a1, $k0
++  jal   __osEnqueueThread
++   addiu $a0, %lo(D_80334890 + 0x8) # addiu $a0, $a0, 0x2ef8
++  j     __osDispatchThread
++   nop   
++
++.L80326BD0:
++  lui   $t1, %hi(D_80334890 + 0x8) # $t1, 0x8030
++  addiu $t1, %lo(D_80334890 + 0x8) # addiu $t1, $t1, 0x2ef8
++  lw    $t2, ($t1)
++  sw    $t2, ($k0)
++  j     __osDispatchThread
++   sw    $k0, ($t1)
++
++.L80326BE8:
++glabel L80326BE8
++  lui   $at, %hi(D_80334890 + 0x14) # $at, 0x8030
++  sw    $k0, %lo(D_80334890 + 0x14)($at)
++  li    $t1, 1
++  sh    $t1, 0x10($k0)
++  li    $t1, 2
++  sh    $t1, 0x12($k0)
++  mfc0  $t2, $8
++  sw    $t2, 0x124($k0)
++  jal   send_mesg
++   li    $a0, 96
++  j     __osDispatchThread
++   nop   
++.endif
++
++glabel send_mesg
++    lui   $t2, %hi(D_80363830) # $t2, 0x8036
++    addiu $t2, %lo(D_80363830) # addiu $t2, $t2, 0x3830
++    addu  $t2, $t2, $a0
++    lw    $t1, ($t2)
++    move  $s2, $ra
++    beqz  $t1, .L80326CC4
++     nop
++    lw    $t3, 8($t1)
++    lw    $t4, 0x10($t1)
++    slt   $at, $t3, $t4
++    beqz  $at, .L80326CC4
++     nop
++    lw    $t5, 0xc($t1)
++    addu  $t5, $t5, $t3
++    div   $zero, $t5, $t4
++    bnez  $t4, .L80326C60
++     nop
++    break 7
++.L80326C60:
++    li    $at, -1
++    bne   $t4, $at, .L80326C78
++     lui   $at, 0x8000
++    bne   $t5, $at, .L80326C78
++     nop
++    break 6
++.L80326C78:
++    lw    $t4, 0x14($t1)
++    mfhi  $t5
++    sll   $t5, $t5, 2
++    addu  $t4, $t4, $t5
++    lw    $t5, 4($t2)
++    addiu $t2, $t3, 1
++    sw    $t5, ($t4)
++    sw    $t2, 8($t1)
++    lw    $t2, ($t1)
++    lw    $t3, ($t2)
++    beqz  $t3, .L80326CC4
++     nop
++    jal   __osPopThread
++     move  $a0, $t1
++    move  $t2, $v0
++    lui   $a0, %hi(D_80334890 + 0x8) # $a0, 0x8033
++    move  $a1, $t2
++    jal   __osEnqueueThread
++     addiu $a0, %lo(D_80334890 + 0x8) # addiu $a0, $a0, 0x4898
++.L80326CC4:
++    jr    $s2
++     nop
++.L80326CCC:
++    lui   $at, 0x3000
++    and   $t1, $t0, $at
++    srl   $t1, $t1, 0x1c
++    li    $t2, 1
++    bne   $t1, $t2, .L80326BE8
++     nop
++    lw    $k1, 0x118($k0)
++    lui   $at, 0x2000
++    li    $t1, 1
++    or    $k1, $k1, $at
++    sw    $t1, 0x18($k0)
++    b     .L80326BD0
++     sw    $k1, 0x118($k0)
++
++
++glabel __osEnqueueAndYield
++    lui   $a1, %hi(D_80334890 + 0x10) # $a1, 0x8033
++    lw    $a1, %lo(D_80334890 + 0x10)($a1)
++    mfc0  $t0, $12
++    lw    $k1, 0x18($a1)
++    ori   $t0, $t0, 2
++    sw    $t0, 0x118($a1)
++    sd    $s0, 0x98($a1)
++    sd    $s1, 0xa0($a1)
++    sd    $s2, 0xa8($a1)
++    sd    $s3, 0xb0($a1)
++    sd    $s4, 0xb8($a1)
++    sd    $s5, 0xc0($a1)
++    sd    $s6, 0xc8($a1)
++    sd    $s7, 0xd0($a1)
++    sd    $gp, 0xe8($a1)
++    sd    $sp, 0xf0($a1)
++    sd    $fp, 0xf8($a1)
++    sd    $ra, 0x100($a1)
++.ifdef VERSION_EU
++    beqz  $k1, .L802F3F7C
++.else
++    beqz  $k1, .L80326D70
++.endif
++     sw    $ra, 0x11c($a1)
++    cfc1  $k1, $31
++    sdc1  $f20, 0x180($a1)
++    sdc1  $f22, 0x188($a1)
++    sdc1  $f24, 0x190($a1)
++    sdc1  $f26, 0x198($a1)
++    sdc1  $f28, 0x1a0($a1)
++    sdc1  $f30, 0x1a8($a1)
++    sw    $k1, 0x12c($a1)
++
++.ifdef VERSION_EU
++.L802F3F7C:
++/* 0B377C 802F3F7C 8CBB0118 */  lw    $k1, 0x118($a1)
++/* 0B3780 802F3F80 3369FF00 */  andi  $t1, $k1, 0xff00
++/* 0B3784 802F3F84 1120000D */  beqz  $t1, .L802F3FBC
++/* 0B3788 802F3F88 00000000 */   nop   
++/* 0B378C 802F3F8C 3C088030 */  lui   $t0, %hi(D_8030208C) # $t0, 0x8030
++/* 0B3790 802F3F90 2508208C */  addiu $t0, %lo(D_8030208C) # addiu $t0, $t0, 0x208c
++/* 0B3794 802F3F94 8D080000 */  lw    $t0, ($t0)
++/* 0B3798 802F3F98 2401FFFF */  li    $at, -1
++/* 0B379C 802F3F9C 01014026 */  xor   $t0, $t0, $at
++/* 0B37A0 802F3FA0 3C01FFFF */  lui   $at, (0xFFFF00FF >> 16) # lui $at, 0xffff
++/* 0B37A4 802F3FA4 3108FF00 */  andi  $t0, $t0, 0xff00
++/* 0B37A8 802F3FA8 342100FF */  ori   $at, (0xFFFF00FF & 0xFFFF) # ori $at, $at, 0xff
++/* 0B37AC 802F3FAC 01284825 */  or    $t1, $t1, $t0
++/* 0B37B0 802F3FB0 0361D824 */  and   $k1, $k1, $at
++/* 0B37B4 802F3FB4 0369D825 */  or    $k1, $k1, $t1
++/* 0B37B8 802F3FB8 ACBB0118 */  sw    $k1, 0x118($a1)
++.L802F3FBC:
++/* 0B37BC 802F3FBC 3C1BA430 */  lui   $k1, %hi(MI_INTR_MASK_REG) # $k1, 0xa430
++/* 0B37C0 802F3FC0 8F7B000C */  lw    $k1, %lo(MI_INTR_MASK_REG)($k1)
++/* 0B37C4 802F3FC4 1360000B */  beqz  $k1, .L802F3FF4
++/* 0B37C8 802F3FC8 00000000 */   nop   
++/* 0B37CC 802F3FCC 3C1A8030 */  lui   $k0, %hi(D_8030208C) # $k0, 0x8030
++/* 0B37D0 802F3FD0 275A208C */  addiu $k0, %lo(D_8030208C) # addiu $k0, $k0, 0x208c
++/* 0B37D4 802F3FD4 8F5A0000 */  lw    $k0, ($k0)
++/* 0B37D8 802F3FD8 8CA80128 */  lw    $t0, 0x128($a1)
++/* 0B37DC 802F3FDC 2401FFFF */  li    $at, -1
++/* 0B37E0 802F3FE0 001AD402 */  srl   $k0, $k0, 0x10
++/* 0B37E4 802F3FE4 0341D026 */  xor   $k0, $k0, $at
++/* 0B37E8 802F3FE8 335A003F */  andi  $k0, $k0, 0x3f
++/* 0B37EC 802F3FEC 0348D024 */  and   $k0, $k0, $t0
++/* 0B37F0 802F3FF0 037AD825 */  or    $k1, $k1, $k0
++.L802F3FF4:
++.endif
++
++
++.L80326D70:
++.ifndef VERSION_EU
++    lui   $k1, %hi(MI_INTR_MASK_REG) # $k1, 0xa430
++    lw    $k1, %lo(MI_INTR_MASK_REG)($k1)
++.endif
++    beqz  $a0, .L80326D88
++     sw    $k1, 0x128($a1)
++    jal   __osEnqueueThread
++     nop
++.L80326D88:
++    j     __osDispatchThread
++     nop
++
++
++#enqueue and pop look like compiled functions?  but there's no easy way to extract them
++glabel __osEnqueueThread
++    lw    $t8, ($a0)
++    lw    $t7, 4($a1)
++    move  $t9, $a0
++    lw    $t6, 4($t8)
++    slt   $at, $t6, $t7
++    bnez  $at, .L80326DC4
++     nop
++.L80326DAC:
++    move  $t9, $t8
++    lw    $t8, ($t8)
++    lw    $t6, 4($t8)
++    slt   $at, $t6, $t7
++    beqz  $at, .L80326DAC
++     nop
++.L80326DC4:
++    lw    $t8, ($t9)
++    sw    $t8, ($a1)
++    sw    $a1, ($t9)
++    jr    $ra
++     sw    $a0, 8($a1)
++
++glabel __osPopThread
++    lw    $v0, ($a0)
++    lw    $t9, ($v0)
++    jr    $ra
++     sw    $t9, ($a0)
++
++glabel __osDispatchThread
++    lui   $a0, %hi(D_80334890 + 0x8) # $a0, 0x8033
++    jal   __osPopThread
++     addiu $a0, %lo(D_80334890 + 0x8) # addiu $a0, $a0, 0x4898
++    lui   $at, %hi(D_80334890 + 0x10) # $at, 0x8033
++    sw    $v0, %lo(D_80334890 + 0x10)($at)
++    li    $t0, 4
++    sh    $t0, 0x10($v0)
++    move  $k0, $v0
++
++.ifdef VERSION_EU
++
++/* 0B3884 802F4084 3C088030 */  lui   $t0, %hi(D_8030208C) # $t0, 0x8030
++/* 0B3888 802F4088 8F5B0118 */  lw    $k1, 0x118($k0)
++/* 0B388C 802F408C 2508208C */  addiu $t0, %lo(D_8030208C) # addiu $t0, $t0, 0x208c
++/* 0B3890 802F4090 8D080000 */  lw    $t0, ($t0)
++/* 0B3894 802F4094 3C01FFFF */  lui   $at, (0xFFFF00FF >> 16) # lui $at, 0xffff
++/* 0B3898 802F4098 3369FF00 */  andi  $t1, $k1, 0xff00
++/* 0B389C 802F409C 342100FF */  ori   $at, (0xFFFF00FF & 0xFFFF) # ori $at, $at, 0xff
++/* 0B38A0 802F40A0 3108FF00 */  andi  $t0, $t0, 0xff00
++/* 0B38A4 802F40A4 01284824 */  and   $t1, $t1, $t0
++/* 0B38A8 802F40A8 0361D824 */  and   $k1, $k1, $at
++/* 0B38AC 802F40AC 0369D825 */  or    $k1, $k1, $t1
++/* 0B38B0 802F40B0 409B6000 */  mtc0  $k1, $12
++.endif
++.L80326E08:
++    ld    $k1, 0x108($k0)
++    ld    $at, 0x20($k0)
++    ld    $v0, 0x28($k0)
++    mtlo  $k1
++    ld    $k1, 0x110($k0)
++    ld    $v1, 0x30($k0)
++    ld    $a0, 0x38($k0)
++    ld    $a1, 0x40($k0)
++    ld    $a2, 0x48($k0)
++    ld    $a3, 0x50($k0)
++    ld    $t0, 0x58($k0)
++    ld    $t1, 0x60($k0)
++    ld    $t2, 0x68($k0)
++    ld    $t3, 0x70($k0)
++    ld    $t4, 0x78($k0)
++    ld    $t5, 0x80($k0)
++    ld    $t6, 0x88($k0)
++    ld    $t7, 0x90($k0)
++    ld    $s0, 0x98($k0)
++    ld    $s1, 0xa0($k0)
++    ld    $s2, 0xa8($k0)
++    ld    $s3, 0xb0($k0)
++    ld    $s4, 0xb8($k0)
++    ld    $s5, 0xc0($k0)
++    ld    $s6, 0xc8($k0)
++    ld    $s7, 0xd0($k0)
++    ld    $t8, 0xd8($k0)
++    ld    $t9, 0xe0($k0)
++    ld    $gp, 0xe8($k0)
++    mthi  $k1
++    ld    $sp, 0xf0($k0)
++    ld    $fp, 0xf8($k0)
++    ld    $ra, 0x100($k0)
++    lw    $k1, 0x11c($k0)
++    mtc0  $k1, $14
++.ifndef VERSION_EU
++    lw    $k1, 0x118($k0)
++    mtc0  $k1, $12
++.endif
++    lw    $k1, 0x18($k0)
++    beqz  $k1, .L80326EF0
++     nop
++    lw    $k1, 0x12c($k0)
++    ctc1  $k1, $31
++    ldc1  $f0, 0x130($k0)
++    ldc1  $f2, 0x138($k0)
++    ldc1  $f4, 0x140($k0)
++    ldc1  $f6, 0x148($k0)
++    ldc1  $f8, 0x150($k0)
++    ldc1  $f10, 0x158($k0)
++    ldc1  $f12, 0x160($k0)
++    ldc1  $f14, 0x168($k0)
++    ldc1  $f16, 0x170($k0)
++    ldc1  $f18, 0x178($k0)
++    ldc1  $f20, 0x180($k0)
++    ldc1  $f22, 0x188($k0)
++    ldc1  $f24, 0x190($k0)
++    ldc1  $f26, 0x198($k0)
++    ldc1  $f28, 0x1a0($k0)
++    ldc1  $f30, 0x1a8($k0)
++.L80326EF0:
++    lw    $k1, 0x128($k0)
++.ifdef VERSION_EU
++/* 0B3998 802F4198 3C1A8030 */  lui   $k0, %hi(D_8030208C) # $k0, 0x8030
++/* 0B399C 802F419C 275A208C */  addiu $k0, %lo(D_8030208C) # addiu $k0, $k0, 0x208c
++/* 0B39A0 802F41A0 8F5A0000 */  lw    $k0, ($k0)
++/* 0B39A4 802F41A4 001AD402 */  srl   $k0, $k0, 0x10
++/* 0B39A8 802F41A8 037AD824 */  and   $k1, $k1, $k0
++.endif
++    sll   $k1, $k1, 1
++    lui   $k0, %hi(D_803386D0) # $k0, 0x8034
++    addiu $k0, %lo(D_803386D0) # addiu $k0, $k0, -0x7930
++    addu  $k1, $k1, $k0
++    lhu   $k1, ($k1)
++    lui   $k0, %hi(MI_INTR_MASK_REG) # $k0, 0xa430
++    addiu $k0, %lo(MI_INTR_MASK_REG) # addiu $k0, $k0, 0xc
++    sw    $k1, ($k0)
++    nop
++    nop
++    nop
++    nop
++    eret
++glabel __osCleanupThread
++    jal   osDestroyThread
++     move  $a0, $zero
++
++.section .data
++
++glabel D_80334920
++    .word 0
++    .word 0
++    .word 0
++    .word 0
++    .word 0
++
++glabel D_80334934
++    .word 0
++
++glabel D_80334938
++    .word 0
++    .word 0
++
++.section .rodata
++
++glabel D_80338610
++    .byte 0x00,0x14,0x18,0x18,0x1C,0x1C,0x1C,0x1C,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x04,0x08,0x08,0x0C,0x0C,0x0C,0x0C,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10
++
++glabel jtbl_80338630
++    .word L80326B9C
++    .word L80326B64
++    .word L80326B44
++    .word L803269B8
++    .word L80326984
++    .word L80326AE8
++.ifdef VERSION_EU
++    .word 0x802f3b28 
++    .word 0x802f3b34
++.else
++    .word L80326BE8
++    .word L80326BE8
++.endif
++    .word L80326964
++    .word 0
++    .word 0
++    .word 0
+diff --git a/sm64.ld b/sm64.ld
+index 8506985..c0feb34 100755
+--- a/sm64.ld
++++ b/sm64.ld
+@@ -114,6 +114,7 @@ SECTIONS
+       BUILD_DIR/src/game/rendering_graph_node.o(.text);
+       BUILD_DIR/src/game/profiler.o(.text);
+       BUILD_DIR/asm/decompress.o(.text);
++      BUILD_DIR/asm/crash.o(.text);
+       BUILD_DIR/src/game/camera.o(.text);
+       BUILD_DIR/src/game/debug_course.o(.text);
+       BUILD_DIR/src/game/object_list_processor.o(.text);
+diff --git a/sm64.ld.orig b/sm64.ld.orig
+new file mode 100644
+index 0000000..8506985
+--- /dev/null
++++ b/sm64.ld.orig
+@@ -0,0 +1,1021 @@
++OUTPUT_ARCH (mips)
++
++/* include/segments.h defines SEG_POOL_START, SEG_POOL_END, SEG_BUFFERS,
++ * SEG_GODDARD, SEG_MAIN, SEG_ENGINE, SEG_FRAMEBUFFERS */
++#include "segments.h"
++
++#define BEGIN_SEG(name, addr) \
++    _##name##SegmentStart = ADDR(.name); \
++    _##name##SegmentRomStart = __romPos; \
++    .name addr : AT(__romPos)
++
++#define END_SEG(name) \
++    _##name##SegmentEnd = ADDR(.name) + SIZEOF(.name); \
++    _##name##SegmentRomEnd = __romPos + SIZEOF(.name); \
++    __romPos += SIZEOF(.name);
++
++#define BEGIN_NOLOAD(name) \
++    _##name##SegmentNoloadStart = ADDR(.name.noload); \
++    .name.noload (NOLOAD) :
++
++#define END_NOLOAD(name) \
++    _##name##SegmentNoloadEnd = ADDR(.name.noload) + SIZEOF(.name.noload);
++
++#define MIO0_SEG(name, segAddr) \
++   BEGIN_SEG(name##_mio0, segAddr) \
++   { \
++      BUILD_DIR/bin/name.mio0.o(.data); \
++      . = ALIGN(0x10); \
++   } \
++   END_SEG(name##_mio0)
++
++#define MIO0_EU_SEG(name, segAddr) \
++   BEGIN_SEG(name##_mio0, segAddr) \
++   { \
++      BUILD_DIR/bin/eu/name.mio0.o(.data); \
++      . = ALIGN(0x10); \
++   } \
++   END_SEG(name##_mio0)
++
++#define STANDARD_LEVEL(name) \
++   BEGIN_SEG(name##_segment_7, 0x07000000) \
++   { \
++      BUILD_DIR/levels/name/leveldata.mio0.o(.data); \
++      . = ALIGN(0x10); \
++   } \
++   END_SEG(name##_segment_7) \
++   BEGIN_SEG(name, 0x0E000000) \
++   { \
++      BUILD_DIR/levels/name/script.o(.data); \
++      BUILD_DIR/levels/name/geo.o(.data); \
++   } \
++   END_SEG(name)
++
++#define STANDARD_OBJECTS(name, segAddr, geoAddr) \
++   BEGIN_SEG(name##_mio0, segAddr) \
++   { \
++      BUILD_DIR/actors/name.mio0.o(.data); \
++      . = ALIGN(0x10); \
++   } \
++   END_SEG(name##_mio0) \
++   BEGIN_SEG(name##_geo, geoAddr) \
++   { \
++      BUILD_DIR/actors/name##_geo.o(.data); \
++   } \
++   END_SEG(name##_geo)
++
++SECTIONS
++{
++   __romPos = 0;
++
++   BEGIN_SEG(boot, 0x04000000)
++   {
++      BUILD_DIR/asm/rom_header.o(.text);
++      BUILD_DIR/asm/boot.o(.text);
++   }
++   END_SEG(boot)
++
++   . = 0x80000400;
++   BEGIN_NOLOAD(zbuffer) {
++      BUILD_DIR/src/buffers/zbuffer.o(.bss*);
++   }
++
++   /* lib/src/__osDevMgrMain.c and lib/src/osCreateViManager.c contain infinite
++    * loops compiled without -g, which cause the return statements and the .o
++    * files themselves to be aligned to 32-byte boundaries. But in the binary,
++    * they are actually aligned only to 16 bytes! We force this to happen using
++    * a SUBALIGN directive. */
++   BEGIN_SEG(main, SEG_MAIN) SUBALIGN(16)
++   {
++      BUILD_DIR/asm/entry.o(.text);
++      BUILD_DIR/src/game/crash_screen.o(.text);
++      BUILD_DIR/src/game/main.o(.text);
++      BUILD_DIR/src/game/game_init.o(.text);
++      BUILD_DIR/src/game/sound_init.o(.text);
++#ifdef VERSION_SH
++      BUILD_DIR/src/game/thread6.o(.text);
++#endif
++      BUILD_DIR/src/game/level_update.o(.text);
++      BUILD_DIR/src/game/interaction.o(.text);
++      BUILD_DIR/src/game/mario.o(.text);
++      BUILD_DIR/src/game/mario_step.o(.text);
++      BUILD_DIR/src/game/mario_actions_cutscene.o(.text);
++      BUILD_DIR/src/game/mario_actions_automatic.o(.text);
++      BUILD_DIR/src/game/mario_actions_stationary.o(.text);
++      BUILD_DIR/src/game/mario_actions_moving.o(.text);
++      BUILD_DIR/src/game/mario_actions_airborne.o(.text);
++      BUILD_DIR/src/game/mario_actions_submerged.o(.text);
++      BUILD_DIR/src/game/mario_actions_object.o(.text);
++      BUILD_DIR/src/game/level_geo.o(.text);
++      BUILD_DIR/src/game/mario_misc.o(.text);
++      BUILD_DIR/src/game/memory.o(.text);
++      BUILD_DIR/src/game/save_file.o(.text);
++      BUILD_DIR/src/game/area.o(.text);
++      BUILD_DIR/src/game/rendering_graph_node.o(.text);
++      BUILD_DIR/src/game/profiler.o(.text);
++      BUILD_DIR/asm/decompress.o(.text);
++      BUILD_DIR/src/game/camera.o(.text);
++      BUILD_DIR/src/game/debug_course.o(.text);
++      BUILD_DIR/src/game/object_list_processor.o(.text);
++#ifndef VERSION_EU
++      BUILD_DIR/src/game/object_helpers.o(.text);
++#endif
++      BUILD_DIR/src/game/behavior_actions.o(.text);
++      BUILD_DIR/src/game/platform_displacement.o(.text);
++#ifndef VERSION_EU
++      BUILD_DIR/src/game/object_collision.o(.text);
++      BUILD_DIR/src/game/spawn_object.o(.text);
++#endif
++      BUILD_DIR/src/game/spawn_sound.o(.text);
++      BUILD_DIR/src/game/debug.o(.text);
++      BUILD_DIR/src/game/screen_transition.o(.text);
++      BUILD_DIR/src/game/shadow.o(.text);
++      BUILD_DIR/src/game/skybox.o(.text);
++      BUILD_DIR/src/game/moving_texture.o(.text);
++      BUILD_DIR/src/game/geo_misc.o(.text);
++      BUILD_DIR/src/game/paintings.o(.text);
++      BUILD_DIR/src/game/print.o(.text);
++      BUILD_DIR/src/game/ingame_menu.o(.text);
++      BUILD_DIR/src/game/envfx_snow.o(.text);
++      BUILD_DIR/src/game/envfx_bubbles.o(.text);
++      BUILD_DIR/src/game/macro_special_objects.o(.text);
++      BUILD_DIR/src/game/hud.o(.text);
++      BUILD_DIR/src/game/obj_behaviors.o(.text);
++      BUILD_DIR/src/game/obj_behaviors_2.o(.text);
++      BUILD_DIR/src/audio/synthesis.o(.text);
++      BUILD_DIR/src/audio/heap.o(.text);
++      BUILD_DIR/src/audio/load.o(.text);
++      BUILD_DIR/src/audio/playback.o(.text);
++      BUILD_DIR/src/audio/effects.o(.text);
++      BUILD_DIR/src/audio/seqplayer.o(.text);
++      BUILD_DIR/src/audio/external.o(.text);
++      BUILD_DIR/src/audio/port_eu.o(.text);
++#if defined(VERSION_EU) || defined(VERSION_SH)
++      BUILD_DIR/libultra.a:string.o(.text);
++      BUILD_DIR/libultra.a:_Printf.o(.text);
++      BUILD_DIR/libultra.a:llmuldiv.o(.text);
++      BUILD_DIR/libultra.a:osInitialize.o(.text);
++      BUILD_DIR/libultra.a:osSetTime.o(.text);
++      BUILD_DIR/libultra.a:osGetTime.o(.text);
++      BUILD_DIR/libultra.a:osWritebackDCacheAll.o(.text);
++      BUILD_DIR/libultra.a:osViBlack.o(.text);
++      BUILD_DIR/libultra.a:osViSwapBuffer.o(.text);
++      BUILD_DIR/libultra.a:__osGetCurrFaultedThread.o(.text);
++      BUILD_DIR/libultra.a:osSetEventMesg.o(.text);
++      BUILD_DIR/libultra.a:osRecvMesg.o(.text);
++      BUILD_DIR/libultra.a:parameters.o(.text);
++      BUILD_DIR/libultra.a:osCreateMesgQueue.o(.text);
++      BUILD_DIR/libultra.a:osCreateThread.o(.text);
++      BUILD_DIR/libultra.a:osStartThread.o(.text);
++      BUILD_DIR/libultra.a:osMapTLB.o(.text);
++      BUILD_DIR/libultra.a:osUnmapTLBAll.o(.text);
++      BUILD_DIR/libultra.a:sprintf.o(.text);
++      BUILD_DIR/libultra.a:osViSetEvent.o(.text);
++      BUILD_DIR/libultra.a:osSpTaskLoadGo.o(.text);
++      BUILD_DIR/libultra.a:osSpTaskYield.o(.text);
++      BUILD_DIR/libultra.a:osSendMesg.o(.text);
++      BUILD_DIR/libultra.a:osSpTaskYielded.o(.text);
++      BUILD_DIR/libultra.a:osCreateViManager.o(.text);
++      BUILD_DIR/libultra.a:osViSetMode.o(.text);
++      BUILD_DIR/libultra.a:osViSetSpecialFeatures.o(.text);
++      BUILD_DIR/libultra.a:osCreatePiManager.o(.text);
++      BUILD_DIR/libultra.a:osSetThreadPri.o(.text);
++      BUILD_DIR/libultra.a:osViSwapBuffer.o(.text);
++      BUILD_DIR/libultra.a:sqrtf.o(.text);
++      BUILD_DIR/libultra.a:osContStartReadData.o(.text);
++      BUILD_DIR/libultra.a:osContInit.o(.text);
++      BUILD_DIR/libultra.a:osEepromProbe.o(.text);
++      BUILD_DIR/libultra.a:osInvalDCache.o(.text);
++      BUILD_DIR/libultra.a:osPiStartDma.o(.text);
++      BUILD_DIR/libultra.a:bzero.o(.text)
++      BUILD_DIR/libultra.a:osInvalICache.o(.text)
++      BUILD_DIR/libultra.a:osEepromLongRead.o(.text)
++      BUILD_DIR/libultra.a:osEepromLongWrite.o(.text)
++      BUILD_DIR/libultra.a:bcopy.o(.text)
++      BUILD_DIR/libultra.a:guOrthoF.o(.text)
++      BUILD_DIR/libultra.a:guPerspectiveF.o(.text)
++      BUILD_DIR/libultra.a:llconv.o(.text)
++      BUILD_DIR/libultra.a:cosf.o(.text)
++      BUILD_DIR/libultra.a:sinf.o(.text)
++      BUILD_DIR/libultra.a:guTranslateF.o(.text)
++      BUILD_DIR/libultra.a:guRotateF.o(.text)
++      BUILD_DIR/libultra.a:guScaleF.o(.text)
++      BUILD_DIR/libultra.a:osAiSetFrequency.o(.text)
++      BUILD_DIR/libultra.a:alBnkfNew.o(.text)
++      BUILD_DIR/libultra.a:osAiGetLength.o(.text)
++      BUILD_DIR/libultra.a:osAiSetNextBuffer.o(.text)
++      BUILD_DIR/libultra.a:_Litob.o(.text)
++      BUILD_DIR/libultra.a:_Ldtob.o(.text)
++      BUILD_DIR/libultra.a:__osSetSR.o(.text)
++      BUILD_DIR/libultra.a:__osGetSR.o(.text)
++      BUILD_DIR/libultra.a:__osSetFpcCsr.o(.text)
++      BUILD_DIR/libultra.a:__osSiRawReadIo.o(.text)
++      BUILD_DIR/libultra.a:__osSiRawWriteIo.o(.text)
++      BUILD_DIR/libultra.a:__osExceptionPreamble.o(.text)
++      BUILD_DIR/libultra.a:osWritebackDCache.o(.text)
++      BUILD_DIR/libultra.a:osMapTLBRdb.o(.text)
++      BUILD_DIR/libultra.a:osPiRawReadIo.o(.text)
++      BUILD_DIR/libultra.a:EU_D_802f4330.o(.text)
++      BUILD_DIR/libultra.a:D_802F4380.o(.text)
++      BUILD_DIR/libultra.a:func_802F4A20.o(.text)
++      BUILD_DIR/libultra.a:osTimer.o(.text)
++      BUILD_DIR/libultra.a:__osDisableInt.o(.text)
++      BUILD_DIR/libultra.a:__osRestoreInt.o(.text)
++      BUILD_DIR/libultra.a:osGetCount.o(.text)
++      BUILD_DIR/libultra.a:__osViInit.o(.text)
++      BUILD_DIR/libultra.a:__osDequeueThread.o(.text)
++      BUILD_DIR/libultra.a:osVirtualToPhysical.o(.text)
++      BUILD_DIR/libultra.a:__osSpSetStatus.o(.text)
++      BUILD_DIR/libultra.a:__osSpSetPc.o(.text)
++      BUILD_DIR/libultra.a:__osSpRawStartDma.o(.text)
++      BUILD_DIR/libultra.a:__osSpDeviceBusy.o(.text)
++      BUILD_DIR/libultra.a:__osSpGetStatus.o(.text)
++      BUILD_DIR/libultra.a:osGetThreadPri.o(.text)
++      BUILD_DIR/libultra.a:__osViGetCurrentContext.o(.text);
++      BUILD_DIR/libultra.a:__osViSwapContext.o(.text)
++      BUILD_DIR/libultra.a:__osPiCreateAccessQueue.o(.text)
++      BUILD_DIR/libultra.a:osPiRawStartDma.o(.text)
++      BUILD_DIR/libultra.a:osEPiRawStartDma.o(.text)
++      BUILD_DIR/libultra.a:__osDevMgrMain.o(.text)
++      BUILD_DIR/libultra.a:__osSiCreateAccessQueue.o(.text)
++      BUILD_DIR/libultra.a:__osSiRawStartDma.o(.text)
++      BUILD_DIR/libultra.a:osSetTimer.o(.text)
++      BUILD_DIR/libultra.a:osEepromWrite.o(.text)
++      BUILD_DIR/libultra.a:osJamMesg.o(.text)
++      BUILD_DIR/libultra.a:osPiGetCmdQueue.o(.text)
++      BUILD_DIR/libultra.a:osEepromRead.o(.text)
++      BUILD_DIR/libultra.a:guMtxF2L.o(.text)
++      BUILD_DIR/libultra.a:guNormalize.o(.text)
++      BUILD_DIR/libultra.a:__osAiDeviceBusy.o(.text);
++      BUILD_DIR/libultra.a:ldiv.o(.text)
++      BUILD_DIR/libultra.a:__osSiDeviceBusy.o(.text);
++      BUILD_DIR/libultra.a:osSetIntMask.o(.text)
++      BUILD_DIR/libultra.a:osDestroyThread.o(.text)
++      BUILD_DIR/libultra.a:osLeoDiskInit.o(.text)
++      BUILD_DIR/libultra.a:__osSetCompare.o(.text)
++      BUILD_DIR/libultra.a:__osProbeTLB.o(.text)
++      BUILD_DIR/libultra.a:__osDequeueThread.o(.text)
++      BUILD_DIR/libultra.a:func_802F7140.o(.text)
++      BUILD_DIR/libultra.a:func_802F71A0.o(.text)
++      BUILD_DIR/libultra.a:func_802F71F0.o(.text)
++
++      BUILD_DIR/lib/rsp.o(.text);
++
++#else
++      BUILD_DIR/src/game*.o(.text);
++      BUILD_DIR/src/audio*.o(.text);
++      BUILD_DIR/libultra.a:parameters.o(.text);
++      BUILD_DIR/libultra.a:osSetTime.o(.text);
++      BUILD_DIR/libultra.a:osMapTLB.o(.text);
++      BUILD_DIR/libultra.a:osUnmapTLBAll.o(.text);
++      BUILD_DIR/libultra.a:sprintf.o(.text);
++      BUILD_DIR/libultra.a:osCreateMesgQueue.o(.text);
++      BUILD_DIR/libultra.a:osSetEventMesg.o(.text);
++      BUILD_DIR/libultra.a:osViSetEvent.o(.text);
++      BUILD_DIR/libultra.a:osCreateThread.o(.text);
++      BUILD_DIR/libultra.a:osRecvMesg.o(.text);
++      BUILD_DIR/libultra.a:osSpTaskLoadGo.o(.text);
++      BUILD_DIR/libultra.a:osSpTaskYield.o(.text);
++      BUILD_DIR/libultra.a:osSendMesg.o(.text);
++      BUILD_DIR/libultra.a:osSpTaskYielded.o(.text);
++      BUILD_DIR/libultra.a:osStartThread.o(.text);
++      BUILD_DIR/libultra.a:osWritebackDCacheAll.o(.text);
++      BUILD_DIR/libultra.a:osCreateViManager.o(.text);
++      BUILD_DIR/libultra.a:osViSetMode.o(.text);
++      BUILD_DIR/libultra.a:osViBlack.o(.text);
++      BUILD_DIR/libultra.a:osViSetSpecialFeatures.o(.text);
++      BUILD_DIR/libultra.a:osCreatePiManager.o(.text);
++      BUILD_DIR/libultra.a:osSetThreadPri.o(.text);
++      BUILD_DIR/libultra.a:osInitialize.o(.text);
++      BUILD_DIR/libultra.a:osViSwapBuffer.o(.text);
++      BUILD_DIR/libultra.a:sqrtf.o(.text);
++      BUILD_DIR/libultra.a:osContStartReadData.o(.text);
++      BUILD_DIR/libultra.a:osContInit.o(.text);
++      BUILD_DIR/libultra.a:osEepromProbe.o(.text);
++      BUILD_DIR/libultra.a:llmuldiv.o(.text);
++      BUILD_DIR/libultra.a:llmuldiv_gcc.o(.text);
++      BUILD_DIR/libultra.a:osInvalDCache.o(.text);
++      BUILD_DIR/libultra.a:osPiStartDma.o(.text);
++      BUILD_DIR/libultra.a:bzero.o(.text);
++      BUILD_DIR/libultra.a:osInvalICache.o(.text);
++      BUILD_DIR/libultra.a:osEepromLongRead.o(.text);
++      BUILD_DIR/libultra.a:osEepromLongWrite.o(.text);
++      BUILD_DIR/libultra.a:bcopy.o(.text);
++      BUILD_DIR/libultra.a:guOrthoF.o(.text);
++      BUILD_DIR/libultra.a:guPerspectiveF.o(.text);
++      BUILD_DIR/libultra.a:osGetTime.o(.text);
++      BUILD_DIR/libultra.a:llconv.o(.text);
++      BUILD_DIR/libultra.a:cosf.o(.text);
++      BUILD_DIR/libultra.a:sinf.o(.text);
++      BUILD_DIR/libultra.a:guTranslateF.o(.text);
++      BUILD_DIR/libultra.a:guRotateF.o(.text);
++      BUILD_DIR/libultra.a:guScaleF.o(.text);
++#ifndef VERSION_EU
++      BUILD_DIR/libultra.a:osAiSetFrequency.o(.text);
++#endif
++      BUILD_DIR/libultra.a:alBnkfNew.o(.text);
++      BUILD_DIR/libultra.a:osWritebackDCache.o(.text);
++      BUILD_DIR/libultra.a:osAiGetLength.o(.text);
++      BUILD_DIR/libultra.a:osAiSetNextBuffer.o(.text);
++      BUILD_DIR/libultra.a:osTimer.o(.text);
++      BUILD_DIR/libultra.a:_Printf.o(.text);
++      BUILD_DIR/libultra.a:string.o(.text);
++      BUILD_DIR/libultra.a:__osDequeueThread.o(.text);
++      BUILD_DIR/libultra.a:__osDisableInt.o(.text);
++      BUILD_DIR/libultra.a:__osRestoreInt.o(.text);
++      BUILD_DIR/libultra.a:__osViInit.o(.text);
++      BUILD_DIR/libultra.a:__osExceptionPreamble.o(.text);
++      BUILD_DIR/libultra.a:osVirtualToPhysical.o(.text);
++      BUILD_DIR/libultra.a:__osSpSetStatus.o(.text);
++      BUILD_DIR/libultra.a:__osSpSetPc.o(.text);
++      BUILD_DIR/libultra.a:__osSpRawStartDma.o(.text);
++      BUILD_DIR/libultra.a:__osSpDeviceBusy.o(.text);
++      BUILD_DIR/libultra.a:__osSpGetStatus.o(.text);
++      BUILD_DIR/libultra.a:osGetThreadPri.o(.text);
++      BUILD_DIR/libultra.a:__osViGetCurrentContext.o(.text);
++      BUILD_DIR/libultra.a:__osViSwapContext.o(.text);
++      BUILD_DIR/libultra.a:osGetCount.o(.text);
++      BUILD_DIR/libultra.a:__osPiCreateAccessQueue.o(.text);
++      BUILD_DIR/libultra.a:osPiRawStartDma.o(.text);
++      BUILD_DIR/libultra.a:__osDevMgrMain.o(.text);
++      BUILD_DIR/libultra.a:__osSetSR.o(.text);
++      BUILD_DIR/libultra.a:__osGetSR.o(.text);
++      BUILD_DIR/libultra.a:__osSetFpcCsr.o(.text);
++      BUILD_DIR/libultra.a:__osSiRawReadIo.o(.text);
++      BUILD_DIR/libultra.a:__osSiRawWriteIo.o(.text);
++      BUILD_DIR/libultra.a:osMapTLBRdb.o(.text);
++      BUILD_DIR/libultra.a:osPiRawReadIo.o(.text);
++#if VERSION_JP
++      . += 0x40;
++#endif
++      BUILD_DIR/libultra.a:__osSiCreateAccessQueue.o(.text);
++      BUILD_DIR/libultra.a:__osSiRawStartDma.o(.text);
++      BUILD_DIR/libultra.a:osSetTimer.o(.text);
++      BUILD_DIR/libultra.a:osEepromWrite.o(.text);
++      BUILD_DIR/libultra.a:osJamMesg.o(.text);
++      BUILD_DIR/libultra.a:osPiGetCmdQueue.o(.text);
++      BUILD_DIR/libultra.a:osEepromRead.o(.text);
++      BUILD_DIR/libultra.a:guMtxF2L.o(.text);
++      BUILD_DIR/libultra.a:guMtxIdentF.o(.text);
++      BUILD_DIR/libultra.a:guNormalize.o(.text);
++      BUILD_DIR/libultra.a:__osAiDeviceBusy.o(.text);
++      BUILD_DIR/libultra.a:__osSetCompare.o(.text);
++      BUILD_DIR/libultra.a:_Litob.o(.text);
++      BUILD_DIR/libultra.a:_Ldtob.o(.text);
++      BUILD_DIR/libultra.a:kdebugserver.o(.text);
++      BUILD_DIR/libultra.a:__osSyncPutChars.o(.text);
++      BUILD_DIR/libultra.a:osSetIntMask.o(.text);
++      BUILD_DIR/libultra.a:osDestroyThread.o(.text);
++      BUILD_DIR/libultra.a:__osProbeTLB.o(.text);
++      BUILD_DIR/libultra.a:__osSiDeviceBusy.o(.text);
++      BUILD_DIR/libultra.a:ldiv.o(.text);
++      BUILD_DIR/libultra.a:__osGetCause.o(.text);
++      BUILD_DIR/libultra.a:__osAtomicDec.o(.text);
++      BUILD_DIR/libultra.a:guLookAtRef.o(.text); /* Fast3DEX2 only */
++      BUILD_DIR/lib/rsp.o(.text);
++#endif
++
++      /* data */
++      BUILD_DIR/src/game/crash_screen.o(.data*);
++      BUILD_DIR/src/game/main.o(.data*);
++      BUILD_DIR/src/game/game_init.o(.data*);
++      BUILD_DIR/src/game/sound_init.o(.data*);
++      BUILD_DIR/src/game/level_update.o(.data*);
++      BUILD_DIR/src/game/interaction.o(.data*);
++      BUILD_DIR/src/game/mario.o(.data*);
++      BUILD_DIR/src/game/mario_step.o(.data*);
++      BUILD_DIR/src/game/mario_actions_cutscene.o(.data*);
++      BUILD_DIR/src/game/mario_actions_moving.o(.data*);
++      BUILD_DIR/src/game/mario_actions_submerged.o(.data*);
++      BUILD_DIR/src/game/mario_actions_object.o(.data*);
++      BUILD_DIR/src/game/mario_misc.o(.data*);
++      BUILD_DIR/src/game/memory.o(.data*);
++      BUILD_DIR/src/game/save_file.o(.data*);
++      BUILD_DIR/src/game/area.o(.data*);
++      BUILD_DIR/src/game/rendering_graph_node.o(.data*);
++      BUILD_DIR/src/game/profiler.o(.data*);
++      BUILD_DIR/src/game/camera.o(.data*);
++      BUILD_DIR/src/game/object_list_processor.o(.data*);
++#ifndef VERSION_EU
++      BUILD_DIR/src/game/object_helpers.o(.data*);
++#endif
++      BUILD_DIR/src/game/behavior_actions.o(.data*);
++      BUILD_DIR/src/game/platform_displacement.o(.data*);
++      BUILD_DIR/src/game/spawn_sound.o(.data*);
++      BUILD_DIR/src/game/debug.o(.data*);
++      BUILD_DIR/src/game/screen_transition.o(.data*);
++      BUILD_DIR/src/game/shadow.o(.data*);
++      BUILD_DIR/src/game/skybox.o(.data*);
++      BUILD_DIR/src/game/moving_texture.o(.data*);
++      BUILD_DIR/src/game/geo_misc.o(.data*);
++      BUILD_DIR/src/game/paintings.o(.data*);
++      BUILD_DIR/src/game/print.o(.data*);
++      BUILD_DIR/src/game/ingame_menu.o(.data*);
++      BUILD_DIR/src/game/envfx_snow.o(.data*);
++      BUILD_DIR/src/game/envfx_bubbles.o(.data*);
++      BUILD_DIR/src/game/macro_special_objects.o(.data*);
++      BUILD_DIR/src/game/hud.o(.data*);
++      BUILD_DIR/src/game/obj_behaviors.o(.data*);
++      BUILD_DIR/src/game/obj_behaviors_2.o(.data*);
++#ifndef VERSION_EU
++      /* wildcard doesn't work on EU due to files being moved to engine/ */
++      BUILD_DIR/src/game*.o(.data*);
++#endif
++      BUILD_DIR/src/audio/external.o(.data*);
++      BUILD_DIR/src/audio/port_eu.o(.data*);
++      BUILD_DIR/src/audio/data.o(.data*);
++      BUILD_DIR/src/audio*.o(.data*);
++
++#ifdef VERSION_EU
++
++      BUILD_DIR/libultra.a:_Printf.o(.data*);
++      BUILD_DIR/libultra.a:osInitialize.o(.data*);
++      BUILD_DIR/libultra.a:osCreateViManager.o(.data*);
++      BUILD_DIR/libultra.a:osViTable.o(.data*);
++      BUILD_DIR/libultra.a:osCreatePiManager.o(.data*);
++      BUILD_DIR/libultra.a:osContInit.o(.data*);
++      BUILD_DIR/libultra.a:osAiSetNextBuffer.o(.data*);
++
++      BUILD_DIR/libultra.a:_Litob.o(.data*);
++
++      BUILD_DIR/libultra.a:__osExceptionPreamble.o(.data*);
++
++      BUILD_DIR/libultra.a:osTimer.o(.data*);
++      BUILD_DIR/libultra.a:__osViInit.o(.data*);
++      BUILD_DIR/libultra.a:__osDequeueThread.o(.data*);  // ffff...
++
++      BUILD_DIR/libultra.a:__osPiCreateAccessQueue.o(.data*);
++      BUILD_DIR/libultra.a:__osSiCreateAccessQueue.o(.data*);
++      BUILD_DIR/libultra.a:osViData.o(.data*);
++
++#else
++
++      BUILD_DIR/libultra.a:osViTable.o(.data*);
++      BUILD_DIR/libultra.a:osCreateViManager.o(.data*);
++      BUILD_DIR/libultra.a:osCreatePiManager.o(.data*);
++      BUILD_DIR/libultra.a:osInitialize.o(.data*);
++      BUILD_DIR/libultra.a:osContInit.o(.data*);
++      BUILD_DIR/libultra.a:osAiSetNextBuffer.o(.data*);
++      BUILD_DIR/libultra.a:osTimer.o(.data*);
++      BUILD_DIR/libultra.a:_Printf.o(.data*);
++      BUILD_DIR/libultra.a:__osDequeueThread.o(.data*);
++      BUILD_DIR/libultra.a:__osViInit.o(.data*);
++      BUILD_DIR/libultra.a:__osExceptionPreamble.o(.data*);
++      BUILD_DIR/libultra.a:__osPiCreateAccessQueue.o(.data*);
++      BUILD_DIR/libultra.a:__osSiCreateAccessQueue.o(.data*);
++      BUILD_DIR/libultra.a:_Litob.o(.data*);
++      BUILD_DIR/libultra.a:_Ldtob.o(.data*);
++      BUILD_DIR/libultra.a:osViData.o(.data*);
++      BUILD_DIR/libultra.a:kdebugserver.o(.data*);
++      BUILD_DIR/libultra.a:__osSyncPutChars.o(.data*);
++      BUILD_DIR/libultra.a:guRotateF.o(.data*);
++      BUILD_DIR/libultra.a:*.o(.data*);
++
++#endif
++
++
++      /* rodata */
++      BUILD_DIR/src/game/crash_screen.o(.rodata*);
++      BUILD_DIR/src/game/main.o(.rodata*);
++      BUILD_DIR/src/game/game_init.o(.rodata*);
++      BUILD_DIR/src/game/sound_init.o(.rodata*);
++      BUILD_DIR/src/game/level_update.o(.rodata*);
++      BUILD_DIR/src/game/interaction.o(.rodata*);
++      BUILD_DIR/src/game/mario.o(.rodata*);
++      BUILD_DIR/src/game/mario_step.o(.rodata*);
++      BUILD_DIR/src/game/mario_actions_cutscene.o(.rodata*);
++      BUILD_DIR/src/game/mario_actions_automatic.o(.rodata*);
++      BUILD_DIR/src/game/mario_actions_stationary.o(.rodata*);
++      BUILD_DIR/src/game/mario_actions_moving.o(.rodata*);
++      BUILD_DIR/src/game/mario_actions_airborne.o(.rodata*);
++      BUILD_DIR/src/game/mario_actions_submerged.o(.rodata*);
++      BUILD_DIR/src/game/mario_actions_object.o(.rodata*);
++      BUILD_DIR/src/game/mario_misc.o(.rodata*);
++      BUILD_DIR/src/game/area.o(.rodata*);
++      BUILD_DIR/src/game/rendering_graph_node.o(.rodata*);
++      BUILD_DIR/src/game/camera.o(.rodata*);
++      BUILD_DIR/src/game/object_list_processor.o(.rodata*);
++#ifndef VERSION_EU
++      BUILD_DIR/src/game/object_helpers.o(.rodata*);
++#endif
++      BUILD_DIR/src/game/behavior_actions.o(.rodata*);
++#ifndef VERSION_EU
++      BUILD_DIR/src/game/object_collision.o(.rodata*);
++      BUILD_DIR/src/game/spawn_object.o(.rodata*);
++#endif
++      BUILD_DIR/src/game/spawn_sound.o(.rodata*);
++      BUILD_DIR/src/game/debug.o(.rodata*);
++      BUILD_DIR/src/game/screen_transition.o(.rodata*);
++      BUILD_DIR/src/game/shadow.o(.rodata*);
++      BUILD_DIR/src/game/skybox.o(.rodata*);
++      BUILD_DIR/src/game/moving_texture.o(.rodata*);
++      BUILD_DIR/src/game/geo_misc.o(.rodata*);
++      BUILD_DIR/src/game/paintings.o(.rodata*);
++      BUILD_DIR/src/game/print.o(.rodata*);
++      BUILD_DIR/src/game/ingame_menu.o(.rodata*);
++      BUILD_DIR/src/game/envfx_snow.o(.rodata*);
++      BUILD_DIR/src/game/envfx_bubbles.o(.rodata*);
++      BUILD_DIR/src/game/macro_special_objects.o(.rodata*);
++      BUILD_DIR/src/game/hud.o(.rodata*);
++      BUILD_DIR/src/game/obj_behaviors.o(.rodata*);
++      BUILD_DIR/src/game/obj_behaviors_2.o(.rodata*);
++#ifndef VERSION_EU
++      BUILD_DIR/src/game*.o(.rodata*);
++#endif
++      BUILD_DIR/src/audio/synthesis.o(.rodata*);
++      BUILD_DIR/src/audio/heap.o(.rodata*);
++      BUILD_DIR/src/audio/load.o(.rodata*);
++      BUILD_DIR/src/audio/playback.o(.rodata*);
++      BUILD_DIR/src/audio/effects.o(.rodata*);
++      BUILD_DIR/src/audio/seqplayer.o(.rodata*);
++      BUILD_DIR/src/audio/external.o(.rodata*);
++      BUILD_DIR/src/audio/port_eu.o(.rodata*);
++      BUILD_DIR/src/audio*.o(.rodata*);
++
++#ifdef VERSION_EU
++      BUILD_DIR/libultra.a:_Printf.o(.rodata*);
++
++      BUILD_DIR/libultra.a:guPerspectiveF.o(.rodata*);
++      BUILD_DIR/libultra.a:llconv.o(.rodata*);
++      BUILD_DIR/libultra.a:cosf.o(.rodata*);
++      BUILD_DIR/libultra.a:sinf.o(.rodata*);
++      BUILD_DIR/libultra.a:guRotateF.o(.rodata*);
++
++      BUILD_DIR/libultra.a:_Litob.o(.rodata*);
++      BUILD_DIR/libultra.a:_Ldtob.o(.rodata*);
++      
++      BUILD_DIR/libultra.a:__osExceptionPreamble.o(.rodata*);
++      BUILD_DIR/libultra.a:__osDevMgrMain.o(.rodata*);
++      
++      BUILD_DIR/libultra.a:NaN.o(.rodata*);
++#else
++      BUILD_DIR/libultra.a:guPerspectiveF.o(.rodata*);
++      BUILD_DIR/libultra.a:llconv.o(.rodata*);
++      BUILD_DIR/libultra.a:cosf.o(.rodata*);
++      BUILD_DIR/libultra.a:sinf.o(.rodata*);
++      BUILD_DIR/libultra.a:guRotateF.o(.rodata*);
++      BUILD_DIR/libultra.a:_Printf.o(.rodata*);
++      BUILD_DIR/libultra.a:__osExceptionPreamble.o(.rodata*);
++      BUILD_DIR/libultra.a:NaN.o(.rodata*);
++      BUILD_DIR/libultra.a:_Litob.o(.rodata*);
++      BUILD_DIR/libultra.a:_Ldtob.o(.rodata*);
++#endif
++      BUILD_DIR/libultra.a:osSetIntMask.o(.rodata*);
++      BUILD_DIR/libultra.a:guLookAtRef.o(.rodata*); /* Fast3DEX2 only */
++#ifndef VERSION_EU
++      BUILD_DIR/libultra.a:*.o(.rodata*);
++#endif
++      BUILD_DIR/lib/rsp.o(.rodata*);
++   }
++   END_SEG(main)
++   BEGIN_NOLOAD(main)
++   {
++      BUILD_DIR/src/game/crash_screen.o(.bss*);
++      BUILD_DIR/src/game/main.o(.bss*);
++      BUILD_DIR/src/game/game_init.o(.bss*);
++      BUILD_DIR/src/game/sound_init.o(.bss*);
++      BUILD_DIR/src/game/level_update.o(.bss*);
++      BUILD_DIR/src/game/interaction.o(.bss*);
++      BUILD_DIR/src/game/mario.o(.bss*);
++      BUILD_DIR/src/game/mario_actions_cutscene.o(.bss*);
++      BUILD_DIR/src/game/mario_actions_moving.o(.bss*);
++      BUILD_DIR/src/game/mario_actions_submerged.o(.bss*);
++      BUILD_DIR/src/game/mario_misc.o(.bss*);
++      BUILD_DIR/src/game/memory.o(.bss*);
++      BUILD_DIR/src/game/save_file.o(.bss*);
++      BUILD_DIR/src/game/area.o(.bss*);
++      BUILD_DIR/src/game/rendering_graph_node.o(.bss*);
++      BUILD_DIR/src/game/profiler.o(.bss*);
++      BUILD_DIR/src/game/camera.o(.bss*);
++      BUILD_DIR/src/game/object_list_processor.o(.bss*);
++#ifndef VERSION_EU
++      BUILD_DIR/src/game/object_helpers.o(.bss*);
++#endif
++      BUILD_DIR/src/game/behavior_actions.o(.bss*);
++      BUILD_DIR/src/game/debug.o(.bss*);
++      BUILD_DIR/src/game/shadow.o(.bss*);
++      BUILD_DIR/src/game/skybox.o(.bss*);
++      BUILD_DIR/src/game/moving_texture.o(.bss*);
++      BUILD_DIR/src/game/geo_misc.o(.bss*);
++      BUILD_DIR/src/game/paintings.o(.bss*);
++      BUILD_DIR/src/game/print.o(.bss*);
++      BUILD_DIR/src/game/ingame_menu.o(.bss*);
++      BUILD_DIR/src/game/envfx_snow.o(.bss*);
++      BUILD_DIR/src/game/envfx_bubbles.o(.bss*);
++      BUILD_DIR/src/game/macro_special_objects.o(.bss*)
++      BUILD_DIR/src/game/hud.o(.bss*);
++      BUILD_DIR/src/game/obj_behaviors.o(.bss*);
++      BUILD_DIR/src/game/obj_behaviors_2.o(.bss*);
++#ifndef VERSION_EU
++      BUILD_DIR/src/game*.o(.bss*);
++#endif
++      BUILD_DIR/src/audio/external.o(.bss*);
++      BUILD_DIR/src/audio/port_eu.o(.bss*);
++   
++#ifdef VERSION_EU
++      BUILD_DIR/libultra.a:osInitialize.o(.bss*);
++
++      BUILD_DIR/libultra.a:osSetEventMesg.o(.bss*);
++      BUILD_DIR/libultra.a:osSpTaskLoadGo.o(.bss*);
++      BUILD_DIR/libultra.a:osCreateViManager.o(.bss*);
++      
++      BUILD_DIR/libultra.a:osCreatePiManager.o(.bss*);
++      BUILD_DIR/libultra.a:osContStartReadData.o(.bss*);
++      BUILD_DIR/libultra.a:osContInit.o(.bss*);
++
++      BUILD_DIR/libultra.a:guRotateF.o(.bss*);
++
++      BUILD_DIR/libultra.a:unk_stack_data.o(.bss*);
++      BUILD_DIR/libultra.a:osTimer.o(.bss*);
++      BUILD_DIR/libultra.a:__osPiCreateAccessQueue.o(.bss*);
++      BUILD_DIR/libultra.a:__osSiCreateAccessQueue.o(.bss*);
++      BUILD_DIR/libultra.a:osEepromWrite.o(.bss*);
++      
++      BUILD_DIR/libultra.a:kdebugserver.o(.bss*);
++      BUILD_DIR/libultra.a:osLeoDiskInit.o(.bss*)
++
++      BUILD_DIR/libultra.a:_Printf.o(.bss*);
++      BUILD_DIR/libultra.a:osAiSetNextBuffer.o(.bss*);
++      BUILD_DIR/libultra.a:EU_D_802f4330.o(.bss*);
++
++#else
++      BUILD_DIR/libultra.a:osSetEventMesg.o(.bss*);
++      BUILD_DIR/libultra.a:osSpTaskLoadGo.o(.bss*);
++      BUILD_DIR/libultra.a:osCreateViManager.o(.bss*);
++      BUILD_DIR/libultra.a:osCreatePiManager.o(.bss*);
++      BUILD_DIR/libultra.a:osInitialize.o(.bss*);
++      BUILD_DIR/libultra.a:osContStartReadData.o(.bss*);
++      BUILD_DIR/libultra.a:osContInit.o(.bss*);
++      BUILD_DIR/libultra.a:guRotateF.o(.bss*);
++      BUILD_DIR/libultra.a:osTimer.o(.bss*);
++      BUILD_DIR/libultra.a:_Printf.o(.bss*);
++      BUILD_DIR/libultra.a:__osPiCreateAccessQueue.o(.bss*);
++      BUILD_DIR/libultra.a:__osSiCreateAccessQueue.o(.bss*);
++      BUILD_DIR/libultra.a:osEepromWrite.o(.bss*);
++      BUILD_DIR/libultra.a:unk_stack_data.o(.bss*);
++      BUILD_DIR/libultra.a:kdebugserver.o(.bss*);
++      BUILD_DIR/libultra.a:*.o(.bss*);
++#endif
++
++      . = ALIGN(0x8);
++   }
++   END_NOLOAD(main)
++   _mainSegmentNoloadSizeLo = SIZEOF (.main.noload) & 0xffff;
++   _mainSegmentNoloadSizeHi = SIZEOF (.main.noload) >> 16;
++
++   ASSERT((. <= SEG_ENGINE), "Error: main segment extended into engine.")
++
++   BEGIN_SEG(engine, SEG_ENGINE)
++   {
++      BUILD_DIR/src/engine/math_util.o(.text);
++      BUILD_DIR/src/engine/graph_node.o(.text);
++      BUILD_DIR/src/engine/graph_node_manager.o(.text);
++      BUILD_DIR/src/engine/geo_layout.o(.text);
++      BUILD_DIR/src/engine/level_script.o(.text);
++      BUILD_DIR/src/engine/surface_collision.o(.text);
++      BUILD_DIR/src/engine/surface_load.o(.text);
++      BUILD_DIR/src/engine/behavior_script.o(.text);
++#ifdef VERSION_EU
++      BUILD_DIR/src/game/object_collision.o(.text);
++      BUILD_DIR/src/game/spawn_object.o(.text);
++      BUILD_DIR/src/game/object_helpers.o(.text);
++#endif
++      BUILD_DIR/src/engine*.o(.text);
++      /* data */
++      BUILD_DIR/src/engine/graph_node.o(.data*);
++      BUILD_DIR/src/engine/graph_node_manager.o(.data*);
++      BUILD_DIR/src/engine/math_util.o(.data*);
++      BUILD_DIR/src/engine/geo_layout.o(.data*);
++      BUILD_DIR/src/engine/level_script.o(.data*);
++      BUILD_DIR/src/engine/behavior_script.o(.data*);
++#ifdef VERSION_EU
++      BUILD_DIR/src/game/object_collision.o(.data*);
++      BUILD_DIR/src/game/spawn_object.o(.data*);
++      BUILD_DIR/src/game/object_helpers.o(.data*);
++#endif
++      BUILD_DIR/src/engine*.o(.data*);
++      /* rodata */
++      BUILD_DIR/src/engine/math_util.o(.rodata*);
++      BUILD_DIR/src/engine/level_script.o(.rodata*);
++      BUILD_DIR/src/engine/surface_collision.o(.rodata*);
++      BUILD_DIR/src/engine/surface_load.o(.rodata*);
++#ifdef VERSION_EU
++      BUILD_DIR/src/game/object_collision.o(.rodata*);
++      BUILD_DIR/src/game/spawn_object.o(.rodata*);
++      BUILD_DIR/src/game/object_helpers.o(.rodata*);
++#endif
++      BUILD_DIR/src/engine*.o(.rodata*);
++   }
++   END_SEG(engine)
++   BEGIN_NOLOAD(engine)
++   {
++      BUILD_DIR/src/engine/math_util.o(.bss*);
++      BUILD_DIR/src/engine/geo_layout.o(.bss*);
++      BUILD_DIR/src/engine/level_script.o(.bss*);
++      BUILD_DIR/src/engine/surface_collision.o(.bss*);
++      BUILD_DIR/src/engine/surface_load.o(.bss*);
++      BUILD_DIR/src/engine/behavior_script.o(.bss*);
++#ifdef VERSION_EU
++      BUILD_DIR/src/game/object_collision.o(.bss*);
++      BUILD_DIR/src/game/spawn_object.o(.bss*);
++      BUILD_DIR/src/game/object_helpers.o(.bss*);
++#endif
++      BUILD_DIR/src/engine*.o(.bss*);
++   }
++   END_NOLOAD(engine)
++
++   // ASSERT((. <= SEG_FRAMEBUFFERS), "Error: engine segment extended into framebuffers.")
++
++   . = SEG_FRAMEBUFFERS;
++   BEGIN_NOLOAD(framebuffers)
++   {
++      BUILD_DIR/src/buffers/framebuffers.o(.bss*);
++   }
++   END_NOLOAD(framebuffers)
++
++   __expansionRamStart = 0x80400000;
++   ASSERT((. <= __expansionRamStart), "Error: RDRAM expanded into Expansion RAM, despite Expansion RAM not being defined.")
++
++
++   BEGIN_SEG(entry, 0x10000000)
++   {
++      BUILD_DIR/levels/entry.o(.data);
++   }
++   END_SEG(entry)
++
++   /* load MIO0 and level data */
++   MIO0_SEG(segment2, 0x02000000)
++#ifdef VERSION_EU
++   MIO0_EU_SEG(translation_en, 0x19000000)
++   MIO0_EU_SEG(translation_fr, 0x19000000)
++   MIO0_EU_SEG(translation_de, 0x19000000)
++#endif
++
++   /* mario actor group */
++   STANDARD_OBJECTS(group0,  0x04000000, 0x17000000)
++
++   /* load the other actor groups */
++   STANDARD_OBJECTS(group1,  0x05000000, 0x0C000000)
++   STANDARD_OBJECTS(group2,  0x05000000, 0x0C000000)
++   STANDARD_OBJECTS(group3,  0x05000000, 0x0C000000)
++   STANDARD_OBJECTS(group4,  0x05000000, 0x0C000000)
++   STANDARD_OBJECTS(group5,  0x05000000, 0x0C000000)
++   STANDARD_OBJECTS(group6,  0x05000000, 0x0C000000)
++   STANDARD_OBJECTS(group7,  0x05000000, 0x0C000000)
++   STANDARD_OBJECTS(group8,  0x05000000, 0x0C000000)
++   STANDARD_OBJECTS(group9,  0x05000000, 0x0C000000)
++   STANDARD_OBJECTS(group10, 0x05000000, 0x0C000000)
++   STANDARD_OBJECTS(group11, 0x05000000, 0x0C000000)
++   STANDARD_OBJECTS(group12, 0x06000000, 0x0D000000)
++   STANDARD_OBJECTS(group13, 0x06000000, 0x0D000000)
++   STANDARD_OBJECTS(group14, 0x06000000, 0x0D000000)
++   STANDARD_OBJECTS(group15, 0x06000000, 0x0D000000)
++   STANDARD_OBJECTS(group16, 0x06000000, 0x0D000000)
++   STANDARD_OBJECTS(group17, 0x06000000, 0x0D000000)
++
++   /* load the common actor groups */
++   STANDARD_OBJECTS(common0, 0x08000000, 0x0F000000)
++   STANDARD_OBJECTS(common1, 0x03000000, 0x16000000)
++
++   /* use segmented addressing for behaviors */
++   BEGIN_SEG(behavior, 0x13000000)
++   {
++      BUILD_DIR/data/behavior_data.o(.data);
++   }
++   END_SEG(behavior)
++
++   /* 0x8016F000 21D7D0-255EC0 [386F0] */
++   BEGIN_SEG(goddard, SEG_GODDARD)
++   {
++      BUILD_DIR/src/menu/level_select_menu.o(.text);
++      BUILD_DIR/src/menu/intro_geo.o(.text);
++      BUILD_DIR/src/menu/file_select.o(.text);
++      BUILD_DIR/src/menu/star_select.o(.text);
++      BUILD_DIR/src/menu*.o(.text);
++      BUILD_DIR/libgoddard.a:gd_main.o(.text);
++      BUILD_DIR/libgoddard.a:gd_memory.o(.text);
++      BUILD_DIR/libgoddard.a:sfx.o(.text);
++      BUILD_DIR/libgoddard.a:draw_objects.o(.text);
++      BUILD_DIR/libgoddard.a:objects.o(.text);
++      BUILD_DIR/libgoddard.a:skin_movement.o(.text);
++      BUILD_DIR/libgoddard.a:particles.o(.text);
++      BUILD_DIR/libgoddard.a:dynlist_proc.o(.text);
++      BUILD_DIR/libgoddard.a:old_menu.o(.text);
++      BUILD_DIR/libgoddard.a:debug_utils.o(.text);
++      BUILD_DIR/libgoddard.a:joints.o(.text);
++      BUILD_DIR/libgoddard.a:skin.o(.text);
++      BUILD_DIR/libgoddard.a:gd_math.o(.text);
++      BUILD_DIR/libgoddard.a:shape_helper.o(.text);
++      BUILD_DIR/libgoddard.a:renderer.o(.text);
++      BUILD_DIR/libgoddard.a:*.o(.text);
++      /* data, rodata, per file */
++      BUILD_DIR/src/menu/level_select_menu.o(.data*);
++      BUILD_DIR/src/menu/level_select_menu.o(.rodata*);
++      BUILD_DIR/src/menu/intro_geo.o(.data*);
++      BUILD_DIR/src/menu/file_select.o(.data*);
++      BUILD_DIR/src/menu/file_select.o(.rodata*);
++      BUILD_DIR/src/menu/star_select.o(.data*);
++      BUILD_DIR/src/menu/star_select.o(.rodata*);
++      BUILD_DIR/src/menu*.o(.data*);
++      BUILD_DIR/src/menu*.o(.rodata*);
++      /* goddard subsystem data */
++      BUILD_DIR/libgoddard.a:gd_main.o(.data*);
++      BUILD_DIR/libgoddard.a:draw_objects.o(.data*);
++      BUILD_DIR/libgoddard.a:objects.o(.data*);
++      BUILD_DIR/libgoddard.a:particles.o(.data*);
++      BUILD_DIR/libgoddard.a:dynlist_proc.o(.data*);
++      BUILD_DIR/libgoddard.a:debug_utils.o(.data*);
++      BUILD_DIR/libgoddard.a:joints.o(.data*);
++      BUILD_DIR/libgoddard.a:shape_helper.o(.data*);
++      BUILD_DIR/libgoddard.a:renderer.o(.data*);
++      /* goddard subsystem rodata */
++      BUILD_DIR/libgoddard.a:gd_main.o(.rodata*);
++      BUILD_DIR/libgoddard.a:gd_memory.o(.rodata*);
++      BUILD_DIR/libgoddard.a:draw_objects.o(.rodata*);
++      BUILD_DIR/libgoddard.a:objects.o(.rodata*);
++      BUILD_DIR/libgoddard.a:skin_movement.o(.rodata*);
++      BUILD_DIR/libgoddard.a:particles.o(.rodata*);
++      BUILD_DIR/libgoddard.a:dynlist_proc.o(.rodata*);
++      BUILD_DIR/libgoddard.a:old_menu.o(.rodata*);
++      BUILD_DIR/libgoddard.a:debug_utils.o(.rodata*);
++      BUILD_DIR/libgoddard.a:joints.o(.rodata*);
++      BUILD_DIR/libgoddard.a:skin.o(.rodata*);
++      BUILD_DIR/libgoddard.a:gd_math.o(.rodata*);
++      BUILD_DIR/libgoddard.a:shape_helper.o(.rodata*);
++      BUILD_DIR/libgoddard.a:renderer.o(.rodata*);
++   }
++   END_SEG(goddard)
++   BEGIN_NOLOAD(goddard)
++   {
++      BUILD_DIR/src/menu/intro_geo.o(.bss*);
++      BUILD_DIR/src/menu/file_select.o(.bss*);
++      BUILD_DIR/src/menu/star_select.o(.bss*);
++      BUILD_DIR/src/menu*.o(.bss*);
++      BUILD_DIR/libgoddard.a:gd_main.o(.bss*);
++      BUILD_DIR/libgoddard.a:gd_memory.o(.bss*);
++      BUILD_DIR/libgoddard.a:sfx.o(.bss*);
++      BUILD_DIR/libgoddard.a:draw_objects.o(.bss*);
++      BUILD_DIR/libgoddard.a:objects.o(.bss*);
++      BUILD_DIR/libgoddard.a:skin_movement.o(.bss*);
++      BUILD_DIR/libgoddard.a:particles.o(.bss*);
++      BUILD_DIR/libgoddard.a:dynlist_proc.o(.bss*);
++      BUILD_DIR/libgoddard.a:old_menu.o(.bss*);
++      BUILD_DIR/libgoddard.a:debug_utils.o(.bss*);
++      BUILD_DIR/libgoddard.a:joints.o(.bss*);
++      BUILD_DIR/libgoddard.a:skin.o(.bss*);
++      BUILD_DIR/libgoddard.a:shape_helper.o(.bss*);
++      BUILD_DIR/libgoddard.a:renderer.o(.bss*);
++      BUILD_DIR/libgoddard.a:*.o(.bss*);
++   }
++   END_NOLOAD(goddard)
++
++   ASSERT((. <= SEG_POOL_END), "Error: extended past pool end.")
++
++   . = SEG_BUFFERS;
++   BEGIN_NOLOAD(buffers)
++   {
++      BUILD_DIR/src/buffers/buffers.o(.bss*);
++      BUILD_DIR/src/audio/globals_start.o(.bss*);
++
++      BUILD_DIR/src/audio/synthesis.o(.bss*);
++      BUILD_DIR/src/audio/heap.o(.bss*);
++      BUILD_DIR/src/audio/load.o(.bss*);
++      BUILD_DIR/src/audio/data.o(.bss*);
++      BUILD_DIR/src/audio/globals_end.o(.bss*);
++#ifdef VERSION_EU
++      . += 0x4f0;
++#endif
++      
++#ifndef VERSION_EU
++      . = ALIGN(0x1000);
++#endif
++      BUILD_DIR/src/buffers/gfx_output_buffer.o(.bss*);
++
++      BUILD_DIR/src/audio*.o(.bss*);
++   }
++   END_NOLOAD(buffers)
++
++   /* While EU is being worked on, don't warn for a too large buffers segment.
++    * This is a broken thing to do, so please enforce this again when it's fixed! */
++#ifndef VERSION_EU
++   ASSERT((. <= SEG_MAIN), "Error: buffers segment extended into main.")
++#endif
++
++   /* 0x268020 0x268020-0 [0] */
++   BEGIN_SEG(intro, 0x14000000)
++   {
++      BUILD_DIR/levels/intro/script.o(.data);
++      BUILD_DIR/levels/intro/geo.o(.data);
++   }
++   END_SEG(intro)
++   BEGIN_SEG(intro_segment_7, 0x07000000)
++   {
++      BUILD_DIR/levels/intro/leveldata.mio0.o(.data);
++      . = ALIGN(0x10);
++   }
++   END_SEG(intro_segment_7)
++
++   MIO0_SEG(debug_level_select, 0x07000000)
++   MIO0_SEG(title_screen_bg, 0x0A000000)
++
++   /* 271B20-2A42A0 [32780] */
++   BEGIN_SEG(gd_dynlists, 0x04000000)
++   {
++      BUILD_DIR/libgoddard.a:dynlist_test_cube.o(.data);
++      BUILD_DIR/libgoddard.a:dynlist_unused.o(.data);
++      BUILD_DIR/libgoddard.a:dynlist_mario_face.o(.data);
++      BUILD_DIR/libgoddard.a:dynlists_mario_eyes.o(.data);
++      BUILD_DIR/libgoddard.a:dynlists_mario_eyebrows_mustache.o(.data);
++      BUILD_DIR/libgoddard.a:dynlist_mario_master.o(.data);
++      BUILD_DIR/libgoddard.a:anim_mario_mustache_right.o(.data);
++      BUILD_DIR/libgoddard.a:anim_mario_mustache_left.o(.data);
++      BUILD_DIR/libgoddard.a:anim_mario_lips_1.o(.data);
++      BUILD_DIR/libgoddard.a:anim_mario_lips_2.o(.data);
++      BUILD_DIR/libgoddard.a:anim_mario_eyebrows_1.o(.data);
++      BUILD_DIR/libgoddard.a:anim_group_1.o(.data);
++      BUILD_DIR/libgoddard.a:anim_group_2.o(.data);
++      BUILD_DIR/libgoddard.a:dynlist_test_cube.o(.rodata*);
++      BUILD_DIR/libgoddard.a:dynlist_unused.o(.rodata*);
++      BUILD_DIR/libgoddard.a:*.o(.data);
++      BUILD_DIR/libgoddard.a:*.o(.rodata);
++   }
++   END_SEG(gd_dynlists)
++
++   gMainLevels = __romPos;
++
++   BEGIN_SEG(menu, 0x14000000)
++   {
++      BUILD_DIR/levels/menu/script.o(.data);
++      BUILD_DIR/levels/menu/geo.o(.data);
++   }
++   END_SEG(menu)
++   BEGIN_SEG(menu_segment_7, 0x07000000)
++   {
++      BUILD_DIR/levels/menu/leveldata.mio0.o(.data);
++      . = ALIGN(0x10);
++   }
++   END_SEG(menu_segment_7)
++
++   BEGIN_SEG(scripts, 0x15000000)
++   {
++      BUILD_DIR/levels/scripts.o(.data);
++   }
++   END_SEG(scripts)
++
++   MIO0_SEG(water_skybox, 0x0A000000)
++   MIO0_SEG(ccm_skybox, 0x0A000000)
++   MIO0_SEG(clouds_skybox, 0x0A000000)
++   MIO0_SEG(bitfs_skybox, 0x0A000000)
++   MIO0_SEG(wdw_skybox, 0x0A000000)
++   MIO0_SEG(cloud_floor_skybox, 0x0A000000)
++   MIO0_SEG(ssl_skybox, 0x0A000000)
++   MIO0_SEG(bbh_skybox, 0x0A000000)
++   MIO0_SEG(bidw_skybox, 0x0A000000)
++   MIO0_SEG(bits_skybox, 0x0A000000)
++
++   // Texture bins
++   MIO0_SEG(fire, 0x09000000)
++   MIO0_SEG(spooky, 0x09000000)
++   MIO0_SEG(generic, 0x09000000)
++   MIO0_SEG(water, 0x09000000)
++   MIO0_SEG(sky, 0x09000000)
++   MIO0_SEG(snow, 0x09000000)
++   MIO0_SEG(cave, 0x09000000)
++   MIO0_SEG(machine, 0x09000000)
++   MIO0_SEG(mountain, 0x09000000)
++   MIO0_SEG(grass, 0x09000000)
++   MIO0_SEG(outside, 0x09000000)
++   MIO0_SEG(inside, 0x09000000)
++   MIO0_SEG(effect, 0x0B000000)
++
++#define STUB_LEVEL(_0, _1, _2, _3, _4, _5, _6, _7, _8)
++#define DEFINE_LEVEL(_0, _1, _2, folder, _4, _5, _6, _7, _8, _9, _10) STANDARD_LEVEL(folder)
++
++   #include "levels/level_defines.h"
++
++#undef STUB_LEVEL
++#undef DEFINE_LEVEL
++
++   /* 4E9FA0-? [?] */
++   BEGIN_SEG(assets, __romPos)
++   {
++      BUILD_DIR/assets/mario_anim_data.o(.data);
++      BUILD_DIR/assets/mario_anim_data.o(.rodata);
++      BUILD_DIR/assets/demo_data.o(.data);
++      gSoundDataADSR = .;
++      BUILD_DIR/sound/sound_data.ctl.o(.data);
++      gSoundDataRaw = .;
++      BUILD_DIR/sound/sound_data.tbl.o(.data);
++      gMusicData = .;
++      BUILD_DIR/sound/sequences.bin.o(.data);
++      gBankSetsData = .;
++      BUILD_DIR/sound/bank_sets.o(.data);
++   }
++   END_SEG(assets)
++
++   /* Discard everything not specifically mentioned above. */
++   /DISCARD/ :
++   {
++      *(*);
++   }
++}
+diff --git a/src/game/area.c b/src/game/area.c
+index 82d17a3..301ab90 100644
+--- a/src/game/area.c
++++ b/src/game/area.c
+@@ -119,8 +119,8 @@ void print_intro_text(void) {
+ #ifdef VERSION_EU
+             print_text(20, 20, "START");
+ #else
+-            print_text_centered(60, 38, "PRESS");
+-            print_text_centered(60, 20, "START");
++            print_text_centered(60, 38, "BRRRR");
++            print_text_centered(60, 20, "AP!!!");
+ #endif
+         }
+     }
+diff --git a/src/game/camera.c b/src/game/camera.c
+index e0bf05f..1e879a0 100644
+--- a/src/game/camera.c
++++ b/src/game/camera.c
+@@ -2142,7 +2142,7 @@ s16 update_default_camera(struct Camera *c) {
+             nextYawVel = 0x100;
+         }
+         if ((gPlayer1Controller->stickX != 0.f || gPlayer1Controller->stickY != 0.f) != 0) {
+-            nextYawVel = 0x20;
++            nextYawVel = 0x50;
+         }
+     } else {
+         if (sCSideButtonYaw < 0) {
+diff --git a/src/game/crash.c b/src/game/crash.c
+new file mode 100644
+index 0000000..587ac86
+--- /dev/null
++++ b/src/game/crash.c
+@@ -0,0 +1,291 @@
++/* SM64 Crash Handler */
++
++#include <sm64.h>
++
++#include "crash.h"
++
++extern u32 exceptionRegContext[];
++
++extern char *pAssertFile;
++extern int nAssertLine;
++extern char *pAssertExpression;
++extern int nAssertStopProgram;
++
++u16 fbFillColor = 0xFFFF;
++u16 fbShadeColor = 0x0000;
++u16 *fbAddress = NULL;
++
++extern u8 crashFont[];
++
++const char *szErrCodes[] = {
++    "INTERRUPT",
++    "TLB MOD",
++    "UNMAPPED LOAD ADDR",
++    "UNMAPPED STORE ADDR",
++    "BAD LOAD ADDR",
++    "BAD STORE ADDR",
++    "BUS ERR ON INSTR FETCH",
++    "BUS ERR ON LOADSTORE",
++    "SYSCALL",
++    "BREAKPOINT",
++    "UNKNOWN INSTR",
++    "COP UNUSABLE",
++    "ARITHMETIC OVERFLOW",
++    "TRAP EXC",
++    "VIRTUAL COHERENCY INSTR",
++    "FLOAT EXC",
++};
++
++const char *szGPRegisters1[] = { "R0", "AT", "V0", "V1", "A0", "A1", "A2", "A3",
++                                 "T0", "T1", "T2", "T3", "T4", "T5", "T6", NULL };
++
++const char *szGPRegisters2[] = { "T7", "S0", "S1", "S2", "S3", "S4",
++                                 "S5", "S6", "S7", "T8", "T9", /*"K0", "K1",*/
++                                 "GP", "SP", "FP", "RA", NULL };
++
++/*
++    Generates new preamble code at the exception vectors (0x000, 0x180)
++
++    eg: generate_exception_preambles(crash_handler_entry);
++
++    000: lui   k0, hi(crash_handler_entry)
++    004: addiu k0, k0, lo(crash_handler_entry)
++    008: jr    k0
++    00C: nop
++*/
++void generate_exception_preambles(void *entryPoint) {
++    u8 *mem = (u8 *) 0xA0000000;
++    int offs = 0;
++    int i;
++
++    u16 hi = (u32) entryPoint >> 16;
++    u16 lo = (u32) entryPoint & 0xFFFF;
++
++    if (lo & 0x8000) {
++        hi++;
++    }
++
++    for (i = 0; i < 2; i++) {
++        *(u32 *) &mem[offs + 0x00] = 0x3C1A0000 | hi;
++        *(u32 *) &mem[offs + 0x04] = 0x275A0000 | lo;
++        *(u32 *) &mem[offs + 0x08] = 0x03400008;
++        *(u32 *) &mem[offs + 0x0C] = 0x00000000;
++        offs += 0x180;
++    }
++}
++
++int crash_strlen(char *str) {
++    int len = 0;
++    while (*str++) {
++        len++;
++    }
++    return len;
++}
++
++void show_crash_screen_and_hang(void) {
++    u32 cause;
++    u32 epc;
++    u8 errno;
++
++    fb_set_address((void *) (*(u32 *) 0xA4400004 | 0x80000000)); // replace me
++
++    cause = cop0_get_cause();
++    epc = cop0_get_epc();
++
++    errno = (cause >> 2) & 0x1F;
++
++    if (nAssertStopProgram == 0) {
++        fbFillColor = 0x6253;
++        fb_fill(10, 10, 300, 220);
++
++        fb_print_str(80, 20, "AN ERROR HAS OCCURRED!");
++        fb_print_int_hex(80, 30, errno, 8);
++        fb_print_str(107, 30, szErrCodes[errno]);
++
++        if (errno >= 2 && errno <= 5) {
++            /*
++            2 UNMAPPED LOAD ADDR
++            3 UNMAPPED STORE ADDR
++            4 BAD LOAD ADDR
++            5 BAD STORE ADDR
++            */
++            u32 badvaddr = cop0_get_badvaddr();
++
++            fb_print_str(188, 50, "VA");
++            fb_print_int_hex(215, 50, badvaddr, 32);
++        }
++    } else {
++        int afterFileX;
++        int exprBoxWidth;
++        fbFillColor = 0x5263;
++        fb_fill(10, 10, 300, 220);
++
++        fb_print_str(80, 20, "ASSERTION FAILED!");
++
++        afterFileX = fb_print_str(80, 30, pAssertFile);
++        fb_print_str(afterFileX, 30, ":");
++        fb_print_uint(afterFileX + 5, 30, nAssertLine);
++
++        exprBoxWidth = (crash_strlen(pAssertExpression) * 5) + 2;
++        fbFillColor = 0x0001;
++        fb_fill(80 - 1, 40 - 1, exprBoxWidth, 10);
++        fb_print_str(80, 40, pAssertExpression);
++    }
++
++    fb_print_str(80, 50, "PC");
++    fb_print_int_hex(95, 50, epc, 32);
++
++    fb_print_gpr_states(80, 70, szGPRegisters1, &exceptionRegContext[6 + 0]);
++    fb_print_gpr_states(145, 70, szGPRegisters2, &exceptionRegContext[6 + 15 * 2]);
++
++    fb_swap();
++    osWritebackDCacheAll();
++
++    while (1) // hang forever
++    {
++        UNUSED volatile int t = 0; // keep pj64 happy
++    }
++}
++
++u8 ascii_to_idx(char c) {
++    return c - 0x20;
++}
++
++void fb_set_address(void *address) {
++    fbAddress = (u16 *) address;
++}
++
++void fb_swap() {
++    // update VI frame buffer register
++    // todo other registers
++    *(u32 *) (0xA4400004) = (u32) fbAddress & 0x00FFFFFF;
++}
++
++void fb_fill(int baseX, int baseY, int width, int height) {
++    int y, x;
++
++    for (y = baseY; y < baseY + height; y++) {
++        for (x = baseX; x < baseX + width; x++) {
++            fbAddress[y * 320 + x] = fbFillColor;
++        }
++    }
++}
++
++void fb_draw_char(int x, int y, u8 idx) {
++    u16 *out = &fbAddress[y * 320 + x];
++    const u8 *in = &crashFont[idx * 3];
++    int nbyte;
++    int nrow;
++    int ncol;
++
++    for (nbyte = 0; nbyte < 3; nbyte++) {
++        u8 curbyte = in[nbyte];
++        for (nrow = 0; nrow < 2; nrow++) {
++            for (ncol = 0; ncol < 4; ncol++) {
++                u8 px = curbyte & (1 << 7 - (nrow * 4 + ncol));
++                if (px != 0) {
++                    out[ncol] = fbFillColor;
++                }
++            }
++            out += 320;
++        }
++    }
++}
++
++void fb_draw_char_shaded(int x, int y, u8 idx) {
++    fbFillColor = 0x0001;
++    fb_draw_char(x - 1, y + 1, idx);
++
++    fbFillColor = 0xFFFF;
++    fb_draw_char(x, y, idx);
++}
++
++int fb_print_str(int x, int y, const char *str) {
++    while (1) {
++        int yoffs = 0;
++        u8 idx;
++        char c = *str++;
++
++        if (c == '\0') {
++            break;
++        }
++
++        if (c == ' ') {
++            x += 5;
++            continue;
++        }
++
++        switch (c) {
++            case 'j':
++            case 'g':
++            case 'p':
++            case 'q':
++            case 'y':
++            case 'Q':
++                yoffs = 1;
++                break;
++            case ',':
++                yoffs = 2;
++                break;
++        }
++
++        idx = ascii_to_idx(c);
++        fb_draw_char_shaded(x, y + yoffs, idx);
++        x += 5;
++    }
++
++    return x;
++}
++
++void fb_print_int_hex(int x, int y, u32 value, int nbits) {
++    nbits -= 4;
++
++    while (nbits >= 0) {
++        int nib = ((value >> nbits) & 0xF);
++        u8 idx;
++
++        if (nib > 9) {
++            idx = ('A' - 0x20) + (nib - 0xa);
++        } else {
++            idx = ('0' - 0x20) + nib;
++        }
++
++        fb_draw_char_shaded(x, y, idx);
++        x += 5;
++
++        nbits -= 4;
++    }
++}
++
++int fb_print_uint(int x, int y, u32 value) {
++    int nchars = 0;
++
++    int v = value;
++    int i;
++    while (v /= 10) {
++        nchars++;
++    }
++
++    x += nchars * 5;
++
++    for (i = nchars; i >= 0; i--) {
++        fb_draw_char_shaded(x, y, ('0' - 0x20) + (value % 10));
++        value /= 10;
++        x -= 5;
++    }
++
++    return (x + nchars * 5);
++}
++
++void fb_print_gpr_states(int x, int y, const char *regNames[], u32 *regContext) {
++    int i;
++    for (i = 0;; i++) {
++        if (regNames[i] == NULL) {
++            break;
++        }
++
++        fb_print_str(x, y, regNames[i]);
++        fb_print_int_hex(x + 15, y, regContext[i * 2 + 1], 32);
++        y += 10;
++    }
++}
+diff --git a/src/game/crash.h b/src/game/crash.h
+new file mode 100644
+index 0000000..da4e011
+--- /dev/null
++++ b/src/game/crash.h
+@@ -0,0 +1,29 @@
++#ifndef _CRASH_H_
++#define _CRASH_H_
++
++#include <types.h>
++
++#define CRASH_SCREEN_INCLUDED 1
++
++extern u32 cop0_get_cause(void);
++extern u32 cop0_get_epc(void);
++extern u32 cop0_get_badvaddr(void);
++
++extern void _n64_assert(const char* pFile, int nLine, const char *pExpression, int nStopProgram);
++
++extern u8 __crash_handler_entry[];
++
++void generate_exception_preambles(void *entryPoint);
++void show_crash_screen_and_hang(void);
++u8 ascii_to_idx(char c);
++void fb_set_address(void *address);
++void fb_swap(void);
++void fb_fill(int baseX, int baseY, int width, int height);
++void fb_draw_char(int x, int y, u8 idx);
++void fb_draw_char_shaded(int x, int y, u8 idx);
++int fb_print_str(int x, int y, const char *str);
++int fb_print_uint(int x, int y, u32 value);
++void fb_print_int_hex(int x, int y, u32 value, int nbits);
++void fb_print_gpr_states(int x, int y, const char* regStrs[], u32 *regContext);
++
++#endif /* _CRASH_H_ */
+diff --git a/src/game/mario.c b/src/game/mario.c
+index aace34f..419315e 100644
+--- a/src/game/mario.c
++++ b/src/game/mario.c
+@@ -790,6 +790,11 @@ static u32 set_mario_action_airborne(struct MarioState *m, u32 action, u32 actio
+             m->forwardVel *= 0.8f;
+             break;
+ 
++        case ACT_GROUND_POUND_JUMP:
++            set_mario_y_vel_based_on_fspeed(m, 65.0f, 0.0f);
++            m->forwardVel *= 0.8f;
++            break;
++
+         case ACT_BACKFLIP:
+             m->marioObj->header.gfx.unk38.animID = -1;
+             m->forwardVel = -16.0f;
+@@ -862,6 +867,11 @@ static u32 set_mario_action_airborne(struct MarioState *m, u32 action, u32 actio
+             }
+             mario_set_forward_vel(m, fowardVel);
+             break;
++        
++        case ACT_GROUND_POUND_DIVE:
++            mario_set_forward_vel(m, 60.0f);
++            m->vel[1] = 15.0f;
++            break;
+ 
+         case ACT_LONG_JUMP:
+             m->marioObj->header.gfx.unk38.animID = -1;
+@@ -1039,7 +1049,7 @@ s32 set_jump_from_landing(struct MarioState *m) {
+                     break;
+ 
+                 case ACT_FREEFALL_LAND:
+-                    set_mario_action(m, ACT_DOUBLE_JUMP, 0);
++                    set_mario_action(m, ACT_JUMP, 0);
+                     break;
+ 
+                 case ACT_SIDE_FLIP_LAND_STOP:
+diff --git a/src/game/mario.h b/src/game/mario.h
+index 204cffc..518cdef 100644
+--- a/src/game/mario.h
++++ b/src/game/mario.h
+@@ -36,7 +36,8 @@ extern s32 mario_facing_downhill(struct MarioState *m, s32 turnYaw);
+ extern u32 mario_floor_is_slippery(struct MarioState *m);
+ extern s32 mario_floor_is_slope(struct MarioState *m);
+ extern s32 mario_floor_is_steep(struct MarioState *m);
+-extern f32 find_floor_height_relative_polar(struct MarioState *m, s16 angleFromMario, f32 distFromMario);
++extern f32 find_floor_height_relative_polar(struct MarioState *m, s16 angleFromMario,
++                                            f32 distFromMario);
+ extern s16 find_floor_slope(struct MarioState *m, s16 yawOffset);
+ extern void update_mario_sound_and_camera(struct MarioState *m);
+ extern void set_steep_jump_action(struct MarioState *m);
+@@ -53,4 +54,15 @@ extern s32 execute_mario_action(struct Object *o);
+ extern void init_mario(void);
+ extern void init_mario_from_save_file(void);
+ 
++/* clang-format off */
++// ADDITIONAL ACTIONS
++#define ACT_LEDGE_MOVE                  0x00000550 // (0x150 | ACT_FLAG_MOVING)
++
++#define ACT_WALL_KICK_SLIDE             0x0000088F // (0x08F | ACT_FLAG_AIR)
++#define ACT_GROUND_POUND_DIVE           0x01880891 // (0x091 | ACT_FLAG_AIR | ACT_FLAG_DIVING | ACT_FLAG_ATTACKING | ACT_FLAG_ALLOW_VERTICAL_WIND_ACTION)
++#define ACT_GROUND_POUND_JUMP           0x03000890 // (0x090 | ACT_FLAG_AIR | ACT_FLAG_ALLOW_VERTICAL_WIND_ACTION | ACT_FLAG_CONTROL_JUMP_HEIGHT)
++
++#define ACT_WATER_GROUND_POUND          0x300024FC // (0x0FC | ACT_FLAG_MOVING | ACT_FLAG_SWIMMING | ACT_FLAG_SWIMMING_OR_FLYING | ACT_FLAG_WATER_OR_TEXT)
++#define ACT_QUICK_DIVE                  0x300024FD // (0x0FD | ACT_FLAG_MOVING | ACT_FLAG_SWIMMING | ACT_FLAG_SWIMMING_OR_FLYING | ACT_FLAG_WATER_OR_TEXT)
++
+ #endif /* _MARIO_H */
+diff --git a/src/game/mario_actions_airborne.c b/src/game/mario_actions_airborne.c
+index 92e5dab..1a9a6de 100644
+--- a/src/game/mario_actions_airborne.c
++++ b/src/game/mario_actions_airborne.c
+@@ -103,7 +103,11 @@ s32 check_fall_damage(struct MarioState *m, u32 hardFallAction) {
+ 
+ s32 check_kick_or_dive_in_air(struct MarioState *m) {
+     if (m->input & INPUT_B_PRESSED) {
+-        return set_mario_action(m, m->forwardVel > 28.0f ? ACT_DIVE : ACT_JUMP_KICK, 0);
++        return set_mario_action(m,
++                                m->forwardVel > 28.0f
++                                    ? (m->input & INPUT_NONZERO_ANALOG ? ACT_DIVE : ACT_JUMP_KICK)
++                                    : ACT_JUMP_KICK,
++                                0);
+     }
+     return FALSE;
+ }
+@@ -455,9 +459,10 @@ s32 act_jump(struct MarioState *m) {
+ }
+ 
+ s32 act_double_jump(struct MarioState *m) {
+-    s32 animation = (m->vel[1] >= 0.0f) 
+-        ? MARIO_ANIM_DOUBLE_JUMP_RISE 
+-        : MARIO_ANIM_DOUBLE_JUMP_FALL;
++    s32 animation =
++        m->action == ACT_GROUND_POUND_JUMP
++            ? MARIO_ANIM_SINGLE_JUMP
++            : ((m->vel[1] >= 0.0f) ? MARIO_ANIM_DOUBLE_JUMP_RISE : MARIO_ANIM_DOUBLE_JUMP_FALL);
+ 
+     if (check_kick_or_dive_in_air(m)) {
+         return TRUE;
+@@ -467,6 +472,11 @@ s32 act_double_jump(struct MarioState *m) {
+         return set_mario_action(m, ACT_GROUND_POUND, 0);
+     }
+ 
++    if (m->action == ACT_GROUND_POUND_JUMP) {
++        m->marioObj->header.gfx.angle[1] = DEGREES(360 - (12 * m->actionTimer++));
++        if (m->actionTimer == 31) m->actionTimer = 30;
++    }
++
+     play_mario_sound(m, SOUND_ACTION_TERRAIN_JUMP, SOUND_MARIO_HOOHOO);
+     common_air_action_step(m, ACT_DOUBLE_JUMP_LAND, animation,
+                            AIR_STEP_CHECK_LEDGE_GRAB | AIR_STEP_CHECK_HANG);
+@@ -503,6 +513,22 @@ s32 act_triple_jump(struct MarioState *m) {
+ }
+ 
+ s32 act_backflip(struct MarioState *m) {
++    if (m->actionTimer++ >= 8 && m->wall && m->input & INPUT_NONZERO_ANALOG) {
++        s16 wallDYaw, wallDJoy;
++        s16 angle = m->faceAngle[1];
++        if (m->forwardVel < 0)
++            angle += 0x8000;
++        wallDYaw = atan2s(m->wall->normal.z, m->wall->normal.x) - angle;
++        wallDJoy = atan2s(m->wall->normal.z, m->wall->normal.x) - m->intendedYaw;
++
++        if ((wallDJoy < -0x6000 || wallDJoy > 0x6000) && (wallDYaw < -0x6000 || wallDYaw > 0x6000)) {
++            if (m->forwardVel >= 0)
++                m->faceAngle[1] += 0x8000;
++            play_sound(SOUND_ACTION_BONK, m->marioObj->header.gfx.cameraToObject);
++            return set_mario_action(m, ACT_WALL_KICK_SLIDE, 0);
++        }
++    }
++
+     if (m->input & INPUT_Z_PRESSED) {
+         return set_mario_action(m, ACT_GROUND_POUND, 0);
+     }
+@@ -627,6 +653,8 @@ s32 act_wall_kick_air(struct MarioState *m) {
+ 
+ s32 act_long_jump(struct MarioState *m) {
+     s32 animation;
++    m->forwardVel = MAX(m->forwardVel, 0.0f);
++
+     if (!m->marioObj->oMarioLongJumpIsSlow) {
+         animation = MARIO_ANIM_FAST_LONGJUMP;
+     } else {
+@@ -640,7 +668,8 @@ s32 act_long_jump(struct MarioState *m) {
+         m->actionState = 1;
+     }
+ 
+-    common_air_action_step(m, ACT_LONG_JUMP_LAND, animation, AIR_STEP_CHECK_LEDGE_GRAB);
++    common_air_action_step(m, m->forwardVel > 20.0f ? ACT_LONG_JUMP_LAND : ACT_FREEFALL_LAND, animation,
++                           AIR_STEP_CHECK_LEDGE_GRAB);
+ #ifdef VERSION_SH
+     if (m->action == ACT_LONG_JUMP_LAND) {
+         queue_rumble_data(5, 40);
+@@ -677,8 +706,12 @@ s32 act_twirling(struct MarioState *m) {
+     s16 startTwirlYaw = m->twirlYaw;
+     s16 yawVelTarget;
+ 
+-    if (m->input & INPUT_A_DOWN) {
++    if (m->input & INPUT_Z_DOWN) {
++        yawVelTarget = 0x2800;
++        m->pos[1] -= 30.0f;
++    } else if (m->input & INPUT_A_DOWN) {
+         yawVelTarget = 0x2000;
++        m->pos[1] += 5.0f;
+     } else {
+         yawVelTarget = 0x1800;
+     }
+@@ -695,10 +728,18 @@ s32 act_twirling(struct MarioState *m) {
+         play_sound(SOUND_ACTION_TWIRL, m->marioObj->header.gfx.cameraToObject);
+     }
+ 
+-    update_lava_boost_or_twirling(m);
+-
++    if (!(m->input & INPUT_Z_DOWN))
++        update_lava_boost_or_twirling(m);
++    else {
++        m->particleFlags |= PARTICLE_DUST;
++        mario_set_forward_vel(m, 0.0f);
++    }
+     switch (perform_air_step(m, 0)) {
+         case AIR_STEP_LANDED:
++            if (m->input & INPUT_Z_DOWN) {
++                m->particleFlags |= PARTICLE_HORIZONTAL_STAR | PARTICLE_MIST_CIRCLE;
++                return set_mario_action(m, ACT_TRIPLE_JUMP_LAND, 0);
++            }
+             set_mario_action(m, ACT_TWIRL_LAND, 0);
+             break;
+ 
+@@ -914,6 +955,10 @@ s32 act_ground_pound(struct MarioState *m) {
+ 
+     play_sound_if_no_flag(m, SOUND_ACTION_THROW, MARIO_ACTION_SOUND_PLAYED);
+ 
++    if (m->input & INPUT_B_PRESSED) {
++        return set_mario_action(m, ACT_GROUND_POUND_DIVE, 0);
++    }
++
+     if (m->actionState == 0) {
+         if (m->actionTimer < 10) {
+             yOffset = 20 - 2 * m->actionTimer;
+@@ -1238,6 +1283,10 @@ s32 act_thrown_forward(struct MarioState *m) {
+ }
+ 
+ s32 act_soft_bonk(struct MarioState *m) {
++    if (!m->actionArg) {
++        m->faceAngle[1] += 0x8000;
++        return set_mario_action(m, ACT_WALL_KICK_SLIDE, 0);
++    }
+     if (check_wall_kick(m)) {
+         return 1;
+     }
+@@ -1333,7 +1382,7 @@ s32 act_air_hit_wall(struct MarioState *m) {
+ #ifdef AVOID_UB
+     return
+ #endif
+-    set_mario_animation(m, MARIO_ANIM_START_WALLKICK);
++        set_mario_animation(m, MARIO_ANIM_START_WALLKICK);
+ 
+     //! Missing return statement. The returned value is the result of the call
+     // to set_mario_animation. In practice, this value is nonzero.
+@@ -1790,8 +1839,7 @@ s32 act_flying(struct MarioState *m) {
+                     m->vel[1] = 0.0f;
+                 }
+ 
+-                play_sound((m->flags & MARIO_METAL_CAP) ? SOUND_ACTION_METAL_BONK
+-                                                        : SOUND_ACTION_BONK,
++                play_sound((m->flags & MARIO_METAL_CAP) ? SOUND_ACTION_METAL_BONK : SOUND_ACTION_BONK,
+                            m->marioObj->header.gfx.cameraToObject);
+ 
+                 m->particleFlags |= PARTICLE_VERTICAL_STAR;
+@@ -2054,7 +2102,72 @@ s32 check_common_airborne_cancels(struct MarioState *m) {
+     return FALSE;
+ }
+ 
++s32 act_wall_kick_slide(struct MarioState *m) {
++    s16 min, max;
++    f32 dividend;
++    mario_set_forward_vel(m, 0.0f);
++    if ((!m->actionTimer && !m->wallKickTimer && m->prevAction != ACT_BACKFLIP) || !m->wall) {
++        m->faceAngle[1] += 0x8000;
++        return set_mario_action(m, ACT_SOFT_BONK, 1);
++    }
++    if (m->input & INPUT_A_PRESSED) {
++        play_sound(SOUND_ACTION_BONK, m->marioObj->header.gfx.cameraToObject);
++        return set_mario_action(m, ACT_WALL_KICK_AIR, 0);
++    }
++    switch (m->wall->type) {
++        case SURFACE_NOT_SLIPPERY:
++        case SURFACE_HARD_NOT_SLIPPERY:
++        case SURFACE_SWITCH:
++            min = 5;
++            dividend = 2.0f;
++            max = 25;
++            break;
++
++        case SURFACE_SLIPPERY:
++        case SURFACE_NOISE_SLIPPERY:
++        case SURFACE_HARD_SLIPPERY:
++        case SURFACE_NO_CAM_COL_SLIPPERY:
++            min = 7;
++            dividend = 1.5f;
++            max = 30;
++            break;
++
++        case SURFACE_VERY_SLIPPERY:
++        case SURFACE_ICE:
++        case SURFACE_HARD_VERY_SLIPPERY:
++        case SURFACE_NOISE_VERY_SLIPPERY_73:
++        case SURFACE_NOISE_VERY_SLIPPERY_74:
++        case SURFACE_NOISE_VERY_SLIPPERY:
++        case SURFACE_NO_CAM_COL_VERY_SLIPPERY:
++            min = 7;
++            dividend = 0.75f;
++            max = 50;
++            break;
++        default:
++            if ((m->area->terrainType & TERRAIN_MASK) == TERRAIN_SLIDE) {
++                min = 7;
++                dividend = 0.75f;
++                max = 50;
++            } else {
++                min = 5;
++                dividend = 2.0f;
++                max = 25;
++            }
++    }
++    /*if (m->actionTimer == 0 && m->vel[1] < -min) {
++        m->actionTimer = (s16)((s16)m->vel[1] * dividend);      
++    }//*/
++    m->vel[1] = MAX(-((f32) min + m->actionTimer++ / dividend), -(f32) max);
++    if (!(m->actionTimer % 3))
++        m->particleFlags |= PARTICLE_DUST;
++    play_sound(SOUND_ENV_SLIDING, m->marioObj->header.gfx.cameraToObject);
++    set_anim_to_frame(m, 0);
++    m->input &= ~INPUT_NONZERO_ANALOG;
++    common_air_action_step(m, ACT_FREEFALL_LAND, MARIO_ANIM_START_WALLKICK, 0);
++}
++
+ s32 mario_execute_airborne_action(struct MarioState *m) {
++    f32 rotate = 0.0f;
+     u32 cancel;
+ 
+     if (check_common_airborne_cancels(m)) {
+@@ -2066,6 +2179,7 @@ s32 mario_execute_airborne_action(struct MarioState *m) {
+     /* clang-format off */
+     switch (m->action) {
+         case ACT_JUMP:                 cancel = act_jump(m);                 break;
++        case ACT_GROUND_POUND_JUMP:
+         case ACT_DOUBLE_JUMP:          cancel = act_double_jump(m);          break;
+         case ACT_FREEFALL:             cancel = act_freefall(m);             break;
+         case ACT_HOLD_JUMP:            cancel = act_hold_jump(m);            break;
+@@ -2083,6 +2197,7 @@ s32 mario_execute_airborne_action(struct MarioState *m) {
+         case ACT_LONG_JUMP:            cancel = act_long_jump(m);            break;
+         case ACT_RIDING_SHELL_JUMP:
+         case ACT_RIDING_SHELL_FALL:    cancel = act_riding_shell_air(m);     break;
++        case ACT_GROUND_POUND_DIVE:
+         case ACT_DIVE:                 cancel = act_dive(m);                 break;
+         case ACT_AIR_THROW:            cancel = act_air_throw(m);            break;
+         case ACT_BACKWARD_AIR_KB:      cancel = act_backward_air_kb(m);      break;
+@@ -2110,8 +2225,39 @@ s32 mario_execute_airborne_action(struct MarioState *m) {
+         case ACT_RIDING_HOOT:          cancel = act_riding_hoot(m);          break;
+         case ACT_TOP_OF_POLE_JUMP:     cancel = act_top_of_pole_jump(m);     break;
+         case ACT_VERTICAL_WIND:        cancel = act_vertical_wind(m);        break;
++        case ACT_WALL_KICK_SLIDE:      cancel = act_wall_kick_slide(m);      break;
++    }
++
++    switch (m->action) {
++        case ACT_DIVE:
++        case ACT_GROUND_POUND_DIVE:
++        case ACT_STEEP_JUMP:
++        case ACT_RIDING_SHELL_FALL:
++        case ACT_SLIDE_KICK:
++        case ACT_WATER_JUMP:         rotate = 384.0f; break;
++        case ACT_AIR_THROW:
++        case ACT_FORWARD_ROLLOUT:
++        case ACT_BACKWARD_ROLLOUT:
++        case ACT_RIDING_SHELL_JUMP:  rotate = 640.0f; break;
++        case ACT_LONG_JUMP:
++            rotate = MAX(2048.f - 30.0f * m->forwardVel, 896.0f);
++            break;
++        case ACT_JUMP:
++        case ACT_DOUBLE_JUMP: case ACT_GROUND_POUND_JUMP:
++        case ACT_TRIPLE_JUMP: case ACT_SPECIAL_TRIPLE_JUMP:
++        case ACT_FREEFALL:
++            rotate = MAX(4192.0f - 120.0f * m->forwardVel,
++                         (m->action == ACT_JUMP || m->action == ACT_FREEFALL) ? 640.0f : 384.0f);
++            if (m->faceAngle[1] <= m->intendedYaw + 0x7000 && m->faceAngle[1] >= m->intendedYaw + 0x9000) {
++                m->intendedYaw += 20;
++                rotate = 4192.0f;
++            }
+     }
+     /* clang-format on */
+ 
++    if (m->input & INPUT_NONZERO_ANALOG) {
++        m->faceAngle[1] += sins(m->intendedYaw - m->faceAngle[1]) * m->intendedMag / 32.0f * rotate;
++    }
++
+     return cancel;
+ }
+diff --git a/src/game/mario_actions_automatic.c b/src/game/mario_actions_automatic.c
+index d2a3649..71b0a0d 100644
+--- a/src/game/mario_actions_automatic.c
++++ b/src/game/mario_actions_automatic.c
+@@ -547,20 +547,12 @@ s32 act_ledge_grab(struct MarioState *m) {
+     s16 intendedDYaw = m->intendedYaw - m->faceAngle[1];
+     s32 hasSpaceForMario = (m->ceilHeight - m->floorHeight >= 160.0f);
+ 
+-    if (m->actionTimer < 10) {
+-        m->actionTimer++;
+-    }
+-
+-    if (m->floor->normal.y < 0.9063078f) {
+-        return let_go_of_ledge(m);
+-    }
+-
+-    if (m->input & (INPUT_Z_PRESSED | INPUT_OFF_FLOOR)) {
++    if (m->input & (INPUT_Z_PRESSED | INPUT_OFF_FLOOR) || m->floor->normal.y < 0.9063078f) {
+         return let_go_of_ledge(m);
+     }
+ 
+-    if ((m->input & INPUT_A_PRESSED) && hasSpaceForMario) {
+-        return set_mario_action(m, ACT_LEDGE_CLIMB_FAST, 0);
++    if ((m->input & (INPUT_A_PRESSED | INPUT_B_PRESSED)) && hasSpaceForMario) {
++        return set_mario_action(m, ACT_LEDGE_CLIMB_FAST, m->input & INPUT_A_PRESSED);
+     }
+ 
+     if (m->input & INPUT_UNKNOWN_10) {
+@@ -571,15 +563,19 @@ s32 act_ledge_grab(struct MarioState *m) {
+     }
+ #ifdef VERSION_EU
+     // On PAL, you can't slow climb up ledges while holding A.
+-    if (m->actionTimer == 10 && (m->input & INPUT_NONZERO_ANALOG) && !(m->input & INPUT_A_DOWN))
++    if (m->actionTimer++ >= 10 && (m->input & INPUT_NONZERO_ANALOG) && !(m->input & INPUT_A_DOWN))
+ #else
+-    if (m->actionTimer == 10 && (m->input & INPUT_NONZERO_ANALOG))
++    if (m->actionTimer++ >= 10 && (m->input & INPUT_NONZERO_ANALOG))
+ #endif
+     {
+         if (intendedDYaw >= -0x4000 && intendedDYaw <= 0x4000) {
+             if (hasSpaceForMario) {
+                 return set_mario_action(m, ACT_LEDGE_CLIMB_SLOW_1, 0);
+             }
++        } else if (intendedDYaw >= -0x6000 && intendedDYaw <= 0x6000 && false) { //get back to this later
++            if (hasSpaceForMario) {
++                return set_mario_action(m, ACT_LEDGE_MOVE, intendedDYaw <= 0);
++            }
+         } else {
+             return let_go_of_ledge(m);
+         }
+@@ -600,6 +596,33 @@ s32 act_ledge_grab(struct MarioState *m) {
+     return FALSE;
+ }
+ 
++s32 act_ledge_move(struct MarioState *m) {
++    f32 heightAboveFloor;
++    s16 angle = m->marioObj->header.gfx.angle[1];
++    s16 intendedDYaw = m->intendedYaw - angle;
++    s32 hasSpaceForMario = (m->ceilHeight - m->floorHeight >= 160.0f);
++    if (m->input & (INPUT_Z_PRESSED | INPUT_OFF_FLOOR) || m->floor->normal.y < 0.9063078f) {
++        return let_go_of_ledge(m);
++    }
++    if ((m->input & (INPUT_A_PRESSED | INPUT_B_PRESSED)) && hasSpaceForMario) {
++        return set_mario_action(m, ACT_LEDGE_CLIMB_FAST, m->input & INPUT_A_PRESSED);
++    }
++    m->pos[0] += coss(angle) * (8 - m->actionTimer) * (m->actionArg ? -1 : 1);
++    m->pos[2] += sins(angle) * (8 - m->actionTimer) * (m->actionArg ? -1 : 1);
++    m->actionTimer++;
++    //stop_and_set_height_to_floor(m);
++    set_mario_anim_with_accel(m, MARIO_ANIM_SLOW_LEDGE_GRAB, 0xA000); //fixed point math
++    if (m->actionTimer == 2) {
++        //play_sound_if_no_flag(m, SOUND_MARIO_EEUH, MARIO_MARIO_SOUND_PLAYED);
++    }
++    if (m->actionTimer >= 6) {
++        set_mario_animation(m, MARIO_ANIM_IDLE_ON_LEDGE);
++        return set_mario_action(m, ACT_LEDGE_GRAB, 1);
++    }
++    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
++    return false;
++}
++
+ s32 act_ledge_climb_slow(struct MarioState *m) {
+     if (m->input & INPUT_OFF_FLOOR) {
+         return let_go_of_ledge(m);
+@@ -647,7 +670,12 @@ s32 act_ledge_climb_fast(struct MarioState *m) {
+     play_sound_if_no_flag(m, SOUND_MARIO_UH2, MARIO_MARIO_SOUND_PLAYED);
+ 
+     update_ledge_climb(m, MARIO_ANIM_FAST_LEDGE_GRAB, ACT_IDLE);
+-
++    if (is_anim_past_frame(m, 6) && m->actionArg) {
++        m->pos[0] += 14.0f * sins(m->faceAngle[1]);
++        m->pos[2] += 14.0f * coss(m->faceAngle[1]);
++        vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
++        return set_mario_action(m, ACT_DOUBLE_JUMP, 0);
++    }
+     if (m->marioObj->header.gfx.unk38.animFrame == 8) {
+         play_mario_landing_sound(m, SOUND_ACTION_TERRAIN_LANDING);
+     }
+@@ -880,6 +908,7 @@ s32 mario_execute_automatic_action(struct MarioState *m) {
+         case ACT_LEDGE_CLIMB_SLOW_2:     cancel = act_ledge_climb_slow(m);       break;
+         case ACT_LEDGE_CLIMB_DOWN:       cancel = act_ledge_climb_down(m);       break;
+         case ACT_LEDGE_CLIMB_FAST:       cancel = act_ledge_climb_fast(m);       break;
++        case ACT_LEDGE_MOVE:             cancel = act_ledge_move(m);             break;
+         case ACT_GRABBED:                cancel = act_grabbed(m);                break;
+         case ACT_IN_CANNON:              cancel = act_in_cannon(m);              break;
+         case ACT_TORNADO_TWIRLING:       cancel = act_tornado_twirling(m);       break;
+diff --git a/src/game/mario_actions_moving.c b/src/game/mario_actions_moving.c
+index 57290d2..9a35852 100644
+--- a/src/game/mario_actions_moving.c
++++ b/src/game/mario_actions_moving.c
+@@ -36,11 +36,23 @@ struct LandingAction sSideFlipLandAction = {
+ };
+ 
+ struct LandingAction sHoldJumpLandAction = {
+-    4, 5, ACT_HOLD_FREEFALL, ACT_HOLD_JUMP_LAND_STOP, ACT_HOLD_JUMP, ACT_HOLD_FREEFALL, ACT_HOLD_BEGIN_SLIDING,
++    4,
++    5,
++    ACT_HOLD_FREEFALL,
++    ACT_HOLD_JUMP_LAND_STOP,
++    ACT_HOLD_JUMP,
++    ACT_HOLD_FREEFALL,
++    ACT_HOLD_BEGIN_SLIDING,
+ };
+ 
+ struct LandingAction sHoldFreefallLandAction = {
+-    4, 5, ACT_HOLD_FREEFALL, ACT_HOLD_FREEFALL_LAND_STOP, ACT_HOLD_JUMP, ACT_HOLD_FREEFALL, ACT_HOLD_BEGIN_SLIDING,
++    4,
++    5,
++    ACT_HOLD_FREEFALL,
++    ACT_HOLD_FREEFALL_LAND_STOP,
++    ACT_HOLD_JUMP,
++    ACT_HOLD_FREEFALL,
++    ACT_HOLD_BEGIN_SLIDING,
+ };
+ 
+ struct LandingAction sLongJumpLandAction = {
+@@ -699,7 +711,8 @@ void push_or_sidle_wall(struct MarioState *m, Vec3f startPos) {
+         }
+ 
+         if (m->marioObj->header.gfx.unk38.animFrame < 20) {
+-            play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
++            play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend,
++                       m->marioObj->header.gfx.cameraToObject);
+             m->particleFlags |= PARTICLE_DUST;
+         }
+ 
+@@ -986,7 +999,8 @@ s32 act_turning_around(struct MarioState *m) {
+         return begin_walking_action(m, 8.0f, ACT_FINISH_TURNING_AROUND, 0);
+     }
+ 
+-    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
++    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend,
++               m->marioObj->header.gfx.cameraToObject);
+ 
+     adjust_sound_for_speed(m);
+ 
+@@ -1069,7 +1083,8 @@ s32 act_braking(struct MarioState *m) {
+             break;
+     }
+ 
+-    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
++    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend,
++               m->marioObj->header.gfx.cameraToObject);
+     adjust_sound_for_speed(m);
+     set_mario_animation(m, MARIO_ANIM_SKID_ON_GROUND);
+     return FALSE;
+@@ -1121,7 +1136,8 @@ s32 act_decelerating(struct MarioState *m) {
+ 
+     if (slopeClass == SURFACE_CLASS_VERY_SLIPPERY) {
+         set_mario_animation(m, MARIO_ANIM_IDLE_HEAD_LEFT);
+-        play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
++        play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend,
++                   m->marioObj->header.gfx.cameraToObject);
+         adjust_sound_for_speed(m);
+         m->particleFlags |= PARTICLE_DUST;
+     } else {
+@@ -1187,7 +1203,8 @@ s32 act_hold_decelerating(struct MarioState *m) {
+ 
+     if (slopeClass == SURFACE_CLASS_VERY_SLIPPERY) {
+         set_mario_animation(m, MARIO_ANIM_IDLE_WITH_LIGHT_OBJ);
+-        play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
++        play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend,
++                   m->marioObj->header.gfx.cameraToObject);
+         adjust_sound_for_speed(m);
+         m->particleFlags |= PARTICLE_DUST;
+     } else {
+@@ -1277,7 +1294,7 @@ s32 act_crawling(struct MarioState *m) {
+         return set_mario_action(m, ACT_STOP_CRAWLING, 0);
+     }
+ 
+-    m->intendedMag *= 0.1f;
++    m->intendedMag *= 0.2f;
+ 
+     update_walking_speed(m);
+ 
+@@ -1296,8 +1313,8 @@ s32 act_crawling(struct MarioState *m) {
+             align_with_floor(m);
+             break;
+     }
+-
+-    val04 = (s32)(m->intendedMag * 2.0f * 0x10000);
++    // m->intendedMag *= 0.4f; //0.25 -> 0.1
++    val04 = (s32)(m->intendedMag * 0x10000);
+     set_mario_anim_with_accel(m, MARIO_ANIM_CRAWLING, val04);
+     play_step_sound(m, 26, 79);
+     return FALSE;
+@@ -1359,14 +1376,16 @@ s32 act_burning_ground(struct MarioState *m) {
+ void tilt_body_butt_slide(struct MarioState *m) {
+     s16 intendedDYaw = m->intendedYaw - m->faceAngle[1];
+     m->marioBodyState->torsoAngle[0] = (s32)(5461.3335f * m->intendedMag / 32.0f * coss(intendedDYaw));
+-    m->marioBodyState->torsoAngle[2] = (s32)(-(5461.3335f * m->intendedMag / 32.0f * sins(intendedDYaw)));
++    m->marioBodyState->torsoAngle[2] =
++        (s32)(-(5461.3335f * m->intendedMag / 32.0f * sins(intendedDYaw)));
+ }
+ 
+ void common_slide_action(struct MarioState *m, u32 endAction, u32 airAction, s32 animation) {
+     Vec3f val14;
+ 
+     vec3f_copy(val14, m->pos);
+-    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
++    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend,
++               m->marioObj->header.gfx.cameraToObject);
+ 
+ #ifdef VERSION_SH
+     reset_rumble_timers();
+@@ -1449,7 +1468,8 @@ s32 act_hold_butt_slide(struct MarioState *m) {
+         return drop_and_set_mario_action(m, ACT_BUTT_SLIDE, 0);
+     }
+ 
+-    cancel = common_slide_action_with_jump(m, ACT_HOLD_BUTT_SLIDE_STOP, ACT_HOLD_JUMP, ACT_HOLD_BUTT_SLIDE_AIR,
++    cancel = common_slide_action_with_jump(m, ACT_HOLD_BUTT_SLIDE_STOP, ACT_HOLD_JUMP,
++                                           ACT_HOLD_BUTT_SLIDE_AIR,
+                                            MARIO_ANIM_SLIDING_ON_BOTTOM_WITH_LIGHT_OBJ);
+     tilt_body_butt_slide(m);
+     return cancel;
+@@ -1518,7 +1538,8 @@ s32 act_slide_kick_slide(struct MarioState *m) {
+             break;
+     }
+ 
+-    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
++    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend,
++               m->marioObj->header.gfx.cameraToObject);
+     m->particleFlags |= PARTICLE_DUST;
+     return FALSE;
+ }
+@@ -1545,13 +1566,27 @@ s32 stomach_slide_action(struct MarioState *m, u32 stopAction, u32 airAction, s3
+ }
+ 
+ s32 act_stomach_slide(struct MarioState *m) {
+-    s32 cancel = stomach_slide_action(m, ACT_STOMACH_SLIDE_STOP, ACT_FREEFALL, MARIO_ANIM_SLIDE_DIVE);
++    s32 cancel;
++    if (m->input & (INPUT_A_PRESSED | INPUT_B_PRESSED) && m->forwardVel < -3.0f) {
++#ifdef VERSION_SH
++        queue_rumble_data(5, 80);
++#endif
++        return set_mario_action(m, ACT_FORWARD_ROLLOUT, 0);
++    }
++    cancel = stomach_slide_action(m, ACT_STOMACH_SLIDE_STOP, ACT_FREEFALL, MARIO_ANIM_SLIDE_DIVE);
+     return cancel;
+ }
+ 
+ s32 act_hold_stomach_slide(struct MarioState *m) {
+     s32 cancel;
+ 
++    if (m->input & (INPUT_A_PRESSED | INPUT_B_PRESSED) && m->forwardVel < -3.0f) {
++#ifdef VERSION_SH
++        queue_rumble_data(5, 80);
++#endif
++        return set_mario_action(m, ACT_FORWARD_ROLLOUT, 0);
++    }
++
+     if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
+         return drop_and_set_mario_action(m, ACT_STOMACH_SLIDE, 0);
+     }
+@@ -1561,7 +1596,7 @@ s32 act_hold_stomach_slide(struct MarioState *m) {
+ }
+ 
+ s32 act_dive_slide(struct MarioState *m) {
+-    if (!(m->input & INPUT_ABOVE_SLIDE) && (m->input & (INPUT_A_PRESSED | INPUT_B_PRESSED))) {
++    if (m->input & (INPUT_A_PRESSED | INPUT_B_PRESSED)) {
+ #ifdef VERSION_SH
+         queue_rumble_data(5, 80);
+ #endif
+@@ -1779,7 +1814,7 @@ s32 common_landing_cancels(struct MarioState *m, struct LandingAction *landingAc
+     }
+ 
+     if (++m->actionTimer >= landingAction->numFrames) {
+-        return set_mario_action(m, landingAction->endAction, 0);
++        return set_mario_action(m, landingAction->endAction, (m->prevAction == ACT_TWIRLING));
+     }
+ 
+     if (m->input & INPUT_A_PRESSED) {
+@@ -1884,6 +1919,10 @@ s32 act_double_jump_land(struct MarioState *m) {
+ }
+ 
+ s32 act_triple_jump_land(struct MarioState *m) {
++
++    if ((m->input & INPUT_A_PRESSED) && m->prevAction == ACT_TWIRLING) {
++        return set_mario_action(m, ACT_GROUND_POUND_JUMP, 0);
++    }
+     m->input &= ~INPUT_A_PRESSED;
+ 
+     if (common_landing_cancels(m, &sTripleJumpLandAction, set_jumping_action)) {
+@@ -1949,8 +1988,8 @@ s32 act_quicksand_jump_land(struct MarioState *m) {
+ 
+ s32 act_hold_quicksand_jump_land(struct MarioState *m) {
+     s32 cancel = quicksand_jump_land_action(m, MARIO_ANIM_JUMP_WITH_LIGHT_OBJ,
+-                                            MARIO_ANIM_JUMP_LAND_WITH_LIGHT_OBJ, ACT_HOLD_JUMP_LAND_STOP,
+-                                            ACT_HOLD_FREEFALL);
++                                            MARIO_ANIM_JUMP_LAND_WITH_LIGHT_OBJ,
++                                            ACT_HOLD_JUMP_LAND_STOP, ACT_HOLD_FREEFALL);
+     return cancel;
+ }
+ 
+diff --git a/src/game/mario_actions_stationary.c b/src/game/mario_actions_stationary.c
+index 33d2919..fa273df 100644
+--- a/src/game/mario_actions_stationary.c
++++ b/src/game/mario_actions_stationary.c
+@@ -650,6 +650,10 @@ s32 act_butt_slide_stop(struct MarioState *m) {
+         return set_mario_action(m, ACT_SHOCKWAVE_BOUNCE, 0);
+     }
+ 
++    if (m->prevAction == ACT_GROUND_POUND_LAND && m->input & INPUT_NONZERO_ANALOG) {
++        m->faceAngle[1] = m->intendedYaw;
++    } 
++
+     if (m->input & (INPUT_NONZERO_ANALOG | INPUT_A_PRESSED | INPUT_OFF_FLOOR | INPUT_ABOVE_SLIDE)) {
+         return check_common_action_exits(m);
+     }
+@@ -908,6 +912,10 @@ s32 act_freefall_land_stop(struct MarioState *m) {
+ }
+ 
+ s32 act_triple_jump_land_stop(struct MarioState *m) {
++    if ((m->input & INPUT_A_PRESSED) && m->actionArg == 1) {
++        return set_mario_action(m, ACT_GROUND_POUND_JUMP, 0);
++    }
++
+     if (check_common_landing_cancels(m, ACT_JUMP)) {
+         return 1;
+     }
+@@ -947,9 +955,9 @@ s32 act_long_jump_land_stop(struct MarioState *m) {
+     }
+ 
+     landing_step(m,
+-                  !m->marioObj->oMarioLongJumpIsSlow ? MARIO_ANIM_CROUCH_FROM_FAST_LONGJUMP
+-                                                     : MARIO_ANIM_CROUCH_FROM_SLOW_LONGJUMP,
+-                  ACT_CROUCHING);
++                 !m->marioObj->oMarioLongJumpIsSlow ? MARIO_ANIM_CROUCH_FROM_FAST_LONGJUMP
++                                                    : MARIO_ANIM_CROUCH_FROM_SLOW_LONGJUMP,
++                 ACT_CROUCHING);
+     return 0;
+ }
+ 
+@@ -1045,6 +1053,10 @@ s32 act_twirl_land(struct MarioState *m) {
+ 
+ s32 act_ground_pound_land(struct MarioState *m) {
+     m->actionState = 1;
++    if (m->input & INPUT_A_PRESSED) {
++        return set_mario_action(m, ACT_GROUND_POUND_JUMP, 0);
++    }
++
+     if (m->input & INPUT_UNKNOWN_10) {
+         return drop_and_set_mario_action(m, ACT_SHOCKWAVE_BOUNCE, 0);
+     }
+diff --git a/tools/create_patch_from_master.sh b/tools/create_patch_from_master.sh
+new file mode 100644
+index 0000000..06d8998
+--- /dev/null
++++ b/tools/create_patch_from_master.sh
+@@ -0,0 +1,25 @@
++#!/bin/sh
++#
++# create_patch.sh - Creates an enhancement patch based on the current Git changes
++#
++
++if [ "$#" -ne 1 ]
++then
++    echo "Usage: $0 patch_file"
++    echo '    Creates a patch file based on the changes made to the current directory'
++    exit 1
++fi
++
++# Make sure this is a git repository
++if [ ! -d .git ]
++then
++    echo 'Error: The current directory is not a Git repository.'
++    exit 1
++fi
++
++# 'git diff' is stupid and doesn't show new untracked files, so we must add them first.
++git add .
++# Generate the patch.
++git diff -p --staged 9a40d86f6a5d925c4dc62d1cc0b5c345400e8eff > "$1"
++# Undo the 'git add'. 
++git reset
diff --git a/include/types.h b/include/types.h
index 483c894..b391e4f 100644
--- a/include/types.h
+++ b/include/types.h
@@ -7,6 +7,9 @@
 #include <ultra64.h>
 #include "macros.h"
 
+//typedef int bool;
+#define true 1
+#define false 0 
 
 // Certain functions are marked as having return values, but do not
 // actually return a value. This causes undefined behavior, which we'd rather
diff --git a/lib/asm/__osExceptionPreamble.s b/lib/asm/__osExceptionPreamble.s
index c98608b..3f9804f 100644
--- a/lib/asm/__osExceptionPreamble.s
+++ b/lib/asm/__osExceptionPreamble.s
@@ -15,12 +15,11 @@
 .endif
 
 glabel __osExceptionPreamble
-    lui   $k0, %hi(__osException) # $k0, 0x8032
-    addiu $k0, %lo(__osException) # addiu $k0, $k0, 0x66d0
+    lui   $k0, %hi(__crash_handler_entry) # $k0, 0x8032
+    addiu $k0, %lo(__crash_handler_entry) # addiu $k0, $k0, 0x66d0
     jr    $k0
      nop
 
-
 glabel __osException
 .ifndef VERSION_EU
     lui   $k0, %hi(gInterruptedThread) # $k0, 0x8036
diff --git a/lib/asm/__osExceptionPreamble.s.orig b/lib/asm/__osExceptionPreamble.s.orig
new file mode 100644
index 0000000..c98608b
--- /dev/null
+++ b/lib/asm/__osExceptionPreamble.s.orig
@@ -0,0 +1,1123 @@
+.set noat      # allow manual use of $at
+.set noreorder # don't insert nops after branches
+.set gp=64
+
+.include "macros.inc"
+
+.ifdef VERSION_SH
+.set VERSION_EU, 1 # HACK, someone fix this file, its poorly diff'd!
+.endif
+
+.section .text, "ax"
+
+.ifdef AVOID_UB
+.set D_80334890, D_80334890_fix
+.endif
+
+glabel __osExceptionPreamble
+    lui   $k0, %hi(__osException) # $k0, 0x8032
+    addiu $k0, %lo(__osException) # addiu $k0, $k0, 0x66d0
+    jr    $k0
+     nop
+
+
+glabel __osException
+.ifndef VERSION_EU
+    lui   $k0, %hi(gInterruptedThread) # $k0, 0x8036
+    addiu $k0, %lo(gInterruptedThread) # addiu $k0, $k0, 0x5f40
+    sd    $at, 0x20($k0)
+    mfc0  $k1, $12
+    sw    $k1, 0x118($k0)
+    li    $at, -4
+    and   $k1, $k1, $at
+    mtc0  $k1, $12
+    sd    $t0, 0x58($k0)
+    sd    $t1, 0x60($k0)
+    sd    $t2, 0x68($k0)
+    sw    $zero, 0x18($k0)
+    mfc0  $t0, $13
+
+    andi  $t1, $t0, 0x7c
+    li    $t2, 0
+    bne   $t1, $t2, .L80326750
+     nop
+    and   $t1, $k1, $t0
+    andi  $t2, $t1, 0x4000
+    beqz  $t2, .L80326734
+     nop
+    li    $t1, 1
+    lui   $at, %hi(D_80334934) # $at, 0x8033
+    b     .L80326794
+     sw    $t1, %lo(D_80334934)($at)
+.L80326734:
+    andi  $t2, $t1, 0x2000
+    beqz  $t2, .L80326750
+     nop
+    li    $t1, 1
+    lui   $at, %hi(D_80334938) # $at, 0x8033
+    b     .L80326794
+     sw    $t1, %lo(D_80334938)($at)
+.L80326750:
+    lui   $at, %hi(D_80334934) # $at, 0x8033
+    sw    $zero, %lo(D_80334934)($at)
+    lui   $at, %hi(D_80334938) # $at, 0x8033
+
+    move  $t0, $k0
+    sw    $zero, %lo(D_80334938)($at)
+    lui   $k0, %hi(D_80334890 + 0x10) # $k0, 0x8033
+    lw    $k0, %lo(D_80334890 + 0x10)($k0)
+    ld    $t1, 0x20($t0)
+    sd    $t1, 0x20($k0)
+    ld    $t1, 0x118($t0)
+    sd    $t1, 0x118($k0)
+    ld    $t1, 0x58($t0)
+    sd    $t1, 0x58($k0)
+    ld    $t1, 0x60($t0)
+    sd    $t1, 0x60($k0)
+    ld    $t1, 0x68($t0)
+    sd    $t1, 0x68($k0)
+.L80326794:
+    mflo  $t0
+    sd    $t0, 0x108($k0)
+    mfhi  $t0
+    sd    $v0, 0x28($k0)
+    sd    $v1, 0x30($k0)
+    sd    $a0, 0x38($k0)
+    sd    $a1, 0x40($k0)
+    sd    $a2, 0x48($k0)
+    sd    $a3, 0x50($k0)
+    sd    $t3, 0x70($k0)
+    sd    $t4, 0x78($k0)
+    sd    $t5, 0x80($k0)
+    sd    $t6, 0x88($k0)
+    sd    $t7, 0x90($k0)
+    sd    $s0, 0x98($k0)
+    sd    $s1, 0xa0($k0)
+    sd    $s2, 0xa8($k0)
+    sd    $s3, 0xb0($k0)
+    sd    $s4, 0xb8($k0)
+    sd    $s5, 0xc0($k0)
+    sd    $s6, 0xc8($k0)
+    sd    $s7, 0xd0($k0)
+    sd    $t8, 0xd8($k0)
+    sd    $t9, 0xe0($k0)
+    sd    $gp, 0xe8($k0)
+    sd    $sp, 0xf0($k0)
+    sd    $fp, 0xf8($k0)
+    sd    $ra, 0x100($k0)
+.ifndef VERSION_EU
+    sd    $t0, 0x110($k0)
+.else
+    beqz $t1, .L802F3A18
+    sd    $t0, 0x110($k0)
+    lui   $t0, %hi(D_8030208C) # $t0, 0x8030
+    addiu $t0, $t0, %lo(D_8030208C) # addiu $t0, $t0, 0x208c
+    lw    $t0, ($t0)
+    li    $at, -1
+    xor   $t0, $t0, $at
+    lui   $at, (0xFFFF00FF >> 16) # lui $at, 0xffff
+    andi  $t0, $t0, 0xff00
+    ori   $at, (0xFFFF00FF & 0xFFFF) # ori $at, $at, 0xff
+    or    $t1, $t1, $t0
+    and   $k1, $k1, $at
+    or    $k1, $k1, $t1
+    sw    $k1, 0x118($k0)
+.L802F3A18:
+    lui   $t1, %hi(MI_INTR_MASK_REG) # $t1, 0xa430
+    lw    $t1, %lo(MI_INTR_MASK_REG)($t1)
+    beqz  $t1, .L802F3A50
+     nop   
+    lui   $t0, %hi(D_8030208C) # $t0, 0x8030
+    addiu $t0, $t0, %lo(D_8030208C) # addiu $t0, $t0, 0x208c
+    lw    $t0, ($t0)
+    lw    $t4, 0x128($k0)
+    li    $at, -1
+    srl   $t0, $t0, 0x10
+    xor   $t0, $t0, $at
+    andi  $t0, $t0, 0x3f
+    and   $t0, $t0, $t4
+    or    $t1, $t1, $t0
+.L802F3A50:
+    sw    $t1, 0x128($k0)
+.endif
+
+
+    mfc0  $t0, $14
+    sw    $t0, 0x11c($k0)
+    lw    $t0, 0x18($k0)
+    beqz  $t0, .L80326868
+     nop
+    cfc1  $t0, $31
+    nop
+    sw    $t0, 0x12c($k0)
+    sdc1  $f0, 0x130($k0)
+    sdc1  $f2, 0x138($k0)
+    sdc1  $f4, 0x140($k0)
+    sdc1  $f6, 0x148($k0)
+    sdc1  $f8, 0x150($k0)
+    sdc1  $f10, 0x158($k0)
+    sdc1  $f12, 0x160($k0)
+    sdc1  $f14, 0x168($k0)
+    sdc1  $f16, 0x170($k0)
+    sdc1  $f18, 0x178($k0)
+    sdc1  $f20, 0x180($k0)
+    sdc1  $f22, 0x188($k0)
+    sdc1  $f24, 0x190($k0)
+    sdc1  $f26, 0x198($k0)
+    sdc1  $f28, 0x1a0($k0)
+    sdc1  $f30, 0x1a8($k0)
+.L80326868:
+    mfc0  $t0, $13
+    sw    $t0, 0x120($k0)
+    lui   $t1, %hi(MI_INTR_MASK_REG) # $t1, 0xa430
+    lw    $t1, %lo(MI_INTR_MASK_REG)($t1)
+    sw    $t1, 0x128($k0)
+    li    $t1, 2
+    sh    $t1, 0x10($k0)
+    lui   $t1, %hi(D_80334934) # $t1, 0x8033
+    lw    $t1, %lo(D_80334934)($t1)
+    beqz  $t1, .L803268B4
+     nop
+    lui   $t2, %hi(D_C0000008) # $t2, 0xc000
+    sw    $zero, %lo(D_C0000008)($t2)
+    lui   $a0, %hi(D_C0000000)
+    addiu $t2, %lo(D_C0000008) # addiu $t2, $t2, 8
+    jal   kdebugserver
+     lw    $a0, %lo(D_C0000000)($a0)
+    b     .L80326E08
+     nop
+.L803268B4:
+    lui   $t1, %hi(D_80334938) # $t1, 0x8033
+    lw    $t1, %lo(D_80334938)($t1)
+    beqz  $t1, .L80326900
+     nop
+    lui   $t2, %hi(D_C000000C) # $t2, 0xc000
+    sw    $zero, %lo(D_C000000C)($t2)
+    lui   $t1, %hi(D_80334A40) # $t1, 0x8033
+    lw    $t1, %lo(D_80334A40)($t1)
+    addiu $t2, %lo(D_C000000C) # addiu $t2, $t2, 0xc
+    beqz  $t1, .L803268E8
+     nop
+    jal   send_mesg
+     li    $a0, 120
+.L803268E8:
+    lui   $t1, %hi(D_80334A44) # $t1, 0x8033
+    lw    $t1, %lo(D_80334A44)($t1)
+    lui   $at, %hi(D_80334A44) # $at, 0x8033
+    addi  $t1, $t1, 1
+    b     .L80326E08
+     sw    $t1, %lo(D_80334A44)($at)
+.L80326900:
+    andi  $t1, $t0, 0x7c
+    li    $t2, 36
+    beq   $t1, $t2, .L80326B84
+     nop
+    li    $t2, 44
+    beq   $t1, $t2, .L80326CCC
+     nop
+    li    $t2, 0
+    bne   $t1, $t2, .L80326BE8
+     nop
+    and   $s0, $k1, $t0
+.L8032692C:
+    andi  $t1, $s0, 0xff00
+    srl   $t2, $t1, 0xc
+    bnez  $t2, .L80326944
+     nop
+    srl   $t2, $t1, 8
+    addi  $t2, $t2, 0x10
+.L80326944:
+    lui   $at, %hi(D_80338610)
+    addu  $at, $at, $t2
+    lbu   $t2, %lo(D_80338610)($at)
+    lui   $at, %hi(jtbl_80338630)
+    addu  $at, $at, $t2
+    lw    $t2, %lo(jtbl_80338630)($at)
+    jr    $t2
+     nop
+glabel L80326964
+    mfc0  $t1, $11
+    mtc0  $t1, $11
+    jal   send_mesg
+     li    $a0, 24
+    lui   $at, (0xFFFF7FFF >> 16) # lui $at, 0xffff
+    ori   $at, (0xFFFF7FFF & 0xFFFF) # ori $at, $at, 0x7fff
+    b     .L8032692C
+     and   $s0, $s0, $at
+glabel L80326984
+    li    $t2, 4
+    lui   $at, %hi(D_80334920)
+    addu  $at, $at, $t2
+    lw    $t2, %lo(D_80334920)($at)
+    beqz  $t2, .L803269A4
+     nop
+    jalr  $t2
+    nop
+.L803269A4:
+    jal   send_mesg
+     li    $a0, 16
+    li    $at, -2049
+    b     .L8032692C
+     and   $s0, $s0, $at
+glabel L803269B8
+    lui   $s1, %hi(MI_INTR_REG) # $s1, 0xa430
+    lw    $s1, %lo(MI_INTR_REG)($s1)
+    andi  $s1, $s1, 0x3f
+    andi  $t1, $s1, 1
+    beqz  $t1, .L80326A18
+     nop
+    lui   $t4, %hi(SP_STATUS_REG) # $t4, 0xa404
+    lw    $t4, %lo(SP_STATUS_REG)($t4)
+    li    $t1, 8
+    lui   $at, %hi(SP_STATUS_REG) # $at, 0xa404
+    andi  $t4, $t4, 0x300
+    andi  $s1, $s1, 0x3e
+    beqz  $t4, .L80326A08
+     sw    $t1, %lo(SP_STATUS_REG)($at)
+    jal   send_mesg
+     li    $a0, 32
+    beqz  $s1, .L80326ADC
+     nop
+    b     .L80326A18
+     nop
+.L80326A08:
+    jal   send_mesg
+     li    $a0, 88
+    beqz  $s1, .L80326ADC
+     nop
+.L80326A18:
+    andi  $t1, $s1, 8
+    beqz  $t1, .L80326A3C
+     lui   $at, %hi(VI_CURRENT_REG) # $at, 0xa440
+    andi  $s1, $s1, 0x37
+    sw    $zero, %lo(VI_CURRENT_REG)($at)
+    jal   send_mesg
+     li    $a0, 56
+    beqz  $s1, .L80326ADC
+     nop
+.L80326A3C:
+    andi  $t1, $s1, 4
+    beqz  $t1, .L80326A68
+     nop
+    li    $t1, 1
+    lui   $at, %hi(AI_STATUS_REG) # $at, 0xa450
+    andi  $s1, $s1, 0x3b
+    sw    $t1, %lo(AI_STATUS_REG)($at)
+    jal   send_mesg
+     li    $a0, 48
+    beqz  $s1, .L80326ADC
+     nop
+.L80326A68:
+    andi  $t1, $s1, 2
+    beqz  $t1, .L80326A8C
+     lui   $at, %hi(SI_STATUS_REG) # $at, 0xa480
+    andi  $s1, $s1, 0x3d
+    sw    $zero, %lo(SI_STATUS_REG)($at)
+    jal   send_mesg
+     li    $a0, 40
+    beqz  $s1, .L80326ADC
+     nop
+.L80326A8C:
+    andi  $t1, $s1, 0x10
+    beqz  $t1, .L80326AB8
+     nop
+    li    $t1, 2
+    lui   $at, %hi(PI_STATUS_REG) # $at, 0xa460
+    andi  $s1, $s1, 0x2f
+    sw    $t1, %lo(PI_STATUS_REG)($at)
+    jal   send_mesg
+     li    $a0, 64
+    beqz  $s1, .L80326ADC
+     nop
+.L80326AB8:
+    andi  $t1, $s1, 0x20
+    beqz  $t1, .L80326ADC
+     nop
+    li    $t1, 2048
+    lui   $at, %hi(MI_MODE_REG)
+    andi  $s1, $s1, 0x1f
+    sw    $t1, %lo(MI_MODE_REG)($at)
+    jal   send_mesg
+     li    $a0, 72
+.L80326ADC:
+    li    $at, -1025
+    b     .L8032692C
+     and   $s0, $s0, $at
+glabel L80326AE8
+    lw    $k1, 0x118($k0)
+    li    $at, -4097
+    lui   $t1, %hi(D_80334808) # $t1, 0x8033
+    and   $k1, $k1, $at
+    sw    $k1, 0x118($k0)
+    addiu $t1, %lo(D_80334808) # addiu $t1, $t1, 0x4808
+    lw    $t2, ($t1)
+    beqz  $t2, .L80326B14
+     li    $at, -4097
+    b     .L80326B9C
+     and   $s0, $s0, $at
+.L80326B14:
+    li    $t2, 1
+    sw    $t2, ($t1)
+    jal   send_mesg
+     li    $a0, 112
+    lui   $t2, %hi(D_80334890 + 0x8) # $t2, 0x8033
+    lw    $t2, %lo(D_80334890 + 0x8)($t2)
+    li    $at, -4097
+    and   $s0, $s0, $at
+    lw    $k1, 0x118($t2)
+    and   $k1, $k1, $at
+    b     .L80326B9C
+     sw    $k1, 0x118($t2)
+glabel L80326B44
+    li    $at, -513
+    and   $t0, $t0, $at
+    mtc0  $t0, $13
+    jal   send_mesg
+     li    $a0, 8
+    li    $at, -513
+    b     .L8032692C
+     and   $s0, $s0, $at
+glabel L80326B64
+    li    $at, -257
+    and   $t0, $t0, $at
+    mtc0  $t0, $13
+    jal   send_mesg
+     li    $a0, 0
+    li    $at, -257
+    b     .L8032692C
+     and   $s0, $s0, $at
+.L80326B84:
+    li    $t1, 1
+    sh    $t1, 0x12($k0)
+    jal   send_mesg
+     li    $a0, 80
+    b     .L80326B9C
+     nop
+.L80326B9C:
+glabel L80326B9C
+    lui   $t2, %hi(D_80334890 + 0x8) # $t2, 0x8033
+    lw    $t2, %lo(D_80334890 + 0x8)($t2)
+    lw    $t1, 4($k0)
+    lw    $t3, 4($t2)
+    slt   $at, $t1, $t3
+    beqz  $at, .L80326BD0
+     nop
+    lui   $a0, %hi(D_80334890 + 0x8) # $a0, 0x8033
+    move  $a1, $k0
+    jal   __osEnqueueThread
+     addiu $a0, %lo(D_80334890 + 0x8) # addiu $a0, $a0, 0x4898
+    j     __osDispatchThread
+     nop
+
+.L80326BD0:
+    lui   $t1, %hi(D_80334890 + 0x8) # $t1, 0x8033
+    addiu $t1, %lo(D_80334890 + 0x8) # addiu $t1, $t1, 0x4898
+    lw    $t2, ($t1)
+    sw    $t2, ($k0)
+    j     __osDispatchThread
+     sw    $k0, ($t1)
+
+.L80326BE8:
+glabel L80326BE8
+    lui   $at, %hi(D_80334890 + 0x14) # $at, 0x8033
+    sw    $k0, %lo(D_80334890 + 0x14)($at)
+    li    $t1, 1
+    sh    $t1, 0x10($k0)
+    li    $t1, 2
+    sh    $t1, 0x12($k0)
+    mfc0  $t2, $8
+    sw    $t2, 0x124($k0)
+    jal   send_mesg
+     li    $a0, 96
+    j     __osDispatchThread
+     nop
+.else
+  lui   $k0, %hi(gInterruptedThread) # $k0, 0x8033
+  addiu $k0, %lo(gInterruptedThread) # addiu $k0, $k0, 0x6ce0
+  sd    $at, 0x20($k0)
+  mfc0  $k1, $12
+  sw    $k1, 0x118($k0)
+  li    $at, -4
+  and   $k1, $k1, $at
+  mtc0  $k1, $12
+  sd    $t0, 0x58($k0)
+  sd    $t1, 0x60($k0)
+  sd    $t2, 0x68($k0)
+  sw    $zero, 0x18($k0)
+  mfc0  $t0, $13
+  move  $t0, $k0
+  lui   $k0, %hi(D_80334890 + 0x10) # $k0, 0x8030
+  lw    $k0, %lo(D_80334890 + 0x10)($k0)
+  ld    $t1, 0x20($t0)
+  sd    $t1, 0x20($k0)
+  ld    $t1, 0x118($t0)
+  sd    $t1, 0x118($k0)
+  ld    $t1, 0x58($t0)
+  sd    $t1, 0x58($k0)
+  ld    $t1, 0x60($t0)
+  sd    $t1, 0x60($k0)
+  ld    $t1, 0x68($t0)
+  sd    $t1, 0x68($k0)
+  lw    $k1, 0x118($k0)
+  mflo  $t0
+  sd    $t0, 0x108($k0)
+  mfhi  $t0
+  andi  $t1, $k1, 0xff00
+  sd    $v0, 0x28($k0)
+  sd    $v1, 0x30($k0)
+  sd    $a0, 0x38($k0)
+  sd    $a1, 0x40($k0)
+  sd    $a2, 0x48($k0)
+  sd    $a3, 0x50($k0)
+  sd    $t3, 0x70($k0)
+  sd    $t4, 0x78($k0)
+  sd    $t5, 0x80($k0)
+  sd    $t6, 0x88($k0)
+  sd    $t7, 0x90($k0)
+  sd    $s0, 0x98($k0)
+  sd    $s1, 0xa0($k0)
+  sd    $s2, 0xa8($k0)
+  sd    $s3, 0xb0($k0)
+  sd    $s4, 0xb8($k0)
+  sd    $s5, 0xc0($k0)
+  sd    $s6, 0xc8($k0)
+  sd    $s7, 0xd0($k0)
+  sd    $t8, 0xd8($k0)
+  sd    $t9, 0xe0($k0)
+  sd    $gp, 0xe8($k0)
+  sd    $sp, 0xf0($k0)
+  sd    $fp, 0xf8($k0)
+  sd    $ra, 0x100($k0)
+  beqz  $t1, .L802F3A18
+   sd    $t0, 0x110($k0)
+  lui   $t0, %hi(D_8030208C) # $t0, 0x8030
+  addiu $t0, %lo(D_8030208C) # addiu $t0, $t0, 0x208c
+  lw    $t0, ($t0)
+  li    $at, -1
+  xor   $t0, $t0, $at
+  lui   $at, (0xFFFF00FF >> 16) # lui $at, 0xffff
+  andi  $t0, $t0, 0xff00
+  ori   $at, (0xFFFF00FF & 0xFFFF) # ori $at, $at, 0xff
+  or    $t1, $t1, $t0
+  and   $k1, $k1, $at
+  or    $k1, $k1, $t1
+  sw    $k1, 0x118($k0)
+.L802F3A18:
+  lui   $t1, %hi(MI_INTR_MASK_REG) # $t1, 0xa430
+  lw    $t1, %lo(MI_INTR_MASK_REG)($t1)
+  beqz  $t1, .L802F3A50
+   nop   
+  lui   $t0, %hi(D_8030208C) # $t0, 0x8030
+  addiu $t0, %lo(D_8030208C) # addiu $t0, $t0, 0x208c
+  lw    $t0, ($t0)
+  lw    $t4, 0x128($k0)
+  li    $at, -1
+  srl   $t0, $t0, 0x10
+  xor   $t0, $t0, $at
+  andi  $t0, $t0, 0x3f
+  and   $t0, $t0, $t4
+  or    $t1, $t1, $t0
+.L802F3A50:
+  sw    $t1, 0x128($k0)
+  mfc0  $t0, $14
+  sw    $t0, 0x11c($k0)
+  lw    $t0, 0x18($k0)
+  beqz  $t0, .L802F3AB4
+   nop   
+  cfc1  $t0, $31
+  nop   
+  sw    $t0, 0x12c($k0)
+  sdc1  $f0, 0x130($k0)
+  sdc1  $f2, 0x138($k0)
+  sdc1  $f4, 0x140($k0)
+  sdc1  $f6, 0x148($k0)
+  sdc1  $f8, 0x150($k0)
+  sdc1  $f10, 0x158($k0)
+  sdc1  $f12, 0x160($k0)
+  sdc1  $f14, 0x168($k0)
+  sdc1  $f16, 0x170($k0)
+  sdc1  $f18, 0x178($k0)
+  sdc1  $f20, 0x180($k0)
+  sdc1  $f22, 0x188($k0)
+  sdc1  $f24, 0x190($k0)
+  sdc1  $f26, 0x198($k0)
+  sdc1  $f28, 0x1a0($k0)
+  sdc1  $f30, 0x1a8($k0)
+.L802F3AB4:
+  mfc0  $t0, $13
+  sw    $t0, 0x120($k0)
+  li    $t1, 2
+  sh    $t1, 0x10($k0)
+  andi  $t1, $t0, 0x7c
+  li    $t2, 36
+  beq   $t1, $t2, .L802F3D90
+   nop   
+  li    $t2, 44
+  beq   $t1, $t2, .L80326CCC
+   nop   
+  li    $t2, 0
+  bne   $t1, $t2, .L80326BE8
+   nop   
+  and   $s0, $k1, $t0
+.L802F3AF0:
+  andi  $t1, $s0, 0xff00
+  srl   $t2, $t1, 0xc
+  bnez  $t2, .L802F3B08
+   nop   
+  srl   $t2, $t1, 8
+  addi  $t2, $t2, 0x10
+.L802F3B08:
+  lui   $at, %hi(D_80338610)
+  addu  $at, $at, $t2
+  lbu   $t2, %lo(D_80338610)($at)
+  lui   $at, %hi(jtbl_80338630)
+  addu  $at, $at, $t2
+  lw    $t2, %lo(jtbl_80338630)($at)
+  jr    $t2
+   nop   
+  li    $at, -8193
+  b     .L802F3AF0
+   and   $s0, $s0, $at
+  li    $at, -16385
+  b     .L802F3AF0
+   and   $s0, $s0, $at
+glabel L80326964 #probably not right...
+  mfc0  $t1, $11
+  mtc0  $t1, $11
+  jal   send_mesg
+   li    $a0, 24
+  lui   $at, (0xFFFF7FFF >> 16) # lui $at, 0xffff
+  ori   $at, (0xFFFF7FFF & 0xFFFF) # ori $at, $at, 0x7fff
+  b     .L802F3AF0
+   and   $s0, $s0, $at
+glabel L80326984 #possibly wrong 
+  li    $at, -2049
+  and   $s0, $s0, $at
+  li    $t2, 4
+  lui   $at, %hi(D_80334920)
+  addu  $at, $at, $t2
+  lw    $t2, %lo(D_80334920)($at)
+  lui   $sp, %hi(D_80365E40) # $sp, 0x8033 #.bss stack for D_802F4380
+  addiu $sp, %lo(D_80365E40) # addiu $sp, $sp, 0x5c20
+  li    $a0, 16
+  beqz  $t2, .L802F3BA4
+   addiu $sp, $sp, 0xff0
+  jalr  $t2
+  nop   
+  beqz  $v0, .L802F3BA4
+   nop   
+  b     .L802F3DA8
+   nop   
+.L802F3BA4:
+  jal   send_mesg
+   nop   
+  b     .L802F3AF0
+   nop   
+glabel L803269B8
+  lui   $t0, %hi(D_8030208C) # $t0, 0x8030
+  addiu $t0, %lo(D_8030208C) # addiu $t0, $t0, 0x208c
+  lw    $t0, ($t0)
+  lui   $s1, %hi(MI_INTR_REG) # $s1, 0xa430
+  lw    $s1, %lo(MI_INTR_REG)($s1)
+  srl   $t0, $t0, 0x10
+  and   $s1, $s1, $t0
+  andi  $t1, $s1, 1
+  beqz  $t1, .L802F3C24
+   nop   
+  lui   $t4, %hi(SP_STATUS_REG) # $t4, 0xa404
+  lw    $t4, %lo(SP_STATUS_REG)($t4)
+  li    $t1, 8
+  lui   $at, %hi(SP_STATUS_REG) # $at, 0xa404
+  andi  $t4, $t4, 0x300
+  andi  $s1, $s1, 0x3e
+  beqz  $t4, .L802F3C14
+   sw    $t1, %lo(SP_STATUS_REG)($at)
+  jal   send_mesg
+   li    $a0, 32
+  beqz  $s1, .L802F3CE8
+   nop   
+  b     .L802F3C24
+   nop   
+.L802F3C14:
+  jal   send_mesg
+   li    $a0, 88
+  beqz  $s1, .L802F3CE8
+   nop   
+.L802F3C24:
+  andi  $t1, $s1, 8
+  beqz  $t1, .L802F3C48
+   lui   $at, %hi(VI_CURRENT_REG) # $at, 0xa440
+  andi  $s1, $s1, 0x37
+  sw    $zero, %lo(VI_CURRENT_REG)($at)
+  jal   send_mesg
+   li    $a0, 56
+  beqz  $s1, .L802F3CE8
+   nop   
+.L802F3C48:
+  andi  $t1, $s1, 4
+  beqz  $t1, .L802F3C74
+   nop   
+  li    $t1, 1
+  lui   $at, %hi(AI_STATUS_REG) # $at, 0xa450
+  andi  $s1, $s1, 0x3b
+  sw    $t1, %lo(AI_STATUS_REG)($at)
+  jal   send_mesg
+   li    $a0, 48
+  beqz  $s1, .L802F3CE8
+   nop   
+.L802F3C74:
+  andi  $t1, $s1, 2
+  beqz  $t1, .L802F3C98
+   lui   $at, %hi(SI_STATUS_REG) # $at, 0xa480
+  andi  $s1, $s1, 0x3d
+  sw    $zero, %lo(SI_STATUS_REG)($at)
+  jal   send_mesg
+   li    $a0, 40
+  beqz  $s1, .L802F3CE8
+   nop   
+.L802F3C98:
+  andi  $t1, $s1, 0x10
+  beqz  $t1, .L802F3CC4
+   nop   
+  li    $t1, 2
+  lui   $at, %hi(PI_STATUS_REG) # $at, 0xa460
+  andi  $s1, $s1, 0x2f
+  sw    $t1, %lo(PI_STATUS_REG)($at)
+  jal   send_mesg
+   li    $a0, 64
+  beqz  $s1, .L802F3CE8
+   nop   
+.L802F3CC4:
+  andi  $t1, $s1, 0x20
+  beqz  $t1, .L802F3CE8
+   nop   
+  li    $t1, 2048
+  lui   $at, 0xa430
+  andi  $s1, $s1, 0x1f
+  sw    $t1, ($at)
+  jal   send_mesg
+   li    $a0, 72
+.L802F3CE8:
+  li    $at, -1025
+  b     .L802F3AF0
+   and   $s0, $s0, $at
+glabel L80326AE8
+  lw    $k1, 0x118($k0)
+  li    $at, -4097
+  lui   $t1, %hi(D_80334808) # $t1, 0x8030
+  and   $k1, $k1, $at
+  sw    $k1, 0x118($k0)
+  addiu $t1, %lo(D_80334808) # addiu $t1, $t1, 0x2088
+  lw    $t2, ($t1)
+  beqz  $t2, .L802F3D20
+   li    $at, -4097
+  b     .L802F3DA8
+   and   $s0, $s0, $at
+.L802F3D20:
+  li    $t2, 1
+  sw    $t2, ($t1)
+  jal   send_mesg
+   li    $a0, 112
+  lui   $t2, %hi(D_80334890 + 0x8) # $t2, 0x8030
+  lw    $t2, %lo(D_80334890 + 0x8)($t2)
+  li    $at, -4097
+  and   $s0, $s0, $at
+  lw    $k1, 0x118($t2)
+  and   $k1, $k1, $at
+  b     .L802F3DA8
+   sw    $k1, 0x118($t2)
+glabel L80326B44
+  li    $at, -513
+  and   $t0, $t0, $at
+  mtc0  $t0, $13
+  jal   send_mesg
+   li    $a0, 8
+  li    $at, -513
+  b     .L802F3AF0
+   and   $s0, $s0, $at
+glabel L80326B64
+  li    $at, -257
+  and   $t0, $t0, $at
+  mtc0  $t0, $13
+  jal   send_mesg
+   li    $a0, 0
+  li    $at, -257
+  b     .L802F3AF0
+   and   $s0, $s0, $at
+.L802F3D90:
+  li    $t1, 1
+  sh    $t1, 0x12($k0)
+  jal   send_mesg
+   li    $a0, 80
+  b     .L802F3DA8
+   nop   
+.L802F3DA8:
+glabel L80326B9C
+  lui   $t2, %hi(D_80334890 + 0x8) # $t2, 0x8030
+  lw    $t2, %lo(D_80334890 + 0x8)($t2)
+  lw    $t1, 4($k0)
+  lw    $t3, 4($t2)
+  slt   $at, $t1, $t3
+  beqz  $at, .L80326BD0
+   nop   
+  lui   $a0, %hi(D_80334890 + 0x8) # $a0, 0x8030
+  move  $a1, $k0
+  jal   __osEnqueueThread
+   addiu $a0, %lo(D_80334890 + 0x8) # addiu $a0, $a0, 0x2ef8
+  j     __osDispatchThread
+   nop   
+
+.L80326BD0:
+  lui   $t1, %hi(D_80334890 + 0x8) # $t1, 0x8030
+  addiu $t1, %lo(D_80334890 + 0x8) # addiu $t1, $t1, 0x2ef8
+  lw    $t2, ($t1)
+  sw    $t2, ($k0)
+  j     __osDispatchThread
+   sw    $k0, ($t1)
+
+.L80326BE8:
+glabel L80326BE8
+  lui   $at, %hi(D_80334890 + 0x14) # $at, 0x8030
+  sw    $k0, %lo(D_80334890 + 0x14)($at)
+  li    $t1, 1
+  sh    $t1, 0x10($k0)
+  li    $t1, 2
+  sh    $t1, 0x12($k0)
+  mfc0  $t2, $8
+  sw    $t2, 0x124($k0)
+  jal   send_mesg
+   li    $a0, 96
+  j     __osDispatchThread
+   nop   
+.endif
+
+glabel send_mesg
+    lui   $t2, %hi(D_80363830) # $t2, 0x8036
+    addiu $t2, %lo(D_80363830) # addiu $t2, $t2, 0x3830
+    addu  $t2, $t2, $a0
+    lw    $t1, ($t2)
+    move  $s2, $ra
+    beqz  $t1, .L80326CC4
+     nop
+    lw    $t3, 8($t1)
+    lw    $t4, 0x10($t1)
+    slt   $at, $t3, $t4
+    beqz  $at, .L80326CC4
+     nop
+    lw    $t5, 0xc($t1)
+    addu  $t5, $t5, $t3
+    div   $zero, $t5, $t4
+    bnez  $t4, .L80326C60
+     nop
+    break 7
+.L80326C60:
+    li    $at, -1
+    bne   $t4, $at, .L80326C78
+     lui   $at, 0x8000
+    bne   $t5, $at, .L80326C78
+     nop
+    break 6
+.L80326C78:
+    lw    $t4, 0x14($t1)
+    mfhi  $t5
+    sll   $t5, $t5, 2
+    addu  $t4, $t4, $t5
+    lw    $t5, 4($t2)
+    addiu $t2, $t3, 1
+    sw    $t5, ($t4)
+    sw    $t2, 8($t1)
+    lw    $t2, ($t1)
+    lw    $t3, ($t2)
+    beqz  $t3, .L80326CC4
+     nop
+    jal   __osPopThread
+     move  $a0, $t1
+    move  $t2, $v0
+    lui   $a0, %hi(D_80334890 + 0x8) # $a0, 0x8033
+    move  $a1, $t2
+    jal   __osEnqueueThread
+     addiu $a0, %lo(D_80334890 + 0x8) # addiu $a0, $a0, 0x4898
+.L80326CC4:
+    jr    $s2
+     nop
+.L80326CCC:
+    lui   $at, 0x3000
+    and   $t1, $t0, $at
+    srl   $t1, $t1, 0x1c
+    li    $t2, 1
+    bne   $t1, $t2, .L80326BE8
+     nop
+    lw    $k1, 0x118($k0)
+    lui   $at, 0x2000
+    li    $t1, 1
+    or    $k1, $k1, $at
+    sw    $t1, 0x18($k0)
+    b     .L80326BD0
+     sw    $k1, 0x118($k0)
+
+
+glabel __osEnqueueAndYield
+    lui   $a1, %hi(D_80334890 + 0x10) # $a1, 0x8033
+    lw    $a1, %lo(D_80334890 + 0x10)($a1)
+    mfc0  $t0, $12
+    lw    $k1, 0x18($a1)
+    ori   $t0, $t0, 2
+    sw    $t0, 0x118($a1)
+    sd    $s0, 0x98($a1)
+    sd    $s1, 0xa0($a1)
+    sd    $s2, 0xa8($a1)
+    sd    $s3, 0xb0($a1)
+    sd    $s4, 0xb8($a1)
+    sd    $s5, 0xc0($a1)
+    sd    $s6, 0xc8($a1)
+    sd    $s7, 0xd0($a1)
+    sd    $gp, 0xe8($a1)
+    sd    $sp, 0xf0($a1)
+    sd    $fp, 0xf8($a1)
+    sd    $ra, 0x100($a1)
+.ifdef VERSION_EU
+    beqz  $k1, .L802F3F7C
+.else
+    beqz  $k1, .L80326D70
+.endif
+     sw    $ra, 0x11c($a1)
+    cfc1  $k1, $31
+    sdc1  $f20, 0x180($a1)
+    sdc1  $f22, 0x188($a1)
+    sdc1  $f24, 0x190($a1)
+    sdc1  $f26, 0x198($a1)
+    sdc1  $f28, 0x1a0($a1)
+    sdc1  $f30, 0x1a8($a1)
+    sw    $k1, 0x12c($a1)
+
+.ifdef VERSION_EU
+.L802F3F7C:
+/* 0B377C 802F3F7C 8CBB0118 */  lw    $k1, 0x118($a1)
+/* 0B3780 802F3F80 3369FF00 */  andi  $t1, $k1, 0xff00
+/* 0B3784 802F3F84 1120000D */  beqz  $t1, .L802F3FBC
+/* 0B3788 802F3F88 00000000 */   nop   
+/* 0B378C 802F3F8C 3C088030 */  lui   $t0, %hi(D_8030208C) # $t0, 0x8030
+/* 0B3790 802F3F90 2508208C */  addiu $t0, %lo(D_8030208C) # addiu $t0, $t0, 0x208c
+/* 0B3794 802F3F94 8D080000 */  lw    $t0, ($t0)
+/* 0B3798 802F3F98 2401FFFF */  li    $at, -1
+/* 0B379C 802F3F9C 01014026 */  xor   $t0, $t0, $at
+/* 0B37A0 802F3FA0 3C01FFFF */  lui   $at, (0xFFFF00FF >> 16) # lui $at, 0xffff
+/* 0B37A4 802F3FA4 3108FF00 */  andi  $t0, $t0, 0xff00
+/* 0B37A8 802F3FA8 342100FF */  ori   $at, (0xFFFF00FF & 0xFFFF) # ori $at, $at, 0xff
+/* 0B37AC 802F3FAC 01284825 */  or    $t1, $t1, $t0
+/* 0B37B0 802F3FB0 0361D824 */  and   $k1, $k1, $at
+/* 0B37B4 802F3FB4 0369D825 */  or    $k1, $k1, $t1
+/* 0B37B8 802F3FB8 ACBB0118 */  sw    $k1, 0x118($a1)
+.L802F3FBC:
+/* 0B37BC 802F3FBC 3C1BA430 */  lui   $k1, %hi(MI_INTR_MASK_REG) # $k1, 0xa430
+/* 0B37C0 802F3FC0 8F7B000C */  lw    $k1, %lo(MI_INTR_MASK_REG)($k1)
+/* 0B37C4 802F3FC4 1360000B */  beqz  $k1, .L802F3FF4
+/* 0B37C8 802F3FC8 00000000 */   nop   
+/* 0B37CC 802F3FCC 3C1A8030 */  lui   $k0, %hi(D_8030208C) # $k0, 0x8030
+/* 0B37D0 802F3FD0 275A208C */  addiu $k0, %lo(D_8030208C) # addiu $k0, $k0, 0x208c
+/* 0B37D4 802F3FD4 8F5A0000 */  lw    $k0, ($k0)
+/* 0B37D8 802F3FD8 8CA80128 */  lw    $t0, 0x128($a1)
+/* 0B37DC 802F3FDC 2401FFFF */  li    $at, -1
+/* 0B37E0 802F3FE0 001AD402 */  srl   $k0, $k0, 0x10
+/* 0B37E4 802F3FE4 0341D026 */  xor   $k0, $k0, $at
+/* 0B37E8 802F3FE8 335A003F */  andi  $k0, $k0, 0x3f
+/* 0B37EC 802F3FEC 0348D024 */  and   $k0, $k0, $t0
+/* 0B37F0 802F3FF0 037AD825 */  or    $k1, $k1, $k0
+.L802F3FF4:
+.endif
+
+
+.L80326D70:
+.ifndef VERSION_EU
+    lui   $k1, %hi(MI_INTR_MASK_REG) # $k1, 0xa430
+    lw    $k1, %lo(MI_INTR_MASK_REG)($k1)
+.endif
+    beqz  $a0, .L80326D88
+     sw    $k1, 0x128($a1)
+    jal   __osEnqueueThread
+     nop
+.L80326D88:
+    j     __osDispatchThread
+     nop
+
+
+#enqueue and pop look like compiled functions?  but there's no easy way to extract them
+glabel __osEnqueueThread
+    lw    $t8, ($a0)
+    lw    $t7, 4($a1)
+    move  $t9, $a0
+    lw    $t6, 4($t8)
+    slt   $at, $t6, $t7
+    bnez  $at, .L80326DC4
+     nop
+.L80326DAC:
+    move  $t9, $t8
+    lw    $t8, ($t8)
+    lw    $t6, 4($t8)
+    slt   $at, $t6, $t7
+    beqz  $at, .L80326DAC
+     nop
+.L80326DC4:
+    lw    $t8, ($t9)
+    sw    $t8, ($a1)
+    sw    $a1, ($t9)
+    jr    $ra
+     sw    $a0, 8($a1)
+
+glabel __osPopThread
+    lw    $v0, ($a0)
+    lw    $t9, ($v0)
+    jr    $ra
+     sw    $t9, ($a0)
+
+glabel __osDispatchThread
+    lui   $a0, %hi(D_80334890 + 0x8) # $a0, 0x8033
+    jal   __osPopThread
+     addiu $a0, %lo(D_80334890 + 0x8) # addiu $a0, $a0, 0x4898
+    lui   $at, %hi(D_80334890 + 0x10) # $at, 0x8033
+    sw    $v0, %lo(D_80334890 + 0x10)($at)
+    li    $t0, 4
+    sh    $t0, 0x10($v0)
+    move  $k0, $v0
+
+.ifdef VERSION_EU
+
+/* 0B3884 802F4084 3C088030 */  lui   $t0, %hi(D_8030208C) # $t0, 0x8030
+/* 0B3888 802F4088 8F5B0118 */  lw    $k1, 0x118($k0)
+/* 0B388C 802F408C 2508208C */  addiu $t0, %lo(D_8030208C) # addiu $t0, $t0, 0x208c
+/* 0B3890 802F4090 8D080000 */  lw    $t0, ($t0)
+/* 0B3894 802F4094 3C01FFFF */  lui   $at, (0xFFFF00FF >> 16) # lui $at, 0xffff
+/* 0B3898 802F4098 3369FF00 */  andi  $t1, $k1, 0xff00
+/* 0B389C 802F409C 342100FF */  ori   $at, (0xFFFF00FF & 0xFFFF) # ori $at, $at, 0xff
+/* 0B38A0 802F40A0 3108FF00 */  andi  $t0, $t0, 0xff00
+/* 0B38A4 802F40A4 01284824 */  and   $t1, $t1, $t0
+/* 0B38A8 802F40A8 0361D824 */  and   $k1, $k1, $at
+/* 0B38AC 802F40AC 0369D825 */  or    $k1, $k1, $t1
+/* 0B38B0 802F40B0 409B6000 */  mtc0  $k1, $12
+.endif
+.L80326E08:
+    ld    $k1, 0x108($k0)
+    ld    $at, 0x20($k0)
+    ld    $v0, 0x28($k0)
+    mtlo  $k1
+    ld    $k1, 0x110($k0)
+    ld    $v1, 0x30($k0)
+    ld    $a0, 0x38($k0)
+    ld    $a1, 0x40($k0)
+    ld    $a2, 0x48($k0)
+    ld    $a3, 0x50($k0)
+    ld    $t0, 0x58($k0)
+    ld    $t1, 0x60($k0)
+    ld    $t2, 0x68($k0)
+    ld    $t3, 0x70($k0)
+    ld    $t4, 0x78($k0)
+    ld    $t5, 0x80($k0)
+    ld    $t6, 0x88($k0)
+    ld    $t7, 0x90($k0)
+    ld    $s0, 0x98($k0)
+    ld    $s1, 0xa0($k0)
+    ld    $s2, 0xa8($k0)
+    ld    $s3, 0xb0($k0)
+    ld    $s4, 0xb8($k0)
+    ld    $s5, 0xc0($k0)
+    ld    $s6, 0xc8($k0)
+    ld    $s7, 0xd0($k0)
+    ld    $t8, 0xd8($k0)
+    ld    $t9, 0xe0($k0)
+    ld    $gp, 0xe8($k0)
+    mthi  $k1
+    ld    $sp, 0xf0($k0)
+    ld    $fp, 0xf8($k0)
+    ld    $ra, 0x100($k0)
+    lw    $k1, 0x11c($k0)
+    mtc0  $k1, $14
+.ifndef VERSION_EU
+    lw    $k1, 0x118($k0)
+    mtc0  $k1, $12
+.endif
+    lw    $k1, 0x18($k0)
+    beqz  $k1, .L80326EF0
+     nop
+    lw    $k1, 0x12c($k0)
+    ctc1  $k1, $31
+    ldc1  $f0, 0x130($k0)
+    ldc1  $f2, 0x138($k0)
+    ldc1  $f4, 0x140($k0)
+    ldc1  $f6, 0x148($k0)
+    ldc1  $f8, 0x150($k0)
+    ldc1  $f10, 0x158($k0)
+    ldc1  $f12, 0x160($k0)
+    ldc1  $f14, 0x168($k0)
+    ldc1  $f16, 0x170($k0)
+    ldc1  $f18, 0x178($k0)
+    ldc1  $f20, 0x180($k0)
+    ldc1  $f22, 0x188($k0)
+    ldc1  $f24, 0x190($k0)
+    ldc1  $f26, 0x198($k0)
+    ldc1  $f28, 0x1a0($k0)
+    ldc1  $f30, 0x1a8($k0)
+.L80326EF0:
+    lw    $k1, 0x128($k0)
+.ifdef VERSION_EU
+/* 0B3998 802F4198 3C1A8030 */  lui   $k0, %hi(D_8030208C) # $k0, 0x8030
+/* 0B399C 802F419C 275A208C */  addiu $k0, %lo(D_8030208C) # addiu $k0, $k0, 0x208c
+/* 0B39A0 802F41A0 8F5A0000 */  lw    $k0, ($k0)
+/* 0B39A4 802F41A4 001AD402 */  srl   $k0, $k0, 0x10
+/* 0B39A8 802F41A8 037AD824 */  and   $k1, $k1, $k0
+.endif
+    sll   $k1, $k1, 1
+    lui   $k0, %hi(D_803386D0) # $k0, 0x8034
+    addiu $k0, %lo(D_803386D0) # addiu $k0, $k0, -0x7930
+    addu  $k1, $k1, $k0
+    lhu   $k1, ($k1)
+    lui   $k0, %hi(MI_INTR_MASK_REG) # $k0, 0xa430
+    addiu $k0, %lo(MI_INTR_MASK_REG) # addiu $k0, $k0, 0xc
+    sw    $k1, ($k0)
+    nop
+    nop
+    nop
+    nop
+    eret
+glabel __osCleanupThread
+    jal   osDestroyThread
+     move  $a0, $zero
+
+.section .data
+
+glabel D_80334920
+    .word 0
+    .word 0
+    .word 0
+    .word 0
+    .word 0
+
+glabel D_80334934
+    .word 0
+
+glabel D_80334938
+    .word 0
+    .word 0
+
+.section .rodata
+
+glabel D_80338610
+    .byte 0x00,0x14,0x18,0x18,0x1C,0x1C,0x1C,0x1C,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x04,0x08,0x08,0x0C,0x0C,0x0C,0x0C,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10
+
+glabel jtbl_80338630
+    .word L80326B9C
+    .word L80326B64
+    .word L80326B44
+    .word L803269B8
+    .word L80326984
+    .word L80326AE8
+.ifdef VERSION_EU
+    .word 0x802f3b28 
+    .word 0x802f3b34
+.else
+    .word L80326BE8
+    .word L80326BE8
+.endif
+    .word L80326964
+    .word 0
+    .word 0
+    .word 0
diff --git a/sm64.ld b/sm64.ld
index 8506985..c0feb34 100755
--- a/sm64.ld
+++ b/sm64.ld
@@ -114,6 +114,7 @@ SECTIONS
       BUILD_DIR/src/game/rendering_graph_node.o(.text);
       BUILD_DIR/src/game/profiler.o(.text);
       BUILD_DIR/asm/decompress.o(.text);
+      BUILD_DIR/asm/crash.o(.text);
       BUILD_DIR/src/game/camera.o(.text);
       BUILD_DIR/src/game/debug_course.o(.text);
       BUILD_DIR/src/game/object_list_processor.o(.text);
diff --git a/sm64.ld.orig b/sm64.ld.orig
new file mode 100644
index 0000000..8506985
--- /dev/null
+++ b/sm64.ld.orig
@@ -0,0 +1,1021 @@
+OUTPUT_ARCH (mips)
+
+/* include/segments.h defines SEG_POOL_START, SEG_POOL_END, SEG_BUFFERS,
+ * SEG_GODDARD, SEG_MAIN, SEG_ENGINE, SEG_FRAMEBUFFERS */
+#include "segments.h"
+
+#define BEGIN_SEG(name, addr) \
+    _##name##SegmentStart = ADDR(.name); \
+    _##name##SegmentRomStart = __romPos; \
+    .name addr : AT(__romPos)
+
+#define END_SEG(name) \
+    _##name##SegmentEnd = ADDR(.name) + SIZEOF(.name); \
+    _##name##SegmentRomEnd = __romPos + SIZEOF(.name); \
+    __romPos += SIZEOF(.name);
+
+#define BEGIN_NOLOAD(name) \
+    _##name##SegmentNoloadStart = ADDR(.name.noload); \
+    .name.noload (NOLOAD) :
+
+#define END_NOLOAD(name) \
+    _##name##SegmentNoloadEnd = ADDR(.name.noload) + SIZEOF(.name.noload);
+
+#define MIO0_SEG(name, segAddr) \
+   BEGIN_SEG(name##_mio0, segAddr) \
+   { \
+      BUILD_DIR/bin/name.mio0.o(.data); \
+      . = ALIGN(0x10); \
+   } \
+   END_SEG(name##_mio0)
+
+#define MIO0_EU_SEG(name, segAddr) \
+   BEGIN_SEG(name##_mio0, segAddr) \
+   { \
+      BUILD_DIR/bin/eu/name.mio0.o(.data); \
+      . = ALIGN(0x10); \
+   } \
+   END_SEG(name##_mio0)
+
+#define STANDARD_LEVEL(name) \
+   BEGIN_SEG(name##_segment_7, 0x07000000) \
+   { \
+      BUILD_DIR/levels/name/leveldata.mio0.o(.data); \
+      . = ALIGN(0x10); \
+   } \
+   END_SEG(name##_segment_7) \
+   BEGIN_SEG(name, 0x0E000000) \
+   { \
+      BUILD_DIR/levels/name/script.o(.data); \
+      BUILD_DIR/levels/name/geo.o(.data); \
+   } \
+   END_SEG(name)
+
+#define STANDARD_OBJECTS(name, segAddr, geoAddr) \
+   BEGIN_SEG(name##_mio0, segAddr) \
+   { \
+      BUILD_DIR/actors/name.mio0.o(.data); \
+      . = ALIGN(0x10); \
+   } \
+   END_SEG(name##_mio0) \
+   BEGIN_SEG(name##_geo, geoAddr) \
+   { \
+      BUILD_DIR/actors/name##_geo.o(.data); \
+   } \
+   END_SEG(name##_geo)
+
+SECTIONS
+{
+   __romPos = 0;
+
+   BEGIN_SEG(boot, 0x04000000)
+   {
+      BUILD_DIR/asm/rom_header.o(.text);
+      BUILD_DIR/asm/boot.o(.text);
+   }
+   END_SEG(boot)
+
+   . = 0x80000400;
+   BEGIN_NOLOAD(zbuffer) {
+      BUILD_DIR/src/buffers/zbuffer.o(.bss*);
+   }
+
+   /* lib/src/__osDevMgrMain.c and lib/src/osCreateViManager.c contain infinite
+    * loops compiled without -g, which cause the return statements and the .o
+    * files themselves to be aligned to 32-byte boundaries. But in the binary,
+    * they are actually aligned only to 16 bytes! We force this to happen using
+    * a SUBALIGN directive. */
+   BEGIN_SEG(main, SEG_MAIN) SUBALIGN(16)
+   {
+      BUILD_DIR/asm/entry.o(.text);
+      BUILD_DIR/src/game/crash_screen.o(.text);
+      BUILD_DIR/src/game/main.o(.text);
+      BUILD_DIR/src/game/game_init.o(.text);
+      BUILD_DIR/src/game/sound_init.o(.text);
+#ifdef VERSION_SH
+      BUILD_DIR/src/game/thread6.o(.text);
+#endif
+      BUILD_DIR/src/game/level_update.o(.text);
+      BUILD_DIR/src/game/interaction.o(.text);
+      BUILD_DIR/src/game/mario.o(.text);
+      BUILD_DIR/src/game/mario_step.o(.text);
+      BUILD_DIR/src/game/mario_actions_cutscene.o(.text);
+      BUILD_DIR/src/game/mario_actions_automatic.o(.text);
+      BUILD_DIR/src/game/mario_actions_stationary.o(.text);
+      BUILD_DIR/src/game/mario_actions_moving.o(.text);
+      BUILD_DIR/src/game/mario_actions_airborne.o(.text);
+      BUILD_DIR/src/game/mario_actions_submerged.o(.text);
+      BUILD_DIR/src/game/mario_actions_object.o(.text);
+      BUILD_DIR/src/game/level_geo.o(.text);
+      BUILD_DIR/src/game/mario_misc.o(.text);
+      BUILD_DIR/src/game/memory.o(.text);
+      BUILD_DIR/src/game/save_file.o(.text);
+      BUILD_DIR/src/game/area.o(.text);
+      BUILD_DIR/src/game/rendering_graph_node.o(.text);
+      BUILD_DIR/src/game/profiler.o(.text);
+      BUILD_DIR/asm/decompress.o(.text);
+      BUILD_DIR/src/game/camera.o(.text);
+      BUILD_DIR/src/game/debug_course.o(.text);
+      BUILD_DIR/src/game/object_list_processor.o(.text);
+#ifndef VERSION_EU
+      BUILD_DIR/src/game/object_helpers.o(.text);
+#endif
+      BUILD_DIR/src/game/behavior_actions.o(.text);
+      BUILD_DIR/src/game/platform_displacement.o(.text);
+#ifndef VERSION_EU
+      BUILD_DIR/src/game/object_collision.o(.text);
+      BUILD_DIR/src/game/spawn_object.o(.text);
+#endif
+      BUILD_DIR/src/game/spawn_sound.o(.text);
+      BUILD_DIR/src/game/debug.o(.text);
+      BUILD_DIR/src/game/screen_transition.o(.text);
+      BUILD_DIR/src/game/shadow.o(.text);
+      BUILD_DIR/src/game/skybox.o(.text);
+      BUILD_DIR/src/game/moving_texture.o(.text);
+      BUILD_DIR/src/game/geo_misc.o(.text);
+      BUILD_DIR/src/game/paintings.o(.text);
+      BUILD_DIR/src/game/print.o(.text);
+      BUILD_DIR/src/game/ingame_menu.o(.text);
+      BUILD_DIR/src/game/envfx_snow.o(.text);
+      BUILD_DIR/src/game/envfx_bubbles.o(.text);
+      BUILD_DIR/src/game/macro_special_objects.o(.text);
+      BUILD_DIR/src/game/hud.o(.text);
+      BUILD_DIR/src/game/obj_behaviors.o(.text);
+      BUILD_DIR/src/game/obj_behaviors_2.o(.text);
+      BUILD_DIR/src/audio/synthesis.o(.text);
+      BUILD_DIR/src/audio/heap.o(.text);
+      BUILD_DIR/src/audio/load.o(.text);
+      BUILD_DIR/src/audio/playback.o(.text);
+      BUILD_DIR/src/audio/effects.o(.text);
+      BUILD_DIR/src/audio/seqplayer.o(.text);
+      BUILD_DIR/src/audio/external.o(.text);
+      BUILD_DIR/src/audio/port_eu.o(.text);
+#if defined(VERSION_EU) || defined(VERSION_SH)
+      BUILD_DIR/libultra.a:string.o(.text);
+      BUILD_DIR/libultra.a:_Printf.o(.text);
+      BUILD_DIR/libultra.a:llmuldiv.o(.text);
+      BUILD_DIR/libultra.a:osInitialize.o(.text);
+      BUILD_DIR/libultra.a:osSetTime.o(.text);
+      BUILD_DIR/libultra.a:osGetTime.o(.text);
+      BUILD_DIR/libultra.a:osWritebackDCacheAll.o(.text);
+      BUILD_DIR/libultra.a:osViBlack.o(.text);
+      BUILD_DIR/libultra.a:osViSwapBuffer.o(.text);
+      BUILD_DIR/libultra.a:__osGetCurrFaultedThread.o(.text);
+      BUILD_DIR/libultra.a:osSetEventMesg.o(.text);
+      BUILD_DIR/libultra.a:osRecvMesg.o(.text);
+      BUILD_DIR/libultra.a:parameters.o(.text);
+      BUILD_DIR/libultra.a:osCreateMesgQueue.o(.text);
+      BUILD_DIR/libultra.a:osCreateThread.o(.text);
+      BUILD_DIR/libultra.a:osStartThread.o(.text);
+      BUILD_DIR/libultra.a:osMapTLB.o(.text);
+      BUILD_DIR/libultra.a:osUnmapTLBAll.o(.text);
+      BUILD_DIR/libultra.a:sprintf.o(.text);
+      BUILD_DIR/libultra.a:osViSetEvent.o(.text);
+      BUILD_DIR/libultra.a:osSpTaskLoadGo.o(.text);
+      BUILD_DIR/libultra.a:osSpTaskYield.o(.text);
+      BUILD_DIR/libultra.a:osSendMesg.o(.text);
+      BUILD_DIR/libultra.a:osSpTaskYielded.o(.text);
+      BUILD_DIR/libultra.a:osCreateViManager.o(.text);
+      BUILD_DIR/libultra.a:osViSetMode.o(.text);
+      BUILD_DIR/libultra.a:osViSetSpecialFeatures.o(.text);
+      BUILD_DIR/libultra.a:osCreatePiManager.o(.text);
+      BUILD_DIR/libultra.a:osSetThreadPri.o(.text);
+      BUILD_DIR/libultra.a:osViSwapBuffer.o(.text);
+      BUILD_DIR/libultra.a:sqrtf.o(.text);
+      BUILD_DIR/libultra.a:osContStartReadData.o(.text);
+      BUILD_DIR/libultra.a:osContInit.o(.text);
+      BUILD_DIR/libultra.a:osEepromProbe.o(.text);
+      BUILD_DIR/libultra.a:osInvalDCache.o(.text);
+      BUILD_DIR/libultra.a:osPiStartDma.o(.text);
+      BUILD_DIR/libultra.a:bzero.o(.text)
+      BUILD_DIR/libultra.a:osInvalICache.o(.text)
+      BUILD_DIR/libultra.a:osEepromLongRead.o(.text)
+      BUILD_DIR/libultra.a:osEepromLongWrite.o(.text)
+      BUILD_DIR/libultra.a:bcopy.o(.text)
+      BUILD_DIR/libultra.a:guOrthoF.o(.text)
+      BUILD_DIR/libultra.a:guPerspectiveF.o(.text)
+      BUILD_DIR/libultra.a:llconv.o(.text)
+      BUILD_DIR/libultra.a:cosf.o(.text)
+      BUILD_DIR/libultra.a:sinf.o(.text)
+      BUILD_DIR/libultra.a:guTranslateF.o(.text)
+      BUILD_DIR/libultra.a:guRotateF.o(.text)
+      BUILD_DIR/libultra.a:guScaleF.o(.text)
+      BUILD_DIR/libultra.a:osAiSetFrequency.o(.text)
+      BUILD_DIR/libultra.a:alBnkfNew.o(.text)
+      BUILD_DIR/libultra.a:osAiGetLength.o(.text)
+      BUILD_DIR/libultra.a:osAiSetNextBuffer.o(.text)
+      BUILD_DIR/libultra.a:_Litob.o(.text)
+      BUILD_DIR/libultra.a:_Ldtob.o(.text)
+      BUILD_DIR/libultra.a:__osSetSR.o(.text)
+      BUILD_DIR/libultra.a:__osGetSR.o(.text)
+      BUILD_DIR/libultra.a:__osSetFpcCsr.o(.text)
+      BUILD_DIR/libultra.a:__osSiRawReadIo.o(.text)
+      BUILD_DIR/libultra.a:__osSiRawWriteIo.o(.text)
+      BUILD_DIR/libultra.a:__osExceptionPreamble.o(.text)
+      BUILD_DIR/libultra.a:osWritebackDCache.o(.text)
+      BUILD_DIR/libultra.a:osMapTLBRdb.o(.text)
+      BUILD_DIR/libultra.a:osPiRawReadIo.o(.text)
+      BUILD_DIR/libultra.a:EU_D_802f4330.o(.text)
+      BUILD_DIR/libultra.a:D_802F4380.o(.text)
+      BUILD_DIR/libultra.a:func_802F4A20.o(.text)
+      BUILD_DIR/libultra.a:osTimer.o(.text)
+      BUILD_DIR/libultra.a:__osDisableInt.o(.text)
+      BUILD_DIR/libultra.a:__osRestoreInt.o(.text)
+      BUILD_DIR/libultra.a:osGetCount.o(.text)
+      BUILD_DIR/libultra.a:__osViInit.o(.text)
+      BUILD_DIR/libultra.a:__osDequeueThread.o(.text)
+      BUILD_DIR/libultra.a:osVirtualToPhysical.o(.text)
+      BUILD_DIR/libultra.a:__osSpSetStatus.o(.text)
+      BUILD_DIR/libultra.a:__osSpSetPc.o(.text)
+      BUILD_DIR/libultra.a:__osSpRawStartDma.o(.text)
+      BUILD_DIR/libultra.a:__osSpDeviceBusy.o(.text)
+      BUILD_DIR/libultra.a:__osSpGetStatus.o(.text)
+      BUILD_DIR/libultra.a:osGetThreadPri.o(.text)
+      BUILD_DIR/libultra.a:__osViGetCurrentContext.o(.text);
+      BUILD_DIR/libultra.a:__osViSwapContext.o(.text)
+      BUILD_DIR/libultra.a:__osPiCreateAccessQueue.o(.text)
+      BUILD_DIR/libultra.a:osPiRawStartDma.o(.text)
+      BUILD_DIR/libultra.a:osEPiRawStartDma.o(.text)
+      BUILD_DIR/libultra.a:__osDevMgrMain.o(.text)
+      BUILD_DIR/libultra.a:__osSiCreateAccessQueue.o(.text)
+      BUILD_DIR/libultra.a:__osSiRawStartDma.o(.text)
+      BUILD_DIR/libultra.a:osSetTimer.o(.text)
+      BUILD_DIR/libultra.a:osEepromWrite.o(.text)
+      BUILD_DIR/libultra.a:osJamMesg.o(.text)
+      BUILD_DIR/libultra.a:osPiGetCmdQueue.o(.text)
+      BUILD_DIR/libultra.a:osEepromRead.o(.text)
+      BUILD_DIR/libultra.a:guMtxF2L.o(.text)
+      BUILD_DIR/libultra.a:guNormalize.o(.text)
+      BUILD_DIR/libultra.a:__osAiDeviceBusy.o(.text);
+      BUILD_DIR/libultra.a:ldiv.o(.text)
+      BUILD_DIR/libultra.a:__osSiDeviceBusy.o(.text);
+      BUILD_DIR/libultra.a:osSetIntMask.o(.text)
+      BUILD_DIR/libultra.a:osDestroyThread.o(.text)
+      BUILD_DIR/libultra.a:osLeoDiskInit.o(.text)
+      BUILD_DIR/libultra.a:__osSetCompare.o(.text)
+      BUILD_DIR/libultra.a:__osProbeTLB.o(.text)
+      BUILD_DIR/libultra.a:__osDequeueThread.o(.text)
+      BUILD_DIR/libultra.a:func_802F7140.o(.text)
+      BUILD_DIR/libultra.a:func_802F71A0.o(.text)
+      BUILD_DIR/libultra.a:func_802F71F0.o(.text)
+
+      BUILD_DIR/lib/rsp.o(.text);
+
+#else
+      BUILD_DIR/src/game*.o(.text);
+      BUILD_DIR/src/audio*.o(.text);
+      BUILD_DIR/libultra.a:parameters.o(.text);
+      BUILD_DIR/libultra.a:osSetTime.o(.text);
+      BUILD_DIR/libultra.a:osMapTLB.o(.text);
+      BUILD_DIR/libultra.a:osUnmapTLBAll.o(.text);
+      BUILD_DIR/libultra.a:sprintf.o(.text);
+      BUILD_DIR/libultra.a:osCreateMesgQueue.o(.text);
+      BUILD_DIR/libultra.a:osSetEventMesg.o(.text);
+      BUILD_DIR/libultra.a:osViSetEvent.o(.text);
+      BUILD_DIR/libultra.a:osCreateThread.o(.text);
+      BUILD_DIR/libultra.a:osRecvMesg.o(.text);
+      BUILD_DIR/libultra.a:osSpTaskLoadGo.o(.text);
+      BUILD_DIR/libultra.a:osSpTaskYield.o(.text);
+      BUILD_DIR/libultra.a:osSendMesg.o(.text);
+      BUILD_DIR/libultra.a:osSpTaskYielded.o(.text);
+      BUILD_DIR/libultra.a:osStartThread.o(.text);
+      BUILD_DIR/libultra.a:osWritebackDCacheAll.o(.text);
+      BUILD_DIR/libultra.a:osCreateViManager.o(.text);
+      BUILD_DIR/libultra.a:osViSetMode.o(.text);
+      BUILD_DIR/libultra.a:osViBlack.o(.text);
+      BUILD_DIR/libultra.a:osViSetSpecialFeatures.o(.text);
+      BUILD_DIR/libultra.a:osCreatePiManager.o(.text);
+      BUILD_DIR/libultra.a:osSetThreadPri.o(.text);
+      BUILD_DIR/libultra.a:osInitialize.o(.text);
+      BUILD_DIR/libultra.a:osViSwapBuffer.o(.text);
+      BUILD_DIR/libultra.a:sqrtf.o(.text);
+      BUILD_DIR/libultra.a:osContStartReadData.o(.text);
+      BUILD_DIR/libultra.a:osContInit.o(.text);
+      BUILD_DIR/libultra.a:osEepromProbe.o(.text);
+      BUILD_DIR/libultra.a:llmuldiv.o(.text);
+      BUILD_DIR/libultra.a:llmuldiv_gcc.o(.text);
+      BUILD_DIR/libultra.a:osInvalDCache.o(.text);
+      BUILD_DIR/libultra.a:osPiStartDma.o(.text);
+      BUILD_DIR/libultra.a:bzero.o(.text);
+      BUILD_DIR/libultra.a:osInvalICache.o(.text);
+      BUILD_DIR/libultra.a:osEepromLongRead.o(.text);
+      BUILD_DIR/libultra.a:osEepromLongWrite.o(.text);
+      BUILD_DIR/libultra.a:bcopy.o(.text);
+      BUILD_DIR/libultra.a:guOrthoF.o(.text);
+      BUILD_DIR/libultra.a:guPerspectiveF.o(.text);
+      BUILD_DIR/libultra.a:osGetTime.o(.text);
+      BUILD_DIR/libultra.a:llconv.o(.text);
+      BUILD_DIR/libultra.a:cosf.o(.text);
+      BUILD_DIR/libultra.a:sinf.o(.text);
+      BUILD_DIR/libultra.a:guTranslateF.o(.text);
+      BUILD_DIR/libultra.a:guRotateF.o(.text);
+      BUILD_DIR/libultra.a:guScaleF.o(.text);
+#ifndef VERSION_EU
+      BUILD_DIR/libultra.a:osAiSetFrequency.o(.text);
+#endif
+      BUILD_DIR/libultra.a:alBnkfNew.o(.text);
+      BUILD_DIR/libultra.a:osWritebackDCache.o(.text);
+      BUILD_DIR/libultra.a:osAiGetLength.o(.text);
+      BUILD_DIR/libultra.a:osAiSetNextBuffer.o(.text);
+      BUILD_DIR/libultra.a:osTimer.o(.text);
+      BUILD_DIR/libultra.a:_Printf.o(.text);
+      BUILD_DIR/libultra.a:string.o(.text);
+      BUILD_DIR/libultra.a:__osDequeueThread.o(.text);
+      BUILD_DIR/libultra.a:__osDisableInt.o(.text);
+      BUILD_DIR/libultra.a:__osRestoreInt.o(.text);
+      BUILD_DIR/libultra.a:__osViInit.o(.text);
+      BUILD_DIR/libultra.a:__osExceptionPreamble.o(.text);
+      BUILD_DIR/libultra.a:osVirtualToPhysical.o(.text);
+      BUILD_DIR/libultra.a:__osSpSetStatus.o(.text);
+      BUILD_DIR/libultra.a:__osSpSetPc.o(.text);
+      BUILD_DIR/libultra.a:__osSpRawStartDma.o(.text);
+      BUILD_DIR/libultra.a:__osSpDeviceBusy.o(.text);
+      BUILD_DIR/libultra.a:__osSpGetStatus.o(.text);
+      BUILD_DIR/libultra.a:osGetThreadPri.o(.text);
+      BUILD_DIR/libultra.a:__osViGetCurrentContext.o(.text);
+      BUILD_DIR/libultra.a:__osViSwapContext.o(.text);
+      BUILD_DIR/libultra.a:osGetCount.o(.text);
+      BUILD_DIR/libultra.a:__osPiCreateAccessQueue.o(.text);
+      BUILD_DIR/libultra.a:osPiRawStartDma.o(.text);
+      BUILD_DIR/libultra.a:__osDevMgrMain.o(.text);
+      BUILD_DIR/libultra.a:__osSetSR.o(.text);
+      BUILD_DIR/libultra.a:__osGetSR.o(.text);
+      BUILD_DIR/libultra.a:__osSetFpcCsr.o(.text);
+      BUILD_DIR/libultra.a:__osSiRawReadIo.o(.text);
+      BUILD_DIR/libultra.a:__osSiRawWriteIo.o(.text);
+      BUILD_DIR/libultra.a:osMapTLBRdb.o(.text);
+      BUILD_DIR/libultra.a:osPiRawReadIo.o(.text);
+#if VERSION_JP
+      . += 0x40;
+#endif
+      BUILD_DIR/libultra.a:__osSiCreateAccessQueue.o(.text);
+      BUILD_DIR/libultra.a:__osSiRawStartDma.o(.text);
+      BUILD_DIR/libultra.a:osSetTimer.o(.text);
+      BUILD_DIR/libultra.a:osEepromWrite.o(.text);
+      BUILD_DIR/libultra.a:osJamMesg.o(.text);
+      BUILD_DIR/libultra.a:osPiGetCmdQueue.o(.text);
+      BUILD_DIR/libultra.a:osEepromRead.o(.text);
+      BUILD_DIR/libultra.a:guMtxF2L.o(.text);
+      BUILD_DIR/libultra.a:guMtxIdentF.o(.text);
+      BUILD_DIR/libultra.a:guNormalize.o(.text);
+      BUILD_DIR/libultra.a:__osAiDeviceBusy.o(.text);
+      BUILD_DIR/libultra.a:__osSetCompare.o(.text);
+      BUILD_DIR/libultra.a:_Litob.o(.text);
+      BUILD_DIR/libultra.a:_Ldtob.o(.text);
+      BUILD_DIR/libultra.a:kdebugserver.o(.text);
+      BUILD_DIR/libultra.a:__osSyncPutChars.o(.text);
+      BUILD_DIR/libultra.a:osSetIntMask.o(.text);
+      BUILD_DIR/libultra.a:osDestroyThread.o(.text);
+      BUILD_DIR/libultra.a:__osProbeTLB.o(.text);
+      BUILD_DIR/libultra.a:__osSiDeviceBusy.o(.text);
+      BUILD_DIR/libultra.a:ldiv.o(.text);
+      BUILD_DIR/libultra.a:__osGetCause.o(.text);
+      BUILD_DIR/libultra.a:__osAtomicDec.o(.text);
+      BUILD_DIR/libultra.a:guLookAtRef.o(.text); /* Fast3DEX2 only */
+      BUILD_DIR/lib/rsp.o(.text);
+#endif
+
+      /* data */
+      BUILD_DIR/src/game/crash_screen.o(.data*);
+      BUILD_DIR/src/game/main.o(.data*);
+      BUILD_DIR/src/game/game_init.o(.data*);
+      BUILD_DIR/src/game/sound_init.o(.data*);
+      BUILD_DIR/src/game/level_update.o(.data*);
+      BUILD_DIR/src/game/interaction.o(.data*);
+      BUILD_DIR/src/game/mario.o(.data*);
+      BUILD_DIR/src/game/mario_step.o(.data*);
+      BUILD_DIR/src/game/mario_actions_cutscene.o(.data*);
+      BUILD_DIR/src/game/mario_actions_moving.o(.data*);
+      BUILD_DIR/src/game/mario_actions_submerged.o(.data*);
+      BUILD_DIR/src/game/mario_actions_object.o(.data*);
+      BUILD_DIR/src/game/mario_misc.o(.data*);
+      BUILD_DIR/src/game/memory.o(.data*);
+      BUILD_DIR/src/game/save_file.o(.data*);
+      BUILD_DIR/src/game/area.o(.data*);
+      BUILD_DIR/src/game/rendering_graph_node.o(.data*);
+      BUILD_DIR/src/game/profiler.o(.data*);
+      BUILD_DIR/src/game/camera.o(.data*);
+      BUILD_DIR/src/game/object_list_processor.o(.data*);
+#ifndef VERSION_EU
+      BUILD_DIR/src/game/object_helpers.o(.data*);
+#endif
+      BUILD_DIR/src/game/behavior_actions.o(.data*);
+      BUILD_DIR/src/game/platform_displacement.o(.data*);
+      BUILD_DIR/src/game/spawn_sound.o(.data*);
+      BUILD_DIR/src/game/debug.o(.data*);
+      BUILD_DIR/src/game/screen_transition.o(.data*);
+      BUILD_DIR/src/game/shadow.o(.data*);
+      BUILD_DIR/src/game/skybox.o(.data*);
+      BUILD_DIR/src/game/moving_texture.o(.data*);
+      BUILD_DIR/src/game/geo_misc.o(.data*);
+      BUILD_DIR/src/game/paintings.o(.data*);
+      BUILD_DIR/src/game/print.o(.data*);
+      BUILD_DIR/src/game/ingame_menu.o(.data*);
+      BUILD_DIR/src/game/envfx_snow.o(.data*);
+      BUILD_DIR/src/game/envfx_bubbles.o(.data*);
+      BUILD_DIR/src/game/macro_special_objects.o(.data*);
+      BUILD_DIR/src/game/hud.o(.data*);
+      BUILD_DIR/src/game/obj_behaviors.o(.data*);
+      BUILD_DIR/src/game/obj_behaviors_2.o(.data*);
+#ifndef VERSION_EU
+      /* wildcard doesn't work on EU due to files being moved to engine/ */
+      BUILD_DIR/src/game*.o(.data*);
+#endif
+      BUILD_DIR/src/audio/external.o(.data*);
+      BUILD_DIR/src/audio/port_eu.o(.data*);
+      BUILD_DIR/src/audio/data.o(.data*);
+      BUILD_DIR/src/audio*.o(.data*);
+
+#ifdef VERSION_EU
+
+      BUILD_DIR/libultra.a:_Printf.o(.data*);
+      BUILD_DIR/libultra.a:osInitialize.o(.data*);
+      BUILD_DIR/libultra.a:osCreateViManager.o(.data*);
+      BUILD_DIR/libultra.a:osViTable.o(.data*);
+      BUILD_DIR/libultra.a:osCreatePiManager.o(.data*);
+      BUILD_DIR/libultra.a:osContInit.o(.data*);
+      BUILD_DIR/libultra.a:osAiSetNextBuffer.o(.data*);
+
+      BUILD_DIR/libultra.a:_Litob.o(.data*);
+
+      BUILD_DIR/libultra.a:__osExceptionPreamble.o(.data*);
+
+      BUILD_DIR/libultra.a:osTimer.o(.data*);
+      BUILD_DIR/libultra.a:__osViInit.o(.data*);
+      BUILD_DIR/libultra.a:__osDequeueThread.o(.data*);  // ffff...
+
+      BUILD_DIR/libultra.a:__osPiCreateAccessQueue.o(.data*);
+      BUILD_DIR/libultra.a:__osSiCreateAccessQueue.o(.data*);
+      BUILD_DIR/libultra.a:osViData.o(.data*);
+
+#else
+
+      BUILD_DIR/libultra.a:osViTable.o(.data*);
+      BUILD_DIR/libultra.a:osCreateViManager.o(.data*);
+      BUILD_DIR/libultra.a:osCreatePiManager.o(.data*);
+      BUILD_DIR/libultra.a:osInitialize.o(.data*);
+      BUILD_DIR/libultra.a:osContInit.o(.data*);
+      BUILD_DIR/libultra.a:osAiSetNextBuffer.o(.data*);
+      BUILD_DIR/libultra.a:osTimer.o(.data*);
+      BUILD_DIR/libultra.a:_Printf.o(.data*);
+      BUILD_DIR/libultra.a:__osDequeueThread.o(.data*);
+      BUILD_DIR/libultra.a:__osViInit.o(.data*);
+      BUILD_DIR/libultra.a:__osExceptionPreamble.o(.data*);
+      BUILD_DIR/libultra.a:__osPiCreateAccessQueue.o(.data*);
+      BUILD_DIR/libultra.a:__osSiCreateAccessQueue.o(.data*);
+      BUILD_DIR/libultra.a:_Litob.o(.data*);
+      BUILD_DIR/libultra.a:_Ldtob.o(.data*);
+      BUILD_DIR/libultra.a:osViData.o(.data*);
+      BUILD_DIR/libultra.a:kdebugserver.o(.data*);
+      BUILD_DIR/libultra.a:__osSyncPutChars.o(.data*);
+      BUILD_DIR/libultra.a:guRotateF.o(.data*);
+      BUILD_DIR/libultra.a:*.o(.data*);
+
+#endif
+
+
+      /* rodata */
+      BUILD_DIR/src/game/crash_screen.o(.rodata*);
+      BUILD_DIR/src/game/main.o(.rodata*);
+      BUILD_DIR/src/game/game_init.o(.rodata*);
+      BUILD_DIR/src/game/sound_init.o(.rodata*);
+      BUILD_DIR/src/game/level_update.o(.rodata*);
+      BUILD_DIR/src/game/interaction.o(.rodata*);
+      BUILD_DIR/src/game/mario.o(.rodata*);
+      BUILD_DIR/src/game/mario_step.o(.rodata*);
+      BUILD_DIR/src/game/mario_actions_cutscene.o(.rodata*);
+      BUILD_DIR/src/game/mario_actions_automatic.o(.rodata*);
+      BUILD_DIR/src/game/mario_actions_stationary.o(.rodata*);
+      BUILD_DIR/src/game/mario_actions_moving.o(.rodata*);
+      BUILD_DIR/src/game/mario_actions_airborne.o(.rodata*);
+      BUILD_DIR/src/game/mario_actions_submerged.o(.rodata*);
+      BUILD_DIR/src/game/mario_actions_object.o(.rodata*);
+      BUILD_DIR/src/game/mario_misc.o(.rodata*);
+      BUILD_DIR/src/game/area.o(.rodata*);
+      BUILD_DIR/src/game/rendering_graph_node.o(.rodata*);
+      BUILD_DIR/src/game/camera.o(.rodata*);
+      BUILD_DIR/src/game/object_list_processor.o(.rodata*);
+#ifndef VERSION_EU
+      BUILD_DIR/src/game/object_helpers.o(.rodata*);
+#endif
+      BUILD_DIR/src/game/behavior_actions.o(.rodata*);
+#ifndef VERSION_EU
+      BUILD_DIR/src/game/object_collision.o(.rodata*);
+      BUILD_DIR/src/game/spawn_object.o(.rodata*);
+#endif
+      BUILD_DIR/src/game/spawn_sound.o(.rodata*);
+      BUILD_DIR/src/game/debug.o(.rodata*);
+      BUILD_DIR/src/game/screen_transition.o(.rodata*);
+      BUILD_DIR/src/game/shadow.o(.rodata*);
+      BUILD_DIR/src/game/skybox.o(.rodata*);
+      BUILD_DIR/src/game/moving_texture.o(.rodata*);
+      BUILD_DIR/src/game/geo_misc.o(.rodata*);
+      BUILD_DIR/src/game/paintings.o(.rodata*);
+      BUILD_DIR/src/game/print.o(.rodata*);
+      BUILD_DIR/src/game/ingame_menu.o(.rodata*);
+      BUILD_DIR/src/game/envfx_snow.o(.rodata*);
+      BUILD_DIR/src/game/envfx_bubbles.o(.rodata*);
+      BUILD_DIR/src/game/macro_special_objects.o(.rodata*);
+      BUILD_DIR/src/game/hud.o(.rodata*);
+      BUILD_DIR/src/game/obj_behaviors.o(.rodata*);
+      BUILD_DIR/src/game/obj_behaviors_2.o(.rodata*);
+#ifndef VERSION_EU
+      BUILD_DIR/src/game*.o(.rodata*);
+#endif
+      BUILD_DIR/src/audio/synthesis.o(.rodata*);
+      BUILD_DIR/src/audio/heap.o(.rodata*);
+      BUILD_DIR/src/audio/load.o(.rodata*);
+      BUILD_DIR/src/audio/playback.o(.rodata*);
+      BUILD_DIR/src/audio/effects.o(.rodata*);
+      BUILD_DIR/src/audio/seqplayer.o(.rodata*);
+      BUILD_DIR/src/audio/external.o(.rodata*);
+      BUILD_DIR/src/audio/port_eu.o(.rodata*);
+      BUILD_DIR/src/audio*.o(.rodata*);
+
+#ifdef VERSION_EU
+      BUILD_DIR/libultra.a:_Printf.o(.rodata*);
+
+      BUILD_DIR/libultra.a:guPerspectiveF.o(.rodata*);
+      BUILD_DIR/libultra.a:llconv.o(.rodata*);
+      BUILD_DIR/libultra.a:cosf.o(.rodata*);
+      BUILD_DIR/libultra.a:sinf.o(.rodata*);
+      BUILD_DIR/libultra.a:guRotateF.o(.rodata*);
+
+      BUILD_DIR/libultra.a:_Litob.o(.rodata*);
+      BUILD_DIR/libultra.a:_Ldtob.o(.rodata*);
+      
+      BUILD_DIR/libultra.a:__osExceptionPreamble.o(.rodata*);
+      BUILD_DIR/libultra.a:__osDevMgrMain.o(.rodata*);
+      
+      BUILD_DIR/libultra.a:NaN.o(.rodata*);
+#else
+      BUILD_DIR/libultra.a:guPerspectiveF.o(.rodata*);
+      BUILD_DIR/libultra.a:llconv.o(.rodata*);
+      BUILD_DIR/libultra.a:cosf.o(.rodata*);
+      BUILD_DIR/libultra.a:sinf.o(.rodata*);
+      BUILD_DIR/libultra.a:guRotateF.o(.rodata*);
+      BUILD_DIR/libultra.a:_Printf.o(.rodata*);
+      BUILD_DIR/libultra.a:__osExceptionPreamble.o(.rodata*);
+      BUILD_DIR/libultra.a:NaN.o(.rodata*);
+      BUILD_DIR/libultra.a:_Litob.o(.rodata*);
+      BUILD_DIR/libultra.a:_Ldtob.o(.rodata*);
+#endif
+      BUILD_DIR/libultra.a:osSetIntMask.o(.rodata*);
+      BUILD_DIR/libultra.a:guLookAtRef.o(.rodata*); /* Fast3DEX2 only */
+#ifndef VERSION_EU
+      BUILD_DIR/libultra.a:*.o(.rodata*);
+#endif
+      BUILD_DIR/lib/rsp.o(.rodata*);
+   }
+   END_SEG(main)
+   BEGIN_NOLOAD(main)
+   {
+      BUILD_DIR/src/game/crash_screen.o(.bss*);
+      BUILD_DIR/src/game/main.o(.bss*);
+      BUILD_DIR/src/game/game_init.o(.bss*);
+      BUILD_DIR/src/game/sound_init.o(.bss*);
+      BUILD_DIR/src/game/level_update.o(.bss*);
+      BUILD_DIR/src/game/interaction.o(.bss*);
+      BUILD_DIR/src/game/mario.o(.bss*);
+      BUILD_DIR/src/game/mario_actions_cutscene.o(.bss*);
+      BUILD_DIR/src/game/mario_actions_moving.o(.bss*);
+      BUILD_DIR/src/game/mario_actions_submerged.o(.bss*);
+      BUILD_DIR/src/game/mario_misc.o(.bss*);
+      BUILD_DIR/src/game/memory.o(.bss*);
+      BUILD_DIR/src/game/save_file.o(.bss*);
+      BUILD_DIR/src/game/area.o(.bss*);
+      BUILD_DIR/src/game/rendering_graph_node.o(.bss*);
+      BUILD_DIR/src/game/profiler.o(.bss*);
+      BUILD_DIR/src/game/camera.o(.bss*);
+      BUILD_DIR/src/game/object_list_processor.o(.bss*);
+#ifndef VERSION_EU
+      BUILD_DIR/src/game/object_helpers.o(.bss*);
+#endif
+      BUILD_DIR/src/game/behavior_actions.o(.bss*);
+      BUILD_DIR/src/game/debug.o(.bss*);
+      BUILD_DIR/src/game/shadow.o(.bss*);
+      BUILD_DIR/src/game/skybox.o(.bss*);
+      BUILD_DIR/src/game/moving_texture.o(.bss*);
+      BUILD_DIR/src/game/geo_misc.o(.bss*);
+      BUILD_DIR/src/game/paintings.o(.bss*);
+      BUILD_DIR/src/game/print.o(.bss*);
+      BUILD_DIR/src/game/ingame_menu.o(.bss*);
+      BUILD_DIR/src/game/envfx_snow.o(.bss*);
+      BUILD_DIR/src/game/envfx_bubbles.o(.bss*);
+      BUILD_DIR/src/game/macro_special_objects.o(.bss*)
+      BUILD_DIR/src/game/hud.o(.bss*);
+      BUILD_DIR/src/game/obj_behaviors.o(.bss*);
+      BUILD_DIR/src/game/obj_behaviors_2.o(.bss*);
+#ifndef VERSION_EU
+      BUILD_DIR/src/game*.o(.bss*);
+#endif
+      BUILD_DIR/src/audio/external.o(.bss*);
+      BUILD_DIR/src/audio/port_eu.o(.bss*);
+   
+#ifdef VERSION_EU
+      BUILD_DIR/libultra.a:osInitialize.o(.bss*);
+
+      BUILD_DIR/libultra.a:osSetEventMesg.o(.bss*);
+      BUILD_DIR/libultra.a:osSpTaskLoadGo.o(.bss*);
+      BUILD_DIR/libultra.a:osCreateViManager.o(.bss*);
+      
+      BUILD_DIR/libultra.a:osCreatePiManager.o(.bss*);
+      BUILD_DIR/libultra.a:osContStartReadData.o(.bss*);
+      BUILD_DIR/libultra.a:osContInit.o(.bss*);
+
+      BUILD_DIR/libultra.a:guRotateF.o(.bss*);
+
+      BUILD_DIR/libultra.a:unk_stack_data.o(.bss*);
+      BUILD_DIR/libultra.a:osTimer.o(.bss*);
+      BUILD_DIR/libultra.a:__osPiCreateAccessQueue.o(.bss*);
+      BUILD_DIR/libultra.a:__osSiCreateAccessQueue.o(.bss*);
+      BUILD_DIR/libultra.a:osEepromWrite.o(.bss*);
+      
+      BUILD_DIR/libultra.a:kdebugserver.o(.bss*);
+      BUILD_DIR/libultra.a:osLeoDiskInit.o(.bss*)
+
+      BUILD_DIR/libultra.a:_Printf.o(.bss*);
+      BUILD_DIR/libultra.a:osAiSetNextBuffer.o(.bss*);
+      BUILD_DIR/libultra.a:EU_D_802f4330.o(.bss*);
+
+#else
+      BUILD_DIR/libultra.a:osSetEventMesg.o(.bss*);
+      BUILD_DIR/libultra.a:osSpTaskLoadGo.o(.bss*);
+      BUILD_DIR/libultra.a:osCreateViManager.o(.bss*);
+      BUILD_DIR/libultra.a:osCreatePiManager.o(.bss*);
+      BUILD_DIR/libultra.a:osInitialize.o(.bss*);
+      BUILD_DIR/libultra.a:osContStartReadData.o(.bss*);
+      BUILD_DIR/libultra.a:osContInit.o(.bss*);
+      BUILD_DIR/libultra.a:guRotateF.o(.bss*);
+      BUILD_DIR/libultra.a:osTimer.o(.bss*);
+      BUILD_DIR/libultra.a:_Printf.o(.bss*);
+      BUILD_DIR/libultra.a:__osPiCreateAccessQueue.o(.bss*);
+      BUILD_DIR/libultra.a:__osSiCreateAccessQueue.o(.bss*);
+      BUILD_DIR/libultra.a:osEepromWrite.o(.bss*);
+      BUILD_DIR/libultra.a:unk_stack_data.o(.bss*);
+      BUILD_DIR/libultra.a:kdebugserver.o(.bss*);
+      BUILD_DIR/libultra.a:*.o(.bss*);
+#endif
+
+      . = ALIGN(0x8);
+   }
+   END_NOLOAD(main)
+   _mainSegmentNoloadSizeLo = SIZEOF (.main.noload) & 0xffff;
+   _mainSegmentNoloadSizeHi = SIZEOF (.main.noload) >> 16;
+
+   ASSERT((. <= SEG_ENGINE), "Error: main segment extended into engine.")
+
+   BEGIN_SEG(engine, SEG_ENGINE)
+   {
+      BUILD_DIR/src/engine/math_util.o(.text);
+      BUILD_DIR/src/engine/graph_node.o(.text);
+      BUILD_DIR/src/engine/graph_node_manager.o(.text);
+      BUILD_DIR/src/engine/geo_layout.o(.text);
+      BUILD_DIR/src/engine/level_script.o(.text);
+      BUILD_DIR/src/engine/surface_collision.o(.text);
+      BUILD_DIR/src/engine/surface_load.o(.text);
+      BUILD_DIR/src/engine/behavior_script.o(.text);
+#ifdef VERSION_EU
+      BUILD_DIR/src/game/object_collision.o(.text);
+      BUILD_DIR/src/game/spawn_object.o(.text);
+      BUILD_DIR/src/game/object_helpers.o(.text);
+#endif
+      BUILD_DIR/src/engine*.o(.text);
+      /* data */
+      BUILD_DIR/src/engine/graph_node.o(.data*);
+      BUILD_DIR/src/engine/graph_node_manager.o(.data*);
+      BUILD_DIR/src/engine/math_util.o(.data*);
+      BUILD_DIR/src/engine/geo_layout.o(.data*);
+      BUILD_DIR/src/engine/level_script.o(.data*);
+      BUILD_DIR/src/engine/behavior_script.o(.data*);
+#ifdef VERSION_EU
+      BUILD_DIR/src/game/object_collision.o(.data*);
+      BUILD_DIR/src/game/spawn_object.o(.data*);
+      BUILD_DIR/src/game/object_helpers.o(.data*);
+#endif
+      BUILD_DIR/src/engine*.o(.data*);
+      /* rodata */
+      BUILD_DIR/src/engine/math_util.o(.rodata*);
+      BUILD_DIR/src/engine/level_script.o(.rodata*);
+      BUILD_DIR/src/engine/surface_collision.o(.rodata*);
+      BUILD_DIR/src/engine/surface_load.o(.rodata*);
+#ifdef VERSION_EU
+      BUILD_DIR/src/game/object_collision.o(.rodata*);
+      BUILD_DIR/src/game/spawn_object.o(.rodata*);
+      BUILD_DIR/src/game/object_helpers.o(.rodata*);
+#endif
+      BUILD_DIR/src/engine*.o(.rodata*);
+   }
+   END_SEG(engine)
+   BEGIN_NOLOAD(engine)
+   {
+      BUILD_DIR/src/engine/math_util.o(.bss*);
+      BUILD_DIR/src/engine/geo_layout.o(.bss*);
+      BUILD_DIR/src/engine/level_script.o(.bss*);
+      BUILD_DIR/src/engine/surface_collision.o(.bss*);
+      BUILD_DIR/src/engine/surface_load.o(.bss*);
+      BUILD_DIR/src/engine/behavior_script.o(.bss*);
+#ifdef VERSION_EU
+      BUILD_DIR/src/game/object_collision.o(.bss*);
+      BUILD_DIR/src/game/spawn_object.o(.bss*);
+      BUILD_DIR/src/game/object_helpers.o(.bss*);
+#endif
+      BUILD_DIR/src/engine*.o(.bss*);
+   }
+   END_NOLOAD(engine)
+
+   // ASSERT((. <= SEG_FRAMEBUFFERS), "Error: engine segment extended into framebuffers.")
+
+   . = SEG_FRAMEBUFFERS;
+   BEGIN_NOLOAD(framebuffers)
+   {
+      BUILD_DIR/src/buffers/framebuffers.o(.bss*);
+   }
+   END_NOLOAD(framebuffers)
+
+   __expansionRamStart = 0x80400000;
+   ASSERT((. <= __expansionRamStart), "Error: RDRAM expanded into Expansion RAM, despite Expansion RAM not being defined.")
+
+
+   BEGIN_SEG(entry, 0x10000000)
+   {
+      BUILD_DIR/levels/entry.o(.data);
+   }
+   END_SEG(entry)
+
+   /* load MIO0 and level data */
+   MIO0_SEG(segment2, 0x02000000)
+#ifdef VERSION_EU
+   MIO0_EU_SEG(translation_en, 0x19000000)
+   MIO0_EU_SEG(translation_fr, 0x19000000)
+   MIO0_EU_SEG(translation_de, 0x19000000)
+#endif
+
+   /* mario actor group */
+   STANDARD_OBJECTS(group0,  0x04000000, 0x17000000)
+
+   /* load the other actor groups */
+   STANDARD_OBJECTS(group1,  0x05000000, 0x0C000000)
+   STANDARD_OBJECTS(group2,  0x05000000, 0x0C000000)
+   STANDARD_OBJECTS(group3,  0x05000000, 0x0C000000)
+   STANDARD_OBJECTS(group4,  0x05000000, 0x0C000000)
+   STANDARD_OBJECTS(group5,  0x05000000, 0x0C000000)
+   STANDARD_OBJECTS(group6,  0x05000000, 0x0C000000)
+   STANDARD_OBJECTS(group7,  0x05000000, 0x0C000000)
+   STANDARD_OBJECTS(group8,  0x05000000, 0x0C000000)
+   STANDARD_OBJECTS(group9,  0x05000000, 0x0C000000)
+   STANDARD_OBJECTS(group10, 0x05000000, 0x0C000000)
+   STANDARD_OBJECTS(group11, 0x05000000, 0x0C000000)
+   STANDARD_OBJECTS(group12, 0x06000000, 0x0D000000)
+   STANDARD_OBJECTS(group13, 0x06000000, 0x0D000000)
+   STANDARD_OBJECTS(group14, 0x06000000, 0x0D000000)
+   STANDARD_OBJECTS(group15, 0x06000000, 0x0D000000)
+   STANDARD_OBJECTS(group16, 0x06000000, 0x0D000000)
+   STANDARD_OBJECTS(group17, 0x06000000, 0x0D000000)
+
+   /* load the common actor groups */
+   STANDARD_OBJECTS(common0, 0x08000000, 0x0F000000)
+   STANDARD_OBJECTS(common1, 0x03000000, 0x16000000)
+
+   /* use segmented addressing for behaviors */
+   BEGIN_SEG(behavior, 0x13000000)
+   {
+      BUILD_DIR/data/behavior_data.o(.data);
+   }
+   END_SEG(behavior)
+
+   /* 0x8016F000 21D7D0-255EC0 [386F0] */
+   BEGIN_SEG(goddard, SEG_GODDARD)
+   {
+      BUILD_DIR/src/menu/level_select_menu.o(.text);
+      BUILD_DIR/src/menu/intro_geo.o(.text);
+      BUILD_DIR/src/menu/file_select.o(.text);
+      BUILD_DIR/src/menu/star_select.o(.text);
+      BUILD_DIR/src/menu*.o(.text);
+      BUILD_DIR/libgoddard.a:gd_main.o(.text);
+      BUILD_DIR/libgoddard.a:gd_memory.o(.text);
+      BUILD_DIR/libgoddard.a:sfx.o(.text);
+      BUILD_DIR/libgoddard.a:draw_objects.o(.text);
+      BUILD_DIR/libgoddard.a:objects.o(.text);
+      BUILD_DIR/libgoddard.a:skin_movement.o(.text);
+      BUILD_DIR/libgoddard.a:particles.o(.text);
+      BUILD_DIR/libgoddard.a:dynlist_proc.o(.text);
+      BUILD_DIR/libgoddard.a:old_menu.o(.text);
+      BUILD_DIR/libgoddard.a:debug_utils.o(.text);
+      BUILD_DIR/libgoddard.a:joints.o(.text);
+      BUILD_DIR/libgoddard.a:skin.o(.text);
+      BUILD_DIR/libgoddard.a:gd_math.o(.text);
+      BUILD_DIR/libgoddard.a:shape_helper.o(.text);
+      BUILD_DIR/libgoddard.a:renderer.o(.text);
+      BUILD_DIR/libgoddard.a:*.o(.text);
+      /* data, rodata, per file */
+      BUILD_DIR/src/menu/level_select_menu.o(.data*);
+      BUILD_DIR/src/menu/level_select_menu.o(.rodata*);
+      BUILD_DIR/src/menu/intro_geo.o(.data*);
+      BUILD_DIR/src/menu/file_select.o(.data*);
+      BUILD_DIR/src/menu/file_select.o(.rodata*);
+      BUILD_DIR/src/menu/star_select.o(.data*);
+      BUILD_DIR/src/menu/star_select.o(.rodata*);
+      BUILD_DIR/src/menu*.o(.data*);
+      BUILD_DIR/src/menu*.o(.rodata*);
+      /* goddard subsystem data */
+      BUILD_DIR/libgoddard.a:gd_main.o(.data*);
+      BUILD_DIR/libgoddard.a:draw_objects.o(.data*);
+      BUILD_DIR/libgoddard.a:objects.o(.data*);
+      BUILD_DIR/libgoddard.a:particles.o(.data*);
+      BUILD_DIR/libgoddard.a:dynlist_proc.o(.data*);
+      BUILD_DIR/libgoddard.a:debug_utils.o(.data*);
+      BUILD_DIR/libgoddard.a:joints.o(.data*);
+      BUILD_DIR/libgoddard.a:shape_helper.o(.data*);
+      BUILD_DIR/libgoddard.a:renderer.o(.data*);
+      /* goddard subsystem rodata */
+      BUILD_DIR/libgoddard.a:gd_main.o(.rodata*);
+      BUILD_DIR/libgoddard.a:gd_memory.o(.rodata*);
+      BUILD_DIR/libgoddard.a:draw_objects.o(.rodata*);
+      BUILD_DIR/libgoddard.a:objects.o(.rodata*);
+      BUILD_DIR/libgoddard.a:skin_movement.o(.rodata*);
+      BUILD_DIR/libgoddard.a:particles.o(.rodata*);
+      BUILD_DIR/libgoddard.a:dynlist_proc.o(.rodata*);
+      BUILD_DIR/libgoddard.a:old_menu.o(.rodata*);
+      BUILD_DIR/libgoddard.a:debug_utils.o(.rodata*);
+      BUILD_DIR/libgoddard.a:joints.o(.rodata*);
+      BUILD_DIR/libgoddard.a:skin.o(.rodata*);
+      BUILD_DIR/libgoddard.a:gd_math.o(.rodata*);
+      BUILD_DIR/libgoddard.a:shape_helper.o(.rodata*);
+      BUILD_DIR/libgoddard.a:renderer.o(.rodata*);
+   }
+   END_SEG(goddard)
+   BEGIN_NOLOAD(goddard)
+   {
+      BUILD_DIR/src/menu/intro_geo.o(.bss*);
+      BUILD_DIR/src/menu/file_select.o(.bss*);
+      BUILD_DIR/src/menu/star_select.o(.bss*);
+      BUILD_DIR/src/menu*.o(.bss*);
+      BUILD_DIR/libgoddard.a:gd_main.o(.bss*);
+      BUILD_DIR/libgoddard.a:gd_memory.o(.bss*);
+      BUILD_DIR/libgoddard.a:sfx.o(.bss*);
+      BUILD_DIR/libgoddard.a:draw_objects.o(.bss*);
+      BUILD_DIR/libgoddard.a:objects.o(.bss*);
+      BUILD_DIR/libgoddard.a:skin_movement.o(.bss*);
+      BUILD_DIR/libgoddard.a:particles.o(.bss*);
+      BUILD_DIR/libgoddard.a:dynlist_proc.o(.bss*);
+      BUILD_DIR/libgoddard.a:old_menu.o(.bss*);
+      BUILD_DIR/libgoddard.a:debug_utils.o(.bss*);
+      BUILD_DIR/libgoddard.a:joints.o(.bss*);
+      BUILD_DIR/libgoddard.a:skin.o(.bss*);
+      BUILD_DIR/libgoddard.a:shape_helper.o(.bss*);
+      BUILD_DIR/libgoddard.a:renderer.o(.bss*);
+      BUILD_DIR/libgoddard.a:*.o(.bss*);
+   }
+   END_NOLOAD(goddard)
+
+   ASSERT((. <= SEG_POOL_END), "Error: extended past pool end.")
+
+   . = SEG_BUFFERS;
+   BEGIN_NOLOAD(buffers)
+   {
+      BUILD_DIR/src/buffers/buffers.o(.bss*);
+      BUILD_DIR/src/audio/globals_start.o(.bss*);
+
+      BUILD_DIR/src/audio/synthesis.o(.bss*);
+      BUILD_DIR/src/audio/heap.o(.bss*);
+      BUILD_DIR/src/audio/load.o(.bss*);
+      BUILD_DIR/src/audio/data.o(.bss*);
+      BUILD_DIR/src/audio/globals_end.o(.bss*);
+#ifdef VERSION_EU
+      . += 0x4f0;
+#endif
+      
+#ifndef VERSION_EU
+      . = ALIGN(0x1000);
+#endif
+      BUILD_DIR/src/buffers/gfx_output_buffer.o(.bss*);
+
+      BUILD_DIR/src/audio*.o(.bss*);
+   }
+   END_NOLOAD(buffers)
+
+   /* While EU is being worked on, don't warn for a too large buffers segment.
+    * This is a broken thing to do, so please enforce this again when it's fixed! */
+#ifndef VERSION_EU
+   ASSERT((. <= SEG_MAIN), "Error: buffers segment extended into main.")
+#endif
+
+   /* 0x268020 0x268020-0 [0] */
+   BEGIN_SEG(intro, 0x14000000)
+   {
+      BUILD_DIR/levels/intro/script.o(.data);
+      BUILD_DIR/levels/intro/geo.o(.data);
+   }
+   END_SEG(intro)
+   BEGIN_SEG(intro_segment_7, 0x07000000)
+   {
+      BUILD_DIR/levels/intro/leveldata.mio0.o(.data);
+      . = ALIGN(0x10);
+   }
+   END_SEG(intro_segment_7)
+
+   MIO0_SEG(debug_level_select, 0x07000000)
+   MIO0_SEG(title_screen_bg, 0x0A000000)
+
+   /* 271B20-2A42A0 [32780] */
+   BEGIN_SEG(gd_dynlists, 0x04000000)
+   {
+      BUILD_DIR/libgoddard.a:dynlist_test_cube.o(.data);
+      BUILD_DIR/libgoddard.a:dynlist_unused.o(.data);
+      BUILD_DIR/libgoddard.a:dynlist_mario_face.o(.data);
+      BUILD_DIR/libgoddard.a:dynlists_mario_eyes.o(.data);
+      BUILD_DIR/libgoddard.a:dynlists_mario_eyebrows_mustache.o(.data);
+      BUILD_DIR/libgoddard.a:dynlist_mario_master.o(.data);
+      BUILD_DIR/libgoddard.a:anim_mario_mustache_right.o(.data);
+      BUILD_DIR/libgoddard.a:anim_mario_mustache_left.o(.data);
+      BUILD_DIR/libgoddard.a:anim_mario_lips_1.o(.data);
+      BUILD_DIR/libgoddard.a:anim_mario_lips_2.o(.data);
+      BUILD_DIR/libgoddard.a:anim_mario_eyebrows_1.o(.data);
+      BUILD_DIR/libgoddard.a:anim_group_1.o(.data);
+      BUILD_DIR/libgoddard.a:anim_group_2.o(.data);
+      BUILD_DIR/libgoddard.a:dynlist_test_cube.o(.rodata*);
+      BUILD_DIR/libgoddard.a:dynlist_unused.o(.rodata*);
+      BUILD_DIR/libgoddard.a:*.o(.data);
+      BUILD_DIR/libgoddard.a:*.o(.rodata);
+   }
+   END_SEG(gd_dynlists)
+
+   gMainLevels = __romPos;
+
+   BEGIN_SEG(menu, 0x14000000)
+   {
+      BUILD_DIR/levels/menu/script.o(.data);
+      BUILD_DIR/levels/menu/geo.o(.data);
+   }
+   END_SEG(menu)
+   BEGIN_SEG(menu_segment_7, 0x07000000)
+   {
+      BUILD_DIR/levels/menu/leveldata.mio0.o(.data);
+      . = ALIGN(0x10);
+   }
+   END_SEG(menu_segment_7)
+
+   BEGIN_SEG(scripts, 0x15000000)
+   {
+      BUILD_DIR/levels/scripts.o(.data);
+   }
+   END_SEG(scripts)
+
+   MIO0_SEG(water_skybox, 0x0A000000)
+   MIO0_SEG(ccm_skybox, 0x0A000000)
+   MIO0_SEG(clouds_skybox, 0x0A000000)
+   MIO0_SEG(bitfs_skybox, 0x0A000000)
+   MIO0_SEG(wdw_skybox, 0x0A000000)
+   MIO0_SEG(cloud_floor_skybox, 0x0A000000)
+   MIO0_SEG(ssl_skybox, 0x0A000000)
+   MIO0_SEG(bbh_skybox, 0x0A000000)
+   MIO0_SEG(bidw_skybox, 0x0A000000)
+   MIO0_SEG(bits_skybox, 0x0A000000)
+
+   // Texture bins
+   MIO0_SEG(fire, 0x09000000)
+   MIO0_SEG(spooky, 0x09000000)
+   MIO0_SEG(generic, 0x09000000)
+   MIO0_SEG(water, 0x09000000)
+   MIO0_SEG(sky, 0x09000000)
+   MIO0_SEG(snow, 0x09000000)
+   MIO0_SEG(cave, 0x09000000)
+   MIO0_SEG(machine, 0x09000000)
+   MIO0_SEG(mountain, 0x09000000)
+   MIO0_SEG(grass, 0x09000000)
+   MIO0_SEG(outside, 0x09000000)
+   MIO0_SEG(inside, 0x09000000)
+   MIO0_SEG(effect, 0x0B000000)
+
+#define STUB_LEVEL(_0, _1, _2, _3, _4, _5, _6, _7, _8)
+#define DEFINE_LEVEL(_0, _1, _2, folder, _4, _5, _6, _7, _8, _9, _10) STANDARD_LEVEL(folder)
+
+   #include "levels/level_defines.h"
+
+#undef STUB_LEVEL
+#undef DEFINE_LEVEL
+
+   /* 4E9FA0-? [?] */
+   BEGIN_SEG(assets, __romPos)
+   {
+      BUILD_DIR/assets/mario_anim_data.o(.data);
+      BUILD_DIR/assets/mario_anim_data.o(.rodata);
+      BUILD_DIR/assets/demo_data.o(.data);
+      gSoundDataADSR = .;
+      BUILD_DIR/sound/sound_data.ctl.o(.data);
+      gSoundDataRaw = .;
+      BUILD_DIR/sound/sound_data.tbl.o(.data);
+      gMusicData = .;
+      BUILD_DIR/sound/sequences.bin.o(.data);
+      gBankSetsData = .;
+      BUILD_DIR/sound/bank_sets.o(.data);
+   }
+   END_SEG(assets)
+
+   /* Discard everything not specifically mentioned above. */
+   /DISCARD/ :
+   {
+      *(*);
+   }
+}
diff --git a/src/game/area.c b/src/game/area.c
index 82d17a3..301ab90 100644
--- a/src/game/area.c
+++ b/src/game/area.c
@@ -119,8 +119,8 @@ void print_intro_text(void) {
 #ifdef VERSION_EU
             print_text(20, 20, "START");
 #else
-            print_text_centered(60, 38, "PRESS");
-            print_text_centered(60, 20, "START");
+            print_text_centered(60, 38, "BRRRR");
+            print_text_centered(60, 20, "AP!!!");
 #endif
         }
     }
diff --git a/src/game/camera.c b/src/game/camera.c
index e0bf05f..1e879a0 100644
--- a/src/game/camera.c
+++ b/src/game/camera.c
@@ -2142,7 +2142,7 @@ s16 update_default_camera(struct Camera *c) {
             nextYawVel = 0x100;
         }
         if ((gPlayer1Controller->stickX != 0.f || gPlayer1Controller->stickY != 0.f) != 0) {
-            nextYawVel = 0x20;
+            nextYawVel = 0x50;
         }
     } else {
         if (sCSideButtonYaw < 0) {
diff --git a/src/game/crash.c b/src/game/crash.c
new file mode 100644
index 0000000..587ac86
--- /dev/null
+++ b/src/game/crash.c
@@ -0,0 +1,291 @@
+/* SM64 Crash Handler */
+
+#include <sm64.h>
+
+#include "crash.h"
+
+extern u32 exceptionRegContext[];
+
+extern char *pAssertFile;
+extern int nAssertLine;
+extern char *pAssertExpression;
+extern int nAssertStopProgram;
+
+u16 fbFillColor = 0xFFFF;
+u16 fbShadeColor = 0x0000;
+u16 *fbAddress = NULL;
+
+extern u8 crashFont[];
+
+const char *szErrCodes[] = {
+    "INTERRUPT",
+    "TLB MOD",
+    "UNMAPPED LOAD ADDR",
+    "UNMAPPED STORE ADDR",
+    "BAD LOAD ADDR",
+    "BAD STORE ADDR",
+    "BUS ERR ON INSTR FETCH",
+    "BUS ERR ON LOADSTORE",
+    "SYSCALL",
+    "BREAKPOINT",
+    "UNKNOWN INSTR",
+    "COP UNUSABLE",
+    "ARITHMETIC OVERFLOW",
+    "TRAP EXC",
+    "VIRTUAL COHERENCY INSTR",
+    "FLOAT EXC",
+};
+
+const char *szGPRegisters1[] = { "R0", "AT", "V0", "V1", "A0", "A1", "A2", "A3",
+                                 "T0", "T1", "T2", "T3", "T4", "T5", "T6", NULL };
+
+const char *szGPRegisters2[] = { "T7", "S0", "S1", "S2", "S3", "S4",
+                                 "S5", "S6", "S7", "T8", "T9", /*"K0", "K1",*/
+                                 "GP", "SP", "FP", "RA", NULL };
+
+/*
+    Generates new preamble code at the exception vectors (0x000, 0x180)
+
+    eg: generate_exception_preambles(crash_handler_entry);
+
+    000: lui   k0, hi(crash_handler_entry)
+    004: addiu k0, k0, lo(crash_handler_entry)
+    008: jr    k0
+    00C: nop
+*/
+void generate_exception_preambles(void *entryPoint) {
+    u8 *mem = (u8 *) 0xA0000000;
+    int offs = 0;
+    int i;
+
+    u16 hi = (u32) entryPoint >> 16;
+    u16 lo = (u32) entryPoint & 0xFFFF;
+
+    if (lo & 0x8000) {
+        hi++;
+    }
+
+    for (i = 0; i < 2; i++) {
+        *(u32 *) &mem[offs + 0x00] = 0x3C1A0000 | hi;
+        *(u32 *) &mem[offs + 0x04] = 0x275A0000 | lo;
+        *(u32 *) &mem[offs + 0x08] = 0x03400008;
+        *(u32 *) &mem[offs + 0x0C] = 0x00000000;
+        offs += 0x180;
+    }
+}
+
+int crash_strlen(char *str) {
+    int len = 0;
+    while (*str++) {
+        len++;
+    }
+    return len;
+}
+
+void show_crash_screen_and_hang(void) {
+    u32 cause;
+    u32 epc;
+    u8 errno;
+
+    fb_set_address((void *) (*(u32 *) 0xA4400004 | 0x80000000)); // replace me
+
+    cause = cop0_get_cause();
+    epc = cop0_get_epc();
+
+    errno = (cause >> 2) & 0x1F;
+
+    if (nAssertStopProgram == 0) {
+        fbFillColor = 0x6253;
+        fb_fill(10, 10, 300, 220);
+
+        fb_print_str(80, 20, "AN ERROR HAS OCCURRED!");
+        fb_print_int_hex(80, 30, errno, 8);
+        fb_print_str(107, 30, szErrCodes[errno]);
+
+        if (errno >= 2 && errno <= 5) {
+            /*
+            2 UNMAPPED LOAD ADDR
+            3 UNMAPPED STORE ADDR
+            4 BAD LOAD ADDR
+            5 BAD STORE ADDR
+            */
+            u32 badvaddr = cop0_get_badvaddr();
+
+            fb_print_str(188, 50, "VA");
+            fb_print_int_hex(215, 50, badvaddr, 32);
+        }
+    } else {
+        int afterFileX;
+        int exprBoxWidth;
+        fbFillColor = 0x5263;
+        fb_fill(10, 10, 300, 220);
+
+        fb_print_str(80, 20, "ASSERTION FAILED!");
+
+        afterFileX = fb_print_str(80, 30, pAssertFile);
+        fb_print_str(afterFileX, 30, ":");
+        fb_print_uint(afterFileX + 5, 30, nAssertLine);
+
+        exprBoxWidth = (crash_strlen(pAssertExpression) * 5) + 2;
+        fbFillColor = 0x0001;
+        fb_fill(80 - 1, 40 - 1, exprBoxWidth, 10);
+        fb_print_str(80, 40, pAssertExpression);
+    }
+
+    fb_print_str(80, 50, "PC");
+    fb_print_int_hex(95, 50, epc, 32);
+
+    fb_print_gpr_states(80, 70, szGPRegisters1, &exceptionRegContext[6 + 0]);
+    fb_print_gpr_states(145, 70, szGPRegisters2, &exceptionRegContext[6 + 15 * 2]);
+
+    fb_swap();
+    osWritebackDCacheAll();
+
+    while (1) // hang forever
+    {
+        UNUSED volatile int t = 0; // keep pj64 happy
+    }
+}
+
+u8 ascii_to_idx(char c) {
+    return c - 0x20;
+}
+
+void fb_set_address(void *address) {
+    fbAddress = (u16 *) address;
+}
+
+void fb_swap() {
+    // update VI frame buffer register
+    // todo other registers
+    *(u32 *) (0xA4400004) = (u32) fbAddress & 0x00FFFFFF;
+}
+
+void fb_fill(int baseX, int baseY, int width, int height) {
+    int y, x;
+
+    for (y = baseY; y < baseY + height; y++) {
+        for (x = baseX; x < baseX + width; x++) {
+            fbAddress[y * 320 + x] = fbFillColor;
+        }
+    }
+}
+
+void fb_draw_char(int x, int y, u8 idx) {
+    u16 *out = &fbAddress[y * 320 + x];
+    const u8 *in = &crashFont[idx * 3];
+    int nbyte;
+    int nrow;
+    int ncol;
+
+    for (nbyte = 0; nbyte < 3; nbyte++) {
+        u8 curbyte = in[nbyte];
+        for (nrow = 0; nrow < 2; nrow++) {
+            for (ncol = 0; ncol < 4; ncol++) {
+                u8 px = curbyte & (1 << 7 - (nrow * 4 + ncol));
+                if (px != 0) {
+                    out[ncol] = fbFillColor;
+                }
+            }
+            out += 320;
+        }
+    }
+}
+
+void fb_draw_char_shaded(int x, int y, u8 idx) {
+    fbFillColor = 0x0001;
+    fb_draw_char(x - 1, y + 1, idx);
+
+    fbFillColor = 0xFFFF;
+    fb_draw_char(x, y, idx);
+}
+
+int fb_print_str(int x, int y, const char *str) {
+    while (1) {
+        int yoffs = 0;
+        u8 idx;
+        char c = *str++;
+
+        if (c == '\0') {
+            break;
+        }
+
+        if (c == ' ') {
+            x += 5;
+            continue;
+        }
+
+        switch (c) {
+            case 'j':
+            case 'g':
+            case 'p':
+            case 'q':
+            case 'y':
+            case 'Q':
+                yoffs = 1;
+                break;
+            case ',':
+                yoffs = 2;
+                break;
+        }
+
+        idx = ascii_to_idx(c);
+        fb_draw_char_shaded(x, y + yoffs, idx);
+        x += 5;
+    }
+
+    return x;
+}
+
+void fb_print_int_hex(int x, int y, u32 value, int nbits) {
+    nbits -= 4;
+
+    while (nbits >= 0) {
+        int nib = ((value >> nbits) & 0xF);
+        u8 idx;
+
+        if (nib > 9) {
+            idx = ('A' - 0x20) + (nib - 0xa);
+        } else {
+            idx = ('0' - 0x20) + nib;
+        }
+
+        fb_draw_char_shaded(x, y, idx);
+        x += 5;
+
+        nbits -= 4;
+    }
+}
+
+int fb_print_uint(int x, int y, u32 value) {
+    int nchars = 0;
+
+    int v = value;
+    int i;
+    while (v /= 10) {
+        nchars++;
+    }
+
+    x += nchars * 5;
+
+    for (i = nchars; i >= 0; i--) {
+        fb_draw_char_shaded(x, y, ('0' - 0x20) + (value % 10));
+        value /= 10;
+        x -= 5;
+    }
+
+    return (x + nchars * 5);
+}
+
+void fb_print_gpr_states(int x, int y, const char *regNames[], u32 *regContext) {
+    int i;
+    for (i = 0;; i++) {
+        if (regNames[i] == NULL) {
+            break;
+        }
+
+        fb_print_str(x, y, regNames[i]);
+        fb_print_int_hex(x + 15, y, regContext[i * 2 + 1], 32);
+        y += 10;
+    }
+}
diff --git a/src/game/crash.h b/src/game/crash.h
new file mode 100644
index 0000000..da4e011
--- /dev/null
+++ b/src/game/crash.h
@@ -0,0 +1,29 @@
+#ifndef _CRASH_H_
+#define _CRASH_H_
+
+#include <types.h>
+
+#define CRASH_SCREEN_INCLUDED 1
+
+extern u32 cop0_get_cause(void);
+extern u32 cop0_get_epc(void);
+extern u32 cop0_get_badvaddr(void);
+
+extern void _n64_assert(const char* pFile, int nLine, const char *pExpression, int nStopProgram);
+
+extern u8 __crash_handler_entry[];
+
+void generate_exception_preambles(void *entryPoint);
+void show_crash_screen_and_hang(void);
+u8 ascii_to_idx(char c);
+void fb_set_address(void *address);
+void fb_swap(void);
+void fb_fill(int baseX, int baseY, int width, int height);
+void fb_draw_char(int x, int y, u8 idx);
+void fb_draw_char_shaded(int x, int y, u8 idx);
+int fb_print_str(int x, int y, const char *str);
+int fb_print_uint(int x, int y, u32 value);
+void fb_print_int_hex(int x, int y, u32 value, int nbits);
+void fb_print_gpr_states(int x, int y, const char* regStrs[], u32 *regContext);
+
+#endif /* _CRASH_H_ */
diff --git a/src/game/mario.c b/src/game/mario.c
index aace34f..419315e 100644
--- a/src/game/mario.c
+++ b/src/game/mario.c
@@ -790,6 +790,11 @@ static u32 set_mario_action_airborne(struct MarioState *m, u32 action, u32 actio
             m->forwardVel *= 0.8f;
             break;
 
+        case ACT_GROUND_POUND_JUMP:
+            set_mario_y_vel_based_on_fspeed(m, 65.0f, 0.0f);
+            m->forwardVel *= 0.8f;
+            break;
+
         case ACT_BACKFLIP:
             m->marioObj->header.gfx.unk38.animID = -1;
             m->forwardVel = -16.0f;
@@ -862,6 +867,11 @@ static u32 set_mario_action_airborne(struct MarioState *m, u32 action, u32 actio
             }
             mario_set_forward_vel(m, fowardVel);
             break;
+        
+        case ACT_GROUND_POUND_DIVE:
+            mario_set_forward_vel(m, 60.0f);
+            m->vel[1] = 15.0f;
+            break;
 
         case ACT_LONG_JUMP:
             m->marioObj->header.gfx.unk38.animID = -1;
@@ -1039,7 +1049,7 @@ s32 set_jump_from_landing(struct MarioState *m) {
                     break;
 
                 case ACT_FREEFALL_LAND:
-                    set_mario_action(m, ACT_DOUBLE_JUMP, 0);
+                    set_mario_action(m, ACT_JUMP, 0);
                     break;
 
                 case ACT_SIDE_FLIP_LAND_STOP:
diff --git a/src/game/mario.h b/src/game/mario.h
index 204cffc..518cdef 100644
--- a/src/game/mario.h
+++ b/src/game/mario.h
@@ -36,7 +36,8 @@ extern s32 mario_facing_downhill(struct MarioState *m, s32 turnYaw);
 extern u32 mario_floor_is_slippery(struct MarioState *m);
 extern s32 mario_floor_is_slope(struct MarioState *m);
 extern s32 mario_floor_is_steep(struct MarioState *m);
-extern f32 find_floor_height_relative_polar(struct MarioState *m, s16 angleFromMario, f32 distFromMario);
+extern f32 find_floor_height_relative_polar(struct MarioState *m, s16 angleFromMario,
+                                            f32 distFromMario);
 extern s16 find_floor_slope(struct MarioState *m, s16 yawOffset);
 extern void update_mario_sound_and_camera(struct MarioState *m);
 extern void set_steep_jump_action(struct MarioState *m);
@@ -53,4 +54,15 @@ extern s32 execute_mario_action(struct Object *o);
 extern void init_mario(void);
 extern void init_mario_from_save_file(void);
 
+/* clang-format off */
+// ADDITIONAL ACTIONS
+#define ACT_LEDGE_MOVE                  0x00000550 // (0x150 | ACT_FLAG_MOVING)
+
+#define ACT_WALL_KICK_SLIDE             0x0000088F // (0x08F | ACT_FLAG_AIR)
+#define ACT_GROUND_POUND_DIVE           0x01880891 // (0x091 | ACT_FLAG_AIR | ACT_FLAG_DIVING | ACT_FLAG_ATTACKING | ACT_FLAG_ALLOW_VERTICAL_WIND_ACTION)
+#define ACT_GROUND_POUND_JUMP           0x03000890 // (0x090 | ACT_FLAG_AIR | ACT_FLAG_ALLOW_VERTICAL_WIND_ACTION | ACT_FLAG_CONTROL_JUMP_HEIGHT)
+
+#define ACT_WATER_GROUND_POUND          0x300024FC // (0x0FC | ACT_FLAG_MOVING | ACT_FLAG_SWIMMING | ACT_FLAG_SWIMMING_OR_FLYING | ACT_FLAG_WATER_OR_TEXT)
+#define ACT_QUICK_DIVE                  0x300024FD // (0x0FD | ACT_FLAG_MOVING | ACT_FLAG_SWIMMING | ACT_FLAG_SWIMMING_OR_FLYING | ACT_FLAG_WATER_OR_TEXT)
+
 #endif /* _MARIO_H */
diff --git a/src/game/mario_actions_airborne.c b/src/game/mario_actions_airborne.c
index 92e5dab..1a9a6de 100644
--- a/src/game/mario_actions_airborne.c
+++ b/src/game/mario_actions_airborne.c
@@ -103,7 +103,11 @@ s32 check_fall_damage(struct MarioState *m, u32 hardFallAction) {
 
 s32 check_kick_or_dive_in_air(struct MarioState *m) {
     if (m->input & INPUT_B_PRESSED) {
-        return set_mario_action(m, m->forwardVel > 28.0f ? ACT_DIVE : ACT_JUMP_KICK, 0);
+        return set_mario_action(m,
+                                m->forwardVel > 28.0f
+                                    ? (m->input & INPUT_NONZERO_ANALOG ? ACT_DIVE : ACT_JUMP_KICK)
+                                    : ACT_JUMP_KICK,
+                                0);
     }
     return FALSE;
 }
@@ -455,9 +459,10 @@ s32 act_jump(struct MarioState *m) {
 }
 
 s32 act_double_jump(struct MarioState *m) {
-    s32 animation = (m->vel[1] >= 0.0f) 
-        ? MARIO_ANIM_DOUBLE_JUMP_RISE 
-        : MARIO_ANIM_DOUBLE_JUMP_FALL;
+    s32 animation =
+        m->action == ACT_GROUND_POUND_JUMP
+            ? MARIO_ANIM_SINGLE_JUMP
+            : ((m->vel[1] >= 0.0f) ? MARIO_ANIM_DOUBLE_JUMP_RISE : MARIO_ANIM_DOUBLE_JUMP_FALL);
 
     if (check_kick_or_dive_in_air(m)) {
         return TRUE;
@@ -467,6 +472,11 @@ s32 act_double_jump(struct MarioState *m) {
         return set_mario_action(m, ACT_GROUND_POUND, 0);
     }
 
+    if (m->action == ACT_GROUND_POUND_JUMP) {
+        m->marioObj->header.gfx.angle[1] = DEGREES(360 - (12 * m->actionTimer++));
+        if (m->actionTimer == 31) m->actionTimer = 30;
+    }
+
     play_mario_sound(m, SOUND_ACTION_TERRAIN_JUMP, SOUND_MARIO_HOOHOO);
     common_air_action_step(m, ACT_DOUBLE_JUMP_LAND, animation,
                            AIR_STEP_CHECK_LEDGE_GRAB | AIR_STEP_CHECK_HANG);
@@ -503,6 +513,22 @@ s32 act_triple_jump(struct MarioState *m) {
 }
 
 s32 act_backflip(struct MarioState *m) {
+    if (m->actionTimer++ >= 8 && m->wall && m->input & INPUT_NONZERO_ANALOG) {
+        s16 wallDYaw, wallDJoy;
+        s16 angle = m->faceAngle[1];
+        if (m->forwardVel < 0)
+            angle += 0x8000;
+        wallDYaw = atan2s(m->wall->normal.z, m->wall->normal.x) - angle;
+        wallDJoy = atan2s(m->wall->normal.z, m->wall->normal.x) - m->intendedYaw;
+
+        if ((wallDJoy < -0x6000 || wallDJoy > 0x6000) && (wallDYaw < -0x6000 || wallDYaw > 0x6000)) {
+            if (m->forwardVel >= 0)
+                m->faceAngle[1] += 0x8000;
+            play_sound(SOUND_ACTION_BONK, m->marioObj->header.gfx.cameraToObject);
+            return set_mario_action(m, ACT_WALL_KICK_SLIDE, 0);
+        }
+    }
+
     if (m->input & INPUT_Z_PRESSED) {
         return set_mario_action(m, ACT_GROUND_POUND, 0);
     }
@@ -627,6 +653,8 @@ s32 act_wall_kick_air(struct MarioState *m) {
 
 s32 act_long_jump(struct MarioState *m) {
     s32 animation;
+    m->forwardVel = MAX(m->forwardVel, 0.0f);
+
     if (!m->marioObj->oMarioLongJumpIsSlow) {
         animation = MARIO_ANIM_FAST_LONGJUMP;
     } else {
@@ -640,7 +668,8 @@ s32 act_long_jump(struct MarioState *m) {
         m->actionState = 1;
     }
 
-    common_air_action_step(m, ACT_LONG_JUMP_LAND, animation, AIR_STEP_CHECK_LEDGE_GRAB);
+    common_air_action_step(m, m->forwardVel > 20.0f ? ACT_LONG_JUMP_LAND : ACT_FREEFALL_LAND, animation,
+                           AIR_STEP_CHECK_LEDGE_GRAB);
 #ifdef VERSION_SH
     if (m->action == ACT_LONG_JUMP_LAND) {
         queue_rumble_data(5, 40);
@@ -677,8 +706,12 @@ s32 act_twirling(struct MarioState *m) {
     s16 startTwirlYaw = m->twirlYaw;
     s16 yawVelTarget;
 
-    if (m->input & INPUT_A_DOWN) {
+    if (m->input & INPUT_Z_DOWN) {
+        yawVelTarget = 0x2800;
+        m->pos[1] -= 30.0f;
+    } else if (m->input & INPUT_A_DOWN) {
         yawVelTarget = 0x2000;
+        m->pos[1] += 5.0f;
     } else {
         yawVelTarget = 0x1800;
     }
@@ -695,10 +728,18 @@ s32 act_twirling(struct MarioState *m) {
         play_sound(SOUND_ACTION_TWIRL, m->marioObj->header.gfx.cameraToObject);
     }
 
-    update_lava_boost_or_twirling(m);
-
+    if (!(m->input & INPUT_Z_DOWN))
+        update_lava_boost_or_twirling(m);
+    else {
+        m->particleFlags |= PARTICLE_DUST;
+        mario_set_forward_vel(m, 0.0f);
+    }
     switch (perform_air_step(m, 0)) {
         case AIR_STEP_LANDED:
+            if (m->input & INPUT_Z_DOWN) {
+                m->particleFlags |= PARTICLE_HORIZONTAL_STAR | PARTICLE_MIST_CIRCLE;
+                return set_mario_action(m, ACT_TRIPLE_JUMP_LAND, 0);
+            }
             set_mario_action(m, ACT_TWIRL_LAND, 0);
             break;
 
@@ -914,6 +955,10 @@ s32 act_ground_pound(struct MarioState *m) {
 
     play_sound_if_no_flag(m, SOUND_ACTION_THROW, MARIO_ACTION_SOUND_PLAYED);
 
+    if (m->input & INPUT_B_PRESSED) {
+        return set_mario_action(m, ACT_GROUND_POUND_DIVE, 0);
+    }
+
     if (m->actionState == 0) {
         if (m->actionTimer < 10) {
             yOffset = 20 - 2 * m->actionTimer;
@@ -1238,6 +1283,10 @@ s32 act_thrown_forward(struct MarioState *m) {
 }
 
 s32 act_soft_bonk(struct MarioState *m) {
+    if (!m->actionArg) {
+        m->faceAngle[1] += 0x8000;
+        return set_mario_action(m, ACT_WALL_KICK_SLIDE, 0);
+    }
     if (check_wall_kick(m)) {
         return 1;
     }
@@ -1333,7 +1382,7 @@ s32 act_air_hit_wall(struct MarioState *m) {
 #ifdef AVOID_UB
     return
 #endif
-    set_mario_animation(m, MARIO_ANIM_START_WALLKICK);
+        set_mario_animation(m, MARIO_ANIM_START_WALLKICK);
 
     //! Missing return statement. The returned value is the result of the call
     // to set_mario_animation. In practice, this value is nonzero.
@@ -1790,8 +1839,7 @@ s32 act_flying(struct MarioState *m) {
                     m->vel[1] = 0.0f;
                 }
 
-                play_sound((m->flags & MARIO_METAL_CAP) ? SOUND_ACTION_METAL_BONK
-                                                        : SOUND_ACTION_BONK,
+                play_sound((m->flags & MARIO_METAL_CAP) ? SOUND_ACTION_METAL_BONK : SOUND_ACTION_BONK,
                            m->marioObj->header.gfx.cameraToObject);
 
                 m->particleFlags |= PARTICLE_VERTICAL_STAR;
@@ -2054,7 +2102,72 @@ s32 check_common_airborne_cancels(struct MarioState *m) {
     return FALSE;
 }
 
+s32 act_wall_kick_slide(struct MarioState *m) {
+    s16 min, max;
+    f32 dividend;
+    mario_set_forward_vel(m, 0.0f);
+    if ((!m->actionTimer && !m->wallKickTimer && m->prevAction != ACT_BACKFLIP) || !m->wall) {
+        m->faceAngle[1] += 0x8000;
+        return set_mario_action(m, ACT_SOFT_BONK, 1);
+    }
+    if (m->input & INPUT_A_PRESSED) {
+        play_sound(SOUND_ACTION_BONK, m->marioObj->header.gfx.cameraToObject);
+        return set_mario_action(m, ACT_WALL_KICK_AIR, 0);
+    }
+    switch (m->wall->type) {
+        case SURFACE_NOT_SLIPPERY:
+        case SURFACE_HARD_NOT_SLIPPERY:
+        case SURFACE_SWITCH:
+            min = 5;
+            dividend = 2.0f;
+            max = 25;
+            break;
+
+        case SURFACE_SLIPPERY:
+        case SURFACE_NOISE_SLIPPERY:
+        case SURFACE_HARD_SLIPPERY:
+        case SURFACE_NO_CAM_COL_SLIPPERY:
+            min = 7;
+            dividend = 1.5f;
+            max = 30;
+            break;
+
+        case SURFACE_VERY_SLIPPERY:
+        case SURFACE_ICE:
+        case SURFACE_HARD_VERY_SLIPPERY:
+        case SURFACE_NOISE_VERY_SLIPPERY_73:
+        case SURFACE_NOISE_VERY_SLIPPERY_74:
+        case SURFACE_NOISE_VERY_SLIPPERY:
+        case SURFACE_NO_CAM_COL_VERY_SLIPPERY:
+            min = 7;
+            dividend = 0.75f;
+            max = 50;
+            break;
+        default:
+            if ((m->area->terrainType & TERRAIN_MASK) == TERRAIN_SLIDE) {
+                min = 7;
+                dividend = 0.75f;
+                max = 50;
+            } else {
+                min = 5;
+                dividend = 2.0f;
+                max = 25;
+            }
+    }
+    /*if (m->actionTimer == 0 && m->vel[1] < -min) {
+        m->actionTimer = (s16)((s16)m->vel[1] * dividend);      
+    }//*/
+    m->vel[1] = MAX(-((f32) min + m->actionTimer++ / dividend), -(f32) max);
+    if (!(m->actionTimer % 3))
+        m->particleFlags |= PARTICLE_DUST;
+    play_sound(SOUND_ENV_SLIDING, m->marioObj->header.gfx.cameraToObject);
+    set_anim_to_frame(m, 0);
+    m->input &= ~INPUT_NONZERO_ANALOG;
+    common_air_action_step(m, ACT_FREEFALL_LAND, MARIO_ANIM_START_WALLKICK, 0);
+}
+
 s32 mario_execute_airborne_action(struct MarioState *m) {
+    f32 rotate = 0.0f;
     u32 cancel;
 
     if (check_common_airborne_cancels(m)) {
@@ -2066,6 +2179,7 @@ s32 mario_execute_airborne_action(struct MarioState *m) {
     /* clang-format off */
     switch (m->action) {
         case ACT_JUMP:                 cancel = act_jump(m);                 break;
+        case ACT_GROUND_POUND_JUMP:
         case ACT_DOUBLE_JUMP:          cancel = act_double_jump(m);          break;
         case ACT_FREEFALL:             cancel = act_freefall(m);             break;
         case ACT_HOLD_JUMP:            cancel = act_hold_jump(m);            break;
@@ -2083,6 +2197,7 @@ s32 mario_execute_airborne_action(struct MarioState *m) {
         case ACT_LONG_JUMP:            cancel = act_long_jump(m);            break;
         case ACT_RIDING_SHELL_JUMP:
         case ACT_RIDING_SHELL_FALL:    cancel = act_riding_shell_air(m);     break;
+        case ACT_GROUND_POUND_DIVE:
         case ACT_DIVE:                 cancel = act_dive(m);                 break;
         case ACT_AIR_THROW:            cancel = act_air_throw(m);            break;
         case ACT_BACKWARD_AIR_KB:      cancel = act_backward_air_kb(m);      break;
@@ -2110,8 +2225,39 @@ s32 mario_execute_airborne_action(struct MarioState *m) {
         case ACT_RIDING_HOOT:          cancel = act_riding_hoot(m);          break;
         case ACT_TOP_OF_POLE_JUMP:     cancel = act_top_of_pole_jump(m);     break;
         case ACT_VERTICAL_WIND:        cancel = act_vertical_wind(m);        break;
+        case ACT_WALL_KICK_SLIDE:      cancel = act_wall_kick_slide(m);      break;
+    }
+
+    switch (m->action) {
+        case ACT_DIVE:
+        case ACT_GROUND_POUND_DIVE:
+        case ACT_STEEP_JUMP:
+        case ACT_RIDING_SHELL_FALL:
+        case ACT_SLIDE_KICK:
+        case ACT_WATER_JUMP:         rotate = 384.0f; break;
+        case ACT_AIR_THROW:
+        case ACT_FORWARD_ROLLOUT:
+        case ACT_BACKWARD_ROLLOUT:
+        case ACT_RIDING_SHELL_JUMP:  rotate = 640.0f; break;
+        case ACT_LONG_JUMP:
+            rotate = MAX(2048.f - 30.0f * m->forwardVel, 896.0f);
+            break;
+        case ACT_JUMP:
+        case ACT_DOUBLE_JUMP: case ACT_GROUND_POUND_JUMP:
+        case ACT_TRIPLE_JUMP: case ACT_SPECIAL_TRIPLE_JUMP:
+        case ACT_FREEFALL:
+            rotate = MAX(4192.0f - 120.0f * m->forwardVel,
+                         (m->action == ACT_JUMP || m->action == ACT_FREEFALL) ? 640.0f : 384.0f);
+            if (m->faceAngle[1] <= m->intendedYaw + 0x7000 && m->faceAngle[1] >= m->intendedYaw + 0x9000) {
+                m->intendedYaw += 20;
+                rotate = 4192.0f;
+            }
     }
     /* clang-format on */
 
+    if (m->input & INPUT_NONZERO_ANALOG) {
+        m->faceAngle[1] += sins(m->intendedYaw - m->faceAngle[1]) * m->intendedMag / 32.0f * rotate;
+    }
+
     return cancel;
 }
diff --git a/src/game/mario_actions_automatic.c b/src/game/mario_actions_automatic.c
index d2a3649..71b0a0d 100644
--- a/src/game/mario_actions_automatic.c
+++ b/src/game/mario_actions_automatic.c
@@ -547,20 +547,12 @@ s32 act_ledge_grab(struct MarioState *m) {
     s16 intendedDYaw = m->intendedYaw - m->faceAngle[1];
     s32 hasSpaceForMario = (m->ceilHeight - m->floorHeight >= 160.0f);
 
-    if (m->actionTimer < 10) {
-        m->actionTimer++;
-    }
-
-    if (m->floor->normal.y < 0.9063078f) {
-        return let_go_of_ledge(m);
-    }
-
-    if (m->input & (INPUT_Z_PRESSED | INPUT_OFF_FLOOR)) {
+    if (m->input & (INPUT_Z_PRESSED | INPUT_OFF_FLOOR) || m->floor->normal.y < 0.9063078f) {
         return let_go_of_ledge(m);
     }
 
-    if ((m->input & INPUT_A_PRESSED) && hasSpaceForMario) {
-        return set_mario_action(m, ACT_LEDGE_CLIMB_FAST, 0);
+    if ((m->input & (INPUT_A_PRESSED | INPUT_B_PRESSED)) && hasSpaceForMario) {
+        return set_mario_action(m, ACT_LEDGE_CLIMB_FAST, m->input & INPUT_A_PRESSED);
     }
 
     if (m->input & INPUT_UNKNOWN_10) {
@@ -571,15 +563,19 @@ s32 act_ledge_grab(struct MarioState *m) {
     }
 #ifdef VERSION_EU
     // On PAL, you can't slow climb up ledges while holding A.
-    if (m->actionTimer == 10 && (m->input & INPUT_NONZERO_ANALOG) && !(m->input & INPUT_A_DOWN))
+    if (m->actionTimer++ >= 10 && (m->input & INPUT_NONZERO_ANALOG) && !(m->input & INPUT_A_DOWN))
 #else
-    if (m->actionTimer == 10 && (m->input & INPUT_NONZERO_ANALOG))
+    if (m->actionTimer++ >= 10 && (m->input & INPUT_NONZERO_ANALOG))
 #endif
     {
         if (intendedDYaw >= -0x4000 && intendedDYaw <= 0x4000) {
             if (hasSpaceForMario) {
                 return set_mario_action(m, ACT_LEDGE_CLIMB_SLOW_1, 0);
             }
+        } else if (intendedDYaw >= -0x6000 && intendedDYaw <= 0x6000 && false) { //get back to this later
+            if (hasSpaceForMario) {
+                return set_mario_action(m, ACT_LEDGE_MOVE, intendedDYaw <= 0);
+            }
         } else {
             return let_go_of_ledge(m);
         }
@@ -600,6 +596,33 @@ s32 act_ledge_grab(struct MarioState *m) {
     return FALSE;
 }
 
+s32 act_ledge_move(struct MarioState *m) {
+    f32 heightAboveFloor;
+    s16 angle = m->marioObj->header.gfx.angle[1];
+    s16 intendedDYaw = m->intendedYaw - angle;
+    s32 hasSpaceForMario = (m->ceilHeight - m->floorHeight >= 160.0f);
+    if (m->input & (INPUT_Z_PRESSED | INPUT_OFF_FLOOR) || m->floor->normal.y < 0.9063078f) {
+        return let_go_of_ledge(m);
+    }
+    if ((m->input & (INPUT_A_PRESSED | INPUT_B_PRESSED)) && hasSpaceForMario) {
+        return set_mario_action(m, ACT_LEDGE_CLIMB_FAST, m->input & INPUT_A_PRESSED);
+    }
+    m->pos[0] += coss(angle) * (8 - m->actionTimer) * (m->actionArg ? -1 : 1);
+    m->pos[2] += sins(angle) * (8 - m->actionTimer) * (m->actionArg ? -1 : 1);
+    m->actionTimer++;
+    //stop_and_set_height_to_floor(m);
+    set_mario_anim_with_accel(m, MARIO_ANIM_SLOW_LEDGE_GRAB, 0xA000); //fixed point math
+    if (m->actionTimer == 2) {
+        //play_sound_if_no_flag(m, SOUND_MARIO_EEUH, MARIO_MARIO_SOUND_PLAYED);
+    }
+    if (m->actionTimer >= 6) {
+        set_mario_animation(m, MARIO_ANIM_IDLE_ON_LEDGE);
+        return set_mario_action(m, ACT_LEDGE_GRAB, 1);
+    }
+    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
+    return false;
+}
+
 s32 act_ledge_climb_slow(struct MarioState *m) {
     if (m->input & INPUT_OFF_FLOOR) {
         return let_go_of_ledge(m);
@@ -647,7 +670,12 @@ s32 act_ledge_climb_fast(struct MarioState *m) {
     play_sound_if_no_flag(m, SOUND_MARIO_UH2, MARIO_MARIO_SOUND_PLAYED);
 
     update_ledge_climb(m, MARIO_ANIM_FAST_LEDGE_GRAB, ACT_IDLE);
-
+    if (is_anim_past_frame(m, 6) && m->actionArg) {
+        m->pos[0] += 14.0f * sins(m->faceAngle[1]);
+        m->pos[2] += 14.0f * coss(m->faceAngle[1]);
+        vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
+        return set_mario_action(m, ACT_DOUBLE_JUMP, 0);
+    }
     if (m->marioObj->header.gfx.unk38.animFrame == 8) {
         play_mario_landing_sound(m, SOUND_ACTION_TERRAIN_LANDING);
     }
@@ -880,6 +908,7 @@ s32 mario_execute_automatic_action(struct MarioState *m) {
         case ACT_LEDGE_CLIMB_SLOW_2:     cancel = act_ledge_climb_slow(m);       break;
         case ACT_LEDGE_CLIMB_DOWN:       cancel = act_ledge_climb_down(m);       break;
         case ACT_LEDGE_CLIMB_FAST:       cancel = act_ledge_climb_fast(m);       break;
+        case ACT_LEDGE_MOVE:             cancel = act_ledge_move(m);             break;
         case ACT_GRABBED:                cancel = act_grabbed(m);                break;
         case ACT_IN_CANNON:              cancel = act_in_cannon(m);              break;
         case ACT_TORNADO_TWIRLING:       cancel = act_tornado_twirling(m);       break;
diff --git a/src/game/mario_actions_moving.c b/src/game/mario_actions_moving.c
index 57290d2..9a35852 100644
--- a/src/game/mario_actions_moving.c
+++ b/src/game/mario_actions_moving.c
@@ -36,11 +36,23 @@ struct LandingAction sSideFlipLandAction = {
 };
 
 struct LandingAction sHoldJumpLandAction = {
-    4, 5, ACT_HOLD_FREEFALL, ACT_HOLD_JUMP_LAND_STOP, ACT_HOLD_JUMP, ACT_HOLD_FREEFALL, ACT_HOLD_BEGIN_SLIDING,
+    4,
+    5,
+    ACT_HOLD_FREEFALL,
+    ACT_HOLD_JUMP_LAND_STOP,
+    ACT_HOLD_JUMP,
+    ACT_HOLD_FREEFALL,
+    ACT_HOLD_BEGIN_SLIDING,
 };
 
 struct LandingAction sHoldFreefallLandAction = {
-    4, 5, ACT_HOLD_FREEFALL, ACT_HOLD_FREEFALL_LAND_STOP, ACT_HOLD_JUMP, ACT_HOLD_FREEFALL, ACT_HOLD_BEGIN_SLIDING,
+    4,
+    5,
+    ACT_HOLD_FREEFALL,
+    ACT_HOLD_FREEFALL_LAND_STOP,
+    ACT_HOLD_JUMP,
+    ACT_HOLD_FREEFALL,
+    ACT_HOLD_BEGIN_SLIDING,
 };
 
 struct LandingAction sLongJumpLandAction = {
@@ -699,7 +711,8 @@ void push_or_sidle_wall(struct MarioState *m, Vec3f startPos) {
         }
 
         if (m->marioObj->header.gfx.unk38.animFrame < 20) {
-            play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
+            play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend,
+                       m->marioObj->header.gfx.cameraToObject);
             m->particleFlags |= PARTICLE_DUST;
         }
 
@@ -986,7 +999,8 @@ s32 act_turning_around(struct MarioState *m) {
         return begin_walking_action(m, 8.0f, ACT_FINISH_TURNING_AROUND, 0);
     }
 
-    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
+    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend,
+               m->marioObj->header.gfx.cameraToObject);
 
     adjust_sound_for_speed(m);
 
@@ -1069,7 +1083,8 @@ s32 act_braking(struct MarioState *m) {
             break;
     }
 
-    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
+    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend,
+               m->marioObj->header.gfx.cameraToObject);
     adjust_sound_for_speed(m);
     set_mario_animation(m, MARIO_ANIM_SKID_ON_GROUND);
     return FALSE;
@@ -1121,7 +1136,8 @@ s32 act_decelerating(struct MarioState *m) {
 
     if (slopeClass == SURFACE_CLASS_VERY_SLIPPERY) {
         set_mario_animation(m, MARIO_ANIM_IDLE_HEAD_LEFT);
-        play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
+        play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend,
+                   m->marioObj->header.gfx.cameraToObject);
         adjust_sound_for_speed(m);
         m->particleFlags |= PARTICLE_DUST;
     } else {
@@ -1187,7 +1203,8 @@ s32 act_hold_decelerating(struct MarioState *m) {
 
     if (slopeClass == SURFACE_CLASS_VERY_SLIPPERY) {
         set_mario_animation(m, MARIO_ANIM_IDLE_WITH_LIGHT_OBJ);
-        play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
+        play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend,
+                   m->marioObj->header.gfx.cameraToObject);
         adjust_sound_for_speed(m);
         m->particleFlags |= PARTICLE_DUST;
     } else {
@@ -1277,7 +1294,7 @@ s32 act_crawling(struct MarioState *m) {
         return set_mario_action(m, ACT_STOP_CRAWLING, 0);
     }
 
-    m->intendedMag *= 0.1f;
+    m->intendedMag *= 0.2f;
 
     update_walking_speed(m);
 
@@ -1296,8 +1313,8 @@ s32 act_crawling(struct MarioState *m) {
             align_with_floor(m);
             break;
     }
-
-    val04 = (s32)(m->intendedMag * 2.0f * 0x10000);
+    // m->intendedMag *= 0.4f; //0.25 -> 0.1
+    val04 = (s32)(m->intendedMag * 0x10000);
     set_mario_anim_with_accel(m, MARIO_ANIM_CRAWLING, val04);
     play_step_sound(m, 26, 79);
     return FALSE;
@@ -1359,14 +1376,16 @@ s32 act_burning_ground(struct MarioState *m) {
 void tilt_body_butt_slide(struct MarioState *m) {
     s16 intendedDYaw = m->intendedYaw - m->faceAngle[1];
     m->marioBodyState->torsoAngle[0] = (s32)(5461.3335f * m->intendedMag / 32.0f * coss(intendedDYaw));
-    m->marioBodyState->torsoAngle[2] = (s32)(-(5461.3335f * m->intendedMag / 32.0f * sins(intendedDYaw)));
+    m->marioBodyState->torsoAngle[2] =
+        (s32)(-(5461.3335f * m->intendedMag / 32.0f * sins(intendedDYaw)));
 }
 
 void common_slide_action(struct MarioState *m, u32 endAction, u32 airAction, s32 animation) {
     Vec3f val14;
 
     vec3f_copy(val14, m->pos);
-    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
+    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend,
+               m->marioObj->header.gfx.cameraToObject);
 
 #ifdef VERSION_SH
     reset_rumble_timers();
@@ -1449,7 +1468,8 @@ s32 act_hold_butt_slide(struct MarioState *m) {
         return drop_and_set_mario_action(m, ACT_BUTT_SLIDE, 0);
     }
 
-    cancel = common_slide_action_with_jump(m, ACT_HOLD_BUTT_SLIDE_STOP, ACT_HOLD_JUMP, ACT_HOLD_BUTT_SLIDE_AIR,
+    cancel = common_slide_action_with_jump(m, ACT_HOLD_BUTT_SLIDE_STOP, ACT_HOLD_JUMP,
+                                           ACT_HOLD_BUTT_SLIDE_AIR,
                                            MARIO_ANIM_SLIDING_ON_BOTTOM_WITH_LIGHT_OBJ);
     tilt_body_butt_slide(m);
     return cancel;
@@ -1518,7 +1538,8 @@ s32 act_slide_kick_slide(struct MarioState *m) {
             break;
     }
 
-    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
+    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend,
+               m->marioObj->header.gfx.cameraToObject);
     m->particleFlags |= PARTICLE_DUST;
     return FALSE;
 }
@@ -1545,13 +1566,27 @@ s32 stomach_slide_action(struct MarioState *m, u32 stopAction, u32 airAction, s3
 }
 
 s32 act_stomach_slide(struct MarioState *m) {
-    s32 cancel = stomach_slide_action(m, ACT_STOMACH_SLIDE_STOP, ACT_FREEFALL, MARIO_ANIM_SLIDE_DIVE);
+    s32 cancel;
+    if (m->input & (INPUT_A_PRESSED | INPUT_B_PRESSED) && m->forwardVel < -3.0f) {
+#ifdef VERSION_SH
+        queue_rumble_data(5, 80);
+#endif
+        return set_mario_action(m, ACT_FORWARD_ROLLOUT, 0);
+    }
+    cancel = stomach_slide_action(m, ACT_STOMACH_SLIDE_STOP, ACT_FREEFALL, MARIO_ANIM_SLIDE_DIVE);
     return cancel;
 }
 
 s32 act_hold_stomach_slide(struct MarioState *m) {
     s32 cancel;
 
+    if (m->input & (INPUT_A_PRESSED | INPUT_B_PRESSED) && m->forwardVel < -3.0f) {
+#ifdef VERSION_SH
+        queue_rumble_data(5, 80);
+#endif
+        return set_mario_action(m, ACT_FORWARD_ROLLOUT, 0);
+    }
+
     if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
         return drop_and_set_mario_action(m, ACT_STOMACH_SLIDE, 0);
     }
@@ -1561,7 +1596,7 @@ s32 act_hold_stomach_slide(struct MarioState *m) {
 }
 
 s32 act_dive_slide(struct MarioState *m) {
-    if (!(m->input & INPUT_ABOVE_SLIDE) && (m->input & (INPUT_A_PRESSED | INPUT_B_PRESSED))) {
+    if (m->input & (INPUT_A_PRESSED | INPUT_B_PRESSED)) {
 #ifdef VERSION_SH
         queue_rumble_data(5, 80);
 #endif
@@ -1779,7 +1814,7 @@ s32 common_landing_cancels(struct MarioState *m, struct LandingAction *landingAc
     }
 
     if (++m->actionTimer >= landingAction->numFrames) {
-        return set_mario_action(m, landingAction->endAction, 0);
+        return set_mario_action(m, landingAction->endAction, (m->prevAction == ACT_TWIRLING));
     }
 
     if (m->input & INPUT_A_PRESSED) {
@@ -1884,6 +1919,10 @@ s32 act_double_jump_land(struct MarioState *m) {
 }
 
 s32 act_triple_jump_land(struct MarioState *m) {
+
+    if ((m->input & INPUT_A_PRESSED) && m->prevAction == ACT_TWIRLING) {
+        return set_mario_action(m, ACT_GROUND_POUND_JUMP, 0);
+    }
     m->input &= ~INPUT_A_PRESSED;
 
     if (common_landing_cancels(m, &sTripleJumpLandAction, set_jumping_action)) {
@@ -1949,8 +1988,8 @@ s32 act_quicksand_jump_land(struct MarioState *m) {
 
 s32 act_hold_quicksand_jump_land(struct MarioState *m) {
     s32 cancel = quicksand_jump_land_action(m, MARIO_ANIM_JUMP_WITH_LIGHT_OBJ,
-                                            MARIO_ANIM_JUMP_LAND_WITH_LIGHT_OBJ, ACT_HOLD_JUMP_LAND_STOP,
-                                            ACT_HOLD_FREEFALL);
+                                            MARIO_ANIM_JUMP_LAND_WITH_LIGHT_OBJ,
+                                            ACT_HOLD_JUMP_LAND_STOP, ACT_HOLD_FREEFALL);
     return cancel;
 }
 
diff --git a/src/game/mario_actions_stationary.c b/src/game/mario_actions_stationary.c
index 33d2919..fa273df 100644
--- a/src/game/mario_actions_stationary.c
+++ b/src/game/mario_actions_stationary.c
@@ -650,6 +650,10 @@ s32 act_butt_slide_stop(struct MarioState *m) {
         return set_mario_action(m, ACT_SHOCKWAVE_BOUNCE, 0);
     }
 
+    if (m->prevAction == ACT_GROUND_POUND_LAND && m->input & INPUT_NONZERO_ANALOG) {
+        m->faceAngle[1] = m->intendedYaw;
+    } 
+
     if (m->input & (INPUT_NONZERO_ANALOG | INPUT_A_PRESSED | INPUT_OFF_FLOOR | INPUT_ABOVE_SLIDE)) {
         return check_common_action_exits(m);
     }
@@ -908,6 +912,10 @@ s32 act_freefall_land_stop(struct MarioState *m) {
 }
 
 s32 act_triple_jump_land_stop(struct MarioState *m) {
+    if ((m->input & INPUT_A_PRESSED) && m->actionArg == 1) {
+        return set_mario_action(m, ACT_GROUND_POUND_JUMP, 0);
+    }
+
     if (check_common_landing_cancels(m, ACT_JUMP)) {
         return 1;
     }
@@ -947,9 +955,9 @@ s32 act_long_jump_land_stop(struct MarioState *m) {
     }
 
     landing_step(m,
-                  !m->marioObj->oMarioLongJumpIsSlow ? MARIO_ANIM_CROUCH_FROM_FAST_LONGJUMP
-                                                     : MARIO_ANIM_CROUCH_FROM_SLOW_LONGJUMP,
-                  ACT_CROUCHING);
+                 !m->marioObj->oMarioLongJumpIsSlow ? MARIO_ANIM_CROUCH_FROM_FAST_LONGJUMP
+                                                    : MARIO_ANIM_CROUCH_FROM_SLOW_LONGJUMP,
+                 ACT_CROUCHING);
     return 0;
 }
 
@@ -1045,6 +1053,10 @@ s32 act_twirl_land(struct MarioState *m) {
 
 s32 act_ground_pound_land(struct MarioState *m) {
     m->actionState = 1;
+    if (m->input & INPUT_A_PRESSED) {
+        return set_mario_action(m, ACT_GROUND_POUND_JUMP, 0);
+    }
+
     if (m->input & INPUT_UNKNOWN_10) {
         return drop_and_set_mario_action(m, ACT_SHOCKWAVE_BOUNCE, 0);
     }
diff --git a/tools/create_patch_from_master.sh b/tools/create_patch_from_master.sh
new file mode 100644
index 0000000..06d8998
--- /dev/null
+++ b/tools/create_patch_from_master.sh
@@ -0,0 +1,25 @@
+#!/bin/sh
+#
+# create_patch.sh - Creates an enhancement patch based on the current Git changes
+#
+
+if [ "$#" -ne 1 ]
+then
+    echo "Usage: $0 patch_file"
+    echo '    Creates a patch file based on the changes made to the current directory'
+    exit 1
+fi
+
+# Make sure this is a git repository
+if [ ! -d .git ]
+then
+    echo 'Error: The current directory is not a Git repository.'
+    exit 1
+fi
+
+# 'git diff' is stupid and doesn't show new untracked files, so we must add them first.
+git add .
+# Generate the patch.
+git diff -p --staged 9a40d86f6a5d925c4dc62d1cc0b5c345400e8eff > "$1"
+# Undo the 'git add'. 
+git reset
